# ============================================================================
# Deploy webhook infrastructure using deployment script
# ============================================================================
name: Deploy Webhook SAM Infrastructure

on:
  push:
    branches: [ dev, main ]
    paths:
      - 'cmd/webhook-receiver/**'
      - 'cmd/webhook-processor/**'
      - 'cmd/dlq-processor/**'
      - 'deployment/template-webhook.yaml'
      - 'internal/client/payment_sync/**'
      - 'internal/handlers/payment_sync_handlers.go'
      - 'internal/handlers/error_recovery_handlers.go'
      - 'internal/db/webhook_management.sql.go'
      - 'internal/db/workspace_payment_configurations.sql.go'
      - 'internal/db/workspace_provider_accounts.sql.go'
      - 'internal/db/payment_sync.sql.go'
      - '.github/workflows/webhooks.yml'
      - '.github/workflows/deploy-webhook-sam.yml'
      - 'Dockerfile'
      - 'Dockerfile.webhook-receiver'
      - 'Dockerfile.webhook-processor'
      - '.dockerignore'
      - 'Makefile'
  pull_request:
    branches: [ dev, main ]
    paths:
      - 'cmd/webhook-receiver/**'
      - 'cmd/webhook-processor/**'
      - 'cmd/dlq-processor/**'
      - 'deployment/template-webhook.yaml'
      - 'internal/client/payment_sync/**'
      - 'internal/handlers/payment_sync_handlers.go'
      - 'internal/handlers/error_recovery_handlers.go'
      - 'internal/db/webhook_management.sql.go'
      - 'internal/db/workspace_payment_configurations.sql.go'
      - 'internal/db/workspace_provider_accounts.sql.go'
      - 'internal/db/payment_sync.sql.go'
      - '.github/workflows/webhooks.yml'
      - '.github/workflows/deploy-webhook-sam.yml'
      - 'Dockerfile'
      - 'Dockerfile.webhook-receiver'
      - 'Dockerfile.webhook-processor'
      - '.dockerignore'
      - 'Makefile'
  workflow_dispatch:
    inputs:
      stage:
        description: 'Deployment stage'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      force_deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        default: false
        type: boolean

env:
  GO_VERSION: '1.23'
  AWS_REGION: us-east-1
  STAGE: ${{ github.event.inputs.stage || (github.ref == 'refs/heads/main' && 'prod' || 'dev') }}
  SAM_TEMPLATE: deployment/template-webhook.yaml
  SAM_STACK_NAME_PREFIX: cyphera-webhook

jobs:
  # ============================================================================
  # Pre-deployment validation and testing
  # ============================================================================
  validate:
    name: Validate SAM Template and Dependencies
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Setup SAM CLI
      uses: aws-actions/setup-sam@v2
      with:
        use-installer: true

    - name: Validate SAM template
      run: |
        echo "üîç Validating SAM template..."
        sam validate --template ${{ env.SAM_TEMPLATE }} --region ${{ env.AWS_REGION }}
        echo "‚úÖ SAM template is valid"

    - name: Check required Go files exist
      run: |
        echo "üîç Checking required webhook command files..."
        test -f cmd/webhook-receiver/main.go || (echo "‚ùå webhook-receiver/main.go missing" && exit 1)
        test -f cmd/webhook-processor/main.go || (echo "‚ùå webhook-processor/main.go missing" && exit 1)
        test -f cmd/dlq-processor/main.go || (echo "‚ùå dlq-processor/main.go missing" && exit 1)
        echo "‚úÖ All required command files exist"

    - name: Check Makefile build targets
      run: |
        echo "üîç Checking Makefile build targets..."
        grep -q "build-WebhookReceiverFunction" Makefile || (echo "‚ùå build-WebhookReceiverFunction target missing" && exit 1)
        grep -q "build-WebhookProcessorFunction" Makefile || (echo "‚ùå build-WebhookProcessorFunction target missing" && exit 1)
        grep -q "build-DLQProcessorFunction" Makefile || (echo "‚ùå build-DLQProcessorFunction target missing" && exit 1)
        echo "‚úÖ All required build targets exist"

  # ============================================================================
  # Test webhook components
  # ============================================================================
  test:
    name: Test Webhook Components
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: cyphera_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}
        cache: true
        cache-dependency-path: go.sum

    - name: Install dependencies
      run: go mod download

    - name: Run webhook component tests
      env:
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/cyphera_test?sslmode=disable
        PAYMENT_SYNC_ENCRYPTION_KEY: fake_encryption_key_for_testing_32chars
      run: |
        echo "üß™ Testing webhook components..."
        go test -v ./cmd/webhook-receiver/... || echo "No tests in webhook-receiver yet"
        go test -v ./cmd/webhook-processor/... || echo "No tests in webhook-processor yet"
        go test -v ./cmd/dlq-processor/... || echo "No tests in dlq-processor yet"
        go test -v ./internal/client/payment_sync/...
        go test -v ./internal/handlers -run ".*PaymentSync.*"
        echo "‚úÖ Tests completed"

  # ============================================================================
  # Build webhook Lambda functions (separate job for caching/reuse)
  # ============================================================================
  build:
    name: Build Webhook Lambda Functions
    needs: [validate]
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    steps:
    - uses: actions/checkout@v4

    - name: Setup SAM CLI
      uses: aws-actions/setup-sam@v2
      with:
        use-installer: true

    - name: Cache SAM build artifacts
      uses: actions/cache@v4
      with:
        path: |
          .aws-sam/build
          .aws-sam/cache
        key: sam-build-${{ runner.os }}-${{ hashFiles('cmd/webhook-receiver/**', 'cmd/webhook-processor/**', 'cmd/dlq-processor/**', 'go.mod', 'go.sum', 'deployment/template-webhook.yaml') }}
        restore-keys: |
          sam-build-${{ runner.os }}-

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: go-${{ runner.os }}-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          go-${{ runner.os }}-

    - name: SAM Build with optimizations
      env:
        SAM_CLI_TELEMETRY: 0
      run: |
        echo "üî® Building webhook Lambda functions with optimizations..."
        
        # Use cached build if available and no changes detected
        if [ -d .aws-sam/build ] && [ -f .aws-sam/build/template.yaml ]; then
          echo "üì¶ Found cached build artifacts, checking if rebuild needed..."
          
          # Check if any source files are newer than the build
          if find cmd/webhook-receiver cmd/webhook-processor cmd/dlq-processor -newer .aws-sam/build/template.yaml 2>/dev/null | grep -q .; then
            echo "üîÑ Source files changed, rebuilding..."
            rm -rf .aws-sam/build
          else
            echo "‚úÖ Using cached build artifacts"
            exit 0
          fi
        fi
        
        # Build with optimizations
        sam build \
          --template deployment/template-webhook.yaml \
          --use-container \
          --parallel \
          --cached \
          --skip-pull-image
        
        echo "‚úÖ Build completed successfully"

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: sam-build-artifacts
        path: |
          .aws-sam/build/
          deployment/template-webhook.yaml
        retention-days: 1

  # ============================================================================
  # Deploy webhook infrastructure (separate job, reuses build artifacts)
  # ============================================================================
  deploy:
    name: Deploy Webhook SAM Infrastructure
    needs: [validate, test, build]
    runs-on: ubuntu-latest
    if: (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev')) || (github.event_name == 'workflow_dispatch') && (needs.test.result == 'success' || needs.test.result == 'skipped') && (needs.build.result == 'success')
    environment: ${{ github.event.inputs.stage || (github.ref == 'refs/heads/main' && 'prod' || 'dev') }}

    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup SAM CLI
      uses: aws-actions/setup-sam@v2
      with:
        use-installer: true

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: sam-build-artifacts
        path: .

    - name: Verify build artifacts
      run: |
        echo "üîç Verifying downloaded build artifacts..."
        ls -la .aws-sam/build/
        
        if [ ! -f .aws-sam/build/template.yaml ]; then
          echo "‚ùå Build template not found"
          exit 1
        fi
        
        # Check that all function artifacts exist
        for func in WebhookReceiverFunction WebhookProcessorFunction DLQProcessorFunction; do
          if [ ! -d ".aws-sam/build/$func" ]; then
            echo "‚ùå Function $func build artifacts not found"
            exit 1
          fi
          echo "‚úÖ Function $func artifacts found"
        done
        
        echo "‚úÖ All build artifacts verified"

    # ============================================================================
    # Deploy webhook infrastructure using deployment script
    # ============================================================================
    - name: Deploy webhook SAM infrastructure
      id: sam-deploy
      env:
        STAGE: ${{ env.STAGE }}
        AWS_REGION: ${{ env.AWS_REGION }}
        SAM_DEPLOYMENT_BUCKET: ${{ secrets.SAM_DEPLOYMENT_BUCKET }}
        LAMBDA_SG_ID: ${{ secrets.LAMBDA_SG_ID }}
        PRIVATE_SUBNET_1_ID: ${{ secrets.PRIVATE_SUBNET_1_ID }}
        PRIVATE_SUBNET_2_ID: ${{ secrets.PRIVATE_SUBNET_2_ID }}
      run: |
        echo "üöÄ Deploying webhook SAM infrastructure using pre-built artifacts..."
        echo "Stage: ${{ env.STAGE }}"
        echo "Region: ${{ env.AWS_REGION }}"
        
        # Make script executable (in case not set in repo)
        chmod +x scripts/deploy_webhook_lambdas.sh
        
        # Execute the deployment script (it will use existing .aws-sam/build)
        ./scripts/deploy_webhook_lambdas.sh
        
        # Set output for verification steps
        STACK_NAME="cyphera-webhook-${{ env.STAGE }}"
        echo "STACK_NAME=$STACK_NAME" >> $GITHUB_OUTPUT
        echo "‚úÖ Webhook SAM deployment completed successfully!"

    # ============================================================================
    # Verify deployment
    # ============================================================================
    - name: Verify webhook Lambda functions
      run: |
        echo "üîç Verifying webhook Lambda function deployment..."
        
        # Check all three Lambda functions exist and are in correct state
        FUNCTIONS=(
          "cyphera-webhook-receiver-${{ env.STAGE }}"
          "cyphera-webhook-processor-${{ env.STAGE }}"
          "cyphera-dlq-processor-${{ env.STAGE }}"
        )
        
        for func in "${FUNCTIONS[@]}"; do
          echo "Checking function: $func"
          aws lambda get-function --function-name $func --region ${{ env.AWS_REGION }} > /dev/null
          
          # Check function state
          STATE=$(aws lambda get-function --function-name $func --query 'Configuration.State' --output text --region ${{ env.AWS_REGION }})
          if [ "$STATE" != "Active" ]; then
            echo "‚ùå Function $func is in state: $STATE"
            exit 1
          fi
          echo "‚úÖ Function $func is active"
        done

    - name: Verify API Gateway
      run: |
        echo "üîç Verifying API Gateway deployment..."
        
        # Get API Gateway ID from CloudFormation stack
        API_ID=$(aws cloudformation describe-stacks \
          --stack-name ${{ steps.sam-deploy.outputs.STACK_NAME }} \
          --query 'Stacks[0].Outputs[?OutputKey==`WebhookApiId`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})
        
        if [ -z "$API_ID" ] || [ "$API_ID" = "None" ]; then
          echo "‚ùå API Gateway ID not found"
          exit 1
        fi
        
        echo "‚úÖ API Gateway deployed with ID: $API_ID"
        
        # Get and validate webhook endpoint URL
        WEBHOOK_URL=$(aws cloudformation describe-stacks \
          --stack-name ${{ steps.sam-deploy.outputs.STACK_NAME }} \
          --query 'Stacks[0].Outputs[?OutputKey==`WebhookEndpoint`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})
        
        echo "üìã Webhook endpoint URL: $WEBHOOK_URL"

    # ============================================================================
    # Show deployment summary
    # ============================================================================
    - name: Show deployment summary
      if: success()
      run: |
        echo "üìã Webhook SAM Infrastructure Deployment Summary"
        echo "================================================"
        echo "üéØ Stage: ${{ env.STAGE }}"
        echo "üåç Region: ${{ env.AWS_REGION }}"
        echo "üì¶ Stack: ${{ steps.sam-deploy.outputs.STACK_NAME }}"
        echo ""
        echo "üìä CloudFormation Stack Outputs:"
        aws cloudformation describe-stacks \
          --stack-name ${{ steps.sam-deploy.outputs.STACK_NAME }} \
          --query 'Stacks[0].Outputs[*].[OutputKey,OutputValue]' \
          --output table \
          --region ${{ env.AWS_REGION }}

  # ============================================================================
  # Post-deployment health checks
  # ============================================================================
  health-check:
    name: Health Check Webhook Infrastructure
    needs: [deploy]
    runs-on: ubuntu-latest
    if: success() && needs.deploy.result == 'success'
    environment: ${{ github.event.inputs.stage || (github.ref == 'refs/heads/main' && 'prod' || 'dev') }}

    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Wait for Lambda functions to be ready
      run: |
        echo "‚è≥ Waiting for Lambda functions to be fully ready..."
        sleep 30  # Give Lambda functions time to initialize after deployment

    - name: Test webhook receiver health
      run: |
        echo "üß™ Testing webhook receiver function..."
        
        # Create proper API Gateway event payload for webhook receiver
        cat > health_payload.json << 'EOF'
        {
          "version": "1.0",
          "routeKey": "GET /health",
          "rawPath": "/health",
          "rawQueryString": "",
          "headers": {
            "accept": "application/json",
            "content-type": "application/json",
            "user-agent": "GitHub-Actions-HealthCheck/1.0"
          },
          "requestContext": {
            "accountId": "123456789012",
            "apiId": "test-api",
            "domainName": "test.execute-api.us-east-1.amazonaws.com",
            "http": {
              "method": "GET",
              "path": "/health",
              "protocol": "HTTP/1.1",
              "sourceIp": "127.0.0.1",
              "userAgent": "GitHub-Actions-HealthCheck/1.0"
            },
            "requestId": "health-check-test",
            "routeKey": "GET /health",
            "stage": "${{ env.STAGE }}",
            "time": "01/Jan/2024:00:00:00 +0000",
            "timeEpoch": 1704067200000
          },
          "pathParameters": null,
          "body": "",
          "isBase64Encoded": false
        }
        EOF
        
        # Test webhook receiver with timeout and better error handling
        echo "Invoking webhook receiver function..."
        if aws lambda invoke \
          --function-name "cyphera-webhook-receiver-${{ env.STAGE }}" \
          --payload fileb://health_payload.json \
          --region ${{ env.AWS_REGION }} \
          --cli-read-timeout 60 \
          --cli-connect-timeout 60 \
          health_response.json; then
          
          echo "‚úÖ Webhook receiver invocation successful"
          echo "Response:"
          cat health_response.json
          
          # Check for successful response
          if grep -q '"statusCode": 200' health_response.json; then
            echo "‚úÖ Webhook receiver health check passed with HTTP 200"
          elif grep -q '"statusCode"' health_response.json; then
            STATUS_CODE=$(grep -o '"statusCode": [0-9]*' health_response.json | grep -o '[0-9]*')
            echo "‚ö†Ô∏è Webhook receiver responded with status code: $STATUS_CODE"
          else
            echo "‚ö†Ô∏è Webhook receiver health check inconclusive - no status code found"
          fi
        else
          echo "‚ùå Failed to invoke webhook receiver function"
          exit 1
        fi

    - name: Test webhook processor with empty SQS event
      run: |
        echo "üß™ Testing webhook processor function..."
        
        # Create empty SQS event payload file
        cat > processor_payload.json << 'EOF'
        {
          "Records": []
        }
        EOF
        
        # Test webhook processor with timeout and better error handling
        echo "Invoking webhook processor function..."
        if aws lambda invoke \
          --function-name "cyphera-webhook-processor-${{ env.STAGE }}" \
          --payload fileb://processor_payload.json \
          --region ${{ env.AWS_REGION }} \
          --cli-read-timeout 60 \
          --cli-connect-timeout 60 \
          processor_response.json; then
          
          echo "‚úÖ Webhook processor invocation successful"
          echo "Response:"
          cat processor_response.json
          
          # Check for errors in response
          if grep -q '"errorMessage"' processor_response.json; then
            echo "‚ö†Ô∏è Webhook processor returned an error - this might be expected for empty event"
            grep '"errorMessage"' processor_response.json || echo "No error message found"
          else
            echo "‚úÖ Webhook processor completed without errors"
          fi
        else
          echo "‚ùå Failed to invoke webhook processor function"
          exit 1
        fi

    - name: Test DLQ processor with empty SQS event
      run: |
        echo "üß™ Testing DLQ processor function..."
        
        # Create empty SQS event payload file
        cat > dlq_payload.json << 'EOF'
        {
          "Records": []
        }
        EOF
        
        # Test DLQ processor with timeout and better error handling
        echo "Invoking DLQ processor function..."
        if aws lambda invoke \
          --function-name "cyphera-dlq-processor-${{ env.STAGE }}" \
          --payload fileb://dlq_payload.json \
          --region ${{ env.AWS_REGION }} \
          --cli-read-timeout 60 \
          --cli-connect-timeout 60 \
          dlq_response.json; then
          
          echo "‚úÖ DLQ processor invocation successful"
          echo "Response:"
          cat dlq_response.json
          
          # Check for errors in response
          if grep -q '"errorMessage"' dlq_response.json; then
            echo "‚ö†Ô∏è DLQ processor returned an error - this might be expected for empty event"
            grep '"errorMessage"' dlq_response.json || echo "No error message found"
          else
            echo "‚úÖ DLQ processor completed without errors"
          fi
        else
          echo "‚ùå Failed to invoke DLQ processor function"
          exit 1
        fi

    - name: Verify Lambda function logs (optional)
      if: always()
      run: |
        echo "üìã Checking recent Lambda function logs for any issues..."
        
        FUNCTIONS=(
          "cyphera-webhook-receiver-${{ env.STAGE }}"
          "cyphera-webhook-processor-${{ env.STAGE }}"
          "cyphera-dlq-processor-${{ env.STAGE }}"
        )
        
        FATAL_ERRORS_FOUND=false
        
        for func in "${FUNCTIONS[@]}"; do
          echo ""
          echo "üìä Recent logs for $func:"
          # Get the most recent log events (last 5 minutes) and check for FATAL errors
          LOG_OUTPUT=$(aws logs filter-log-events \
            --log-group-name "/aws/lambda/$func" \
            --start-time $(date -d '5 minutes ago' +%s)000 \
            --limit 20 \
            --region ${{ env.AWS_REGION }} \
            --query 'events[*].message' \
            --output text 2>/dev/null || echo "No recent logs found for $func")
          
          echo "$LOG_OUTPUT"
          
          # Check for specific error patterns
          if echo "$LOG_OUTPUT" | grep -q "FATAL"; then
            echo "üö® FATAL error detected in $func logs!"
            FATAL_ERRORS_FOUND=true
          fi
          
          if echo "$LOG_OUTPUT" | grep -q "DATABASE_URL environment variable is required"; then
            echo "üö® Database configuration error in $func!"
            FATAL_ERRORS_FOUND=true
          fi
          
          if echo "$LOG_OUTPUT" | grep -q "Encryption key must be 32 bytes"; then
            echo "üö® Encryption key format error in $func!"
            FATAL_ERRORS_FOUND=true
          fi
          
          if echo "$LOG_OUTPUT" | grep -q "Failed to create application"; then
            echo "üö® Application initialization error in $func!"
            FATAL_ERRORS_FOUND=true
          fi
        done
        
        if [[ "$FATAL_ERRORS_FOUND" == "true" ]]; then
          echo ""
          echo "‚ùå FATAL errors detected in Lambda function logs!"
          echo "üí° Health check passed basic invocation but functions have startup errors"
          echo "üîß Check the specific error messages above and fix configuration issues"
          exit 1
        else
          echo ""
          echo "‚úÖ No FATAL errors found in recent Lambda logs"
        fi

    - name: Final health check summary
      if: always()
      run: |
        echo ""
        echo "üèÅ Health Check Summary"
        echo "======================"
        echo "‚úÖ Webhook infrastructure deployment verified"
        echo "‚úÖ All Lambda functions are responsive"
        echo "‚úÖ API Gateway and SQS integration confirmed"
        echo ""
        
        # Check if any of the previous steps failed
        if [[ "${{ job.status }}" == "success" ]]; then
          echo "üéâ All health checks passed! Webhook infrastructure is ready for use!"
        else
          echo "‚ö†Ô∏è Some health checks had issues. Check logs above for details."
          echo "üí° This may be expected for initial deployment - functions should still work correctly."
        fi

  # ============================================================================
  # Workflow summary and cleanup
  # ============================================================================
  summary:
    name: Workflow Summary
    needs: [validate, test, build, deploy, health-check]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Workflow Summary
      run: |
        echo "üìã Webhook Infrastructure Deployment Summary"
        echo "============================================="
        echo ""
        echo "Job Status:"
        echo "- Validate: ${{ needs.validate.result }}"
        echo "- Test: ${{ needs.test.result }}"
        echo "- Build: ${{ needs.build.result }}"
        echo "- Deploy: ${{ needs.deploy.result }}"
        echo "- Health Check: ${{ needs.health-check.result }}"
        echo ""
        
        # Determine overall status
        if [[ "${{ needs.deploy.result }}" == "success" && "${{ needs.health-check.result }}" == "success" ]]; then
          echo "üéâ Overall Status: SUCCESS"
          echo "‚úÖ Webhook infrastructure deployed and verified"
        elif [[ "${{ needs.build.result }}" == "success" && "${{ needs.deploy.result }}" == "failure" ]]; then
          echo "‚ö†Ô∏è  Overall Status: DEPLOY FAILED (Build artifacts preserved)"
          echo "üí° Tip: You can re-run just the deploy job to use cached build artifacts"
        elif [[ "${{ needs.build.result }}" == "failure" ]]; then
          echo "‚ùå Overall Status: BUILD FAILED"
          echo "üîß Fix build issues and re-run the workflow"
        else
          echo "‚ö†Ô∏è  Overall Status: PARTIAL SUCCESS"
          echo "üìù Check individual job logs for details"
        fi
