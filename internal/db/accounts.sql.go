// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: accounts.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAccount = `-- name: CreateAccount :one
INSERT INTO accounts (
    name,
    account_type,
    business_name,
    business_type,
    website_url,
    support_email,
    support_phone,
    finished_onboarding,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, name, account_type, business_name, business_type, website_url, support_email, support_phone, metadata, finished_onboarding, created_at, updated_at, deleted_at
`

type CreateAccountParams struct {
	Name               string      `json:"name"`
	AccountType        AccountType `json:"account_type"`
	BusinessName       pgtype.Text `json:"business_name"`
	BusinessType       pgtype.Text `json:"business_type"`
	WebsiteUrl         pgtype.Text `json:"website_url"`
	SupportEmail       pgtype.Text `json:"support_email"`
	SupportPhone       pgtype.Text `json:"support_phone"`
	FinishedOnboarding pgtype.Bool `json:"finished_onboarding"`
	Metadata           []byte      `json:"metadata"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.Name,
		arg.AccountType,
		arg.BusinessName,
		arg.BusinessType,
		arg.WebsiteUrl,
		arg.SupportEmail,
		arg.SupportPhone,
		arg.FinishedOnboarding,
		arg.Metadata,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AccountType,
		&i.BusinessName,
		&i.BusinessType,
		&i.WebsiteUrl,
		&i.SupportEmail,
		&i.SupportPhone,
		&i.Metadata,
		&i.FinishedOnboarding,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec
UPDATE accounts
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAccount, id)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT id, name, account_type, business_name, business_type, website_url, support_email, support_phone, metadata, finished_onboarding, created_at, updated_at, deleted_at FROM accounts
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetAccount(ctx context.Context, id uuid.UUID) (Account, error) {
	row := q.db.QueryRow(ctx, getAccount, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AccountType,
		&i.BusinessName,
		&i.BusinessType,
		&i.WebsiteUrl,
		&i.SupportEmail,
		&i.SupportPhone,
		&i.Metadata,
		&i.FinishedOnboarding,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAccountByID = `-- name: GetAccountByID :one
SELECT id, name, account_type, business_name, business_type, website_url, support_email, support_phone, metadata, finished_onboarding, created_at, updated_at, deleted_at FROM accounts
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetAccountByID(ctx context.Context, id uuid.UUID) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByID, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AccountType,
		&i.BusinessName,
		&i.BusinessType,
		&i.WebsiteUrl,
		&i.SupportEmail,
		&i.SupportPhone,
		&i.Metadata,
		&i.FinishedOnboarding,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAccountUsers = `-- name: GetAccountUsers :many
SELECT 
    u.id, u.supabase_id, u.email, u.account_id, u.role, u.is_account_owner, u.first_name, u.last_name, u.display_name, u.picture_url, u.phone, u.timezone, u.locale, u.last_login_at, u.email_verified, u.two_factor_enabled, u.status, u.metadata, u.created_at, u.updated_at, u.deleted_at,
    u.role,
    u.is_account_owner,
    u.created_at as joined_at
FROM users u
WHERE u.account_id = $1 
AND u.deleted_at IS NULL
ORDER BY u.is_account_owner DESC, u.created_at DESC
`

type GetAccountUsersRow struct {
	ID               uuid.UUID          `json:"id"`
	SupabaseID       string             `json:"supabase_id"`
	Email            string             `json:"email"`
	AccountID        uuid.UUID          `json:"account_id"`
	Role             UserRole           `json:"role"`
	IsAccountOwner   pgtype.Bool        `json:"is_account_owner"`
	FirstName        pgtype.Text        `json:"first_name"`
	LastName         pgtype.Text        `json:"last_name"`
	DisplayName      pgtype.Text        `json:"display_name"`
	PictureUrl       pgtype.Text        `json:"picture_url"`
	Phone            pgtype.Text        `json:"phone"`
	Timezone         pgtype.Text        `json:"timezone"`
	Locale           pgtype.Text        `json:"locale"`
	LastLoginAt      pgtype.Timestamptz `json:"last_login_at"`
	EmailVerified    pgtype.Bool        `json:"email_verified"`
	TwoFactorEnabled pgtype.Bool        `json:"two_factor_enabled"`
	Status           NullUserStatus     `json:"status"`
	Metadata         []byte             `json:"metadata"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
	Role_2           UserRole           `json:"role_2"`
	IsAccountOwner_2 pgtype.Bool        `json:"is_account_owner_2"`
	JoinedAt         pgtype.Timestamptz `json:"joined_at"`
}

func (q *Queries) GetAccountUsers(ctx context.Context, accountID uuid.UUID) ([]GetAccountUsersRow, error) {
	rows, err := q.db.Query(ctx, getAccountUsers, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAccountUsersRow{}
	for rows.Next() {
		var i GetAccountUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.SupabaseID,
			&i.Email,
			&i.AccountID,
			&i.Role,
			&i.IsAccountOwner,
			&i.FirstName,
			&i.LastName,
			&i.DisplayName,
			&i.PictureUrl,
			&i.Phone,
			&i.Timezone,
			&i.Locale,
			&i.LastLoginAt,
			&i.EmailVerified,
			&i.TwoFactorEnabled,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Role_2,
			&i.IsAccountOwner_2,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAccounts = `-- name: GetAllAccounts :many
SELECT id, name, account_type, business_name, business_type, website_url, support_email, support_phone, metadata, finished_onboarding, created_at, updated_at, deleted_at FROM accounts
ORDER BY created_at DESC
`

func (q *Queries) GetAllAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.Query(ctx, getAllAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AccountType,
			&i.BusinessName,
			&i.BusinessType,
			&i.WebsiteUrl,
			&i.SupportEmail,
			&i.SupportPhone,
			&i.Metadata,
			&i.FinishedOnboarding,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteAccount = `-- name: HardDeleteAccount :exec
DELETE FROM accounts
WHERE id = $1
`

func (q *Queries) HardDeleteAccount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteAccount, id)
	return err
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, name, account_type, business_name, business_type, website_url, support_email, support_phone, metadata, finished_onboarding, created_at, updated_at, deleted_at FROM accounts
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AccountType,
			&i.BusinessName,
			&i.BusinessType,
			&i.WebsiteUrl,
			&i.SupportEmail,
			&i.SupportPhone,
			&i.Metadata,
			&i.FinishedOnboarding,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountsByType = `-- name: ListAccountsByType :many
SELECT id, name, account_type, business_name, business_type, website_url, support_email, support_phone, metadata, finished_onboarding, created_at, updated_at, deleted_at FROM accounts
WHERE account_type = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListAccountsByType(ctx context.Context, accountType AccountType) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccountsByType, accountType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AccountType,
			&i.BusinessName,
			&i.BusinessType,
			&i.WebsiteUrl,
			&i.SupportEmail,
			&i.SupportPhone,
			&i.Metadata,
			&i.FinishedOnboarding,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountsByUser = `-- name: ListAccountsByUser :many
SELECT a.id, a.name, a.account_type, a.business_name, a.business_type, a.website_url, a.support_email, a.support_phone, a.metadata, a.finished_onboarding, a.created_at, a.updated_at, a.deleted_at
FROM accounts a
JOIN users u ON a.id = u.account_id
WHERE u.id = $1 
AND a.deleted_at IS NULL 
AND u.deleted_at IS NULL
ORDER BY a.created_at DESC
`

func (q *Queries) ListAccountsByUser(ctx context.Context, id uuid.UUID) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccountsByUser, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AccountType,
			&i.BusinessName,
			&i.BusinessType,
			&i.WebsiteUrl,
			&i.SupportEmail,
			&i.SupportPhone,
			&i.Metadata,
			&i.FinishedOnboarding,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAccounts = `-- name: SearchAccounts :many
SELECT DISTINCT a.id, a.name, a.account_type, a.business_name, a.business_type, a.website_url, a.support_email, a.support_phone, a.metadata, a.finished_onboarding, a.created_at, a.updated_at, a.deleted_at 
FROM accounts a
LEFT JOIN users u ON a.id = u.account_id
WHERE 
    (
        a.name ILIKE $1 OR
        a.business_name ILIKE $1 OR
        u.email ILIKE $1 OR
        u.display_name ILIKE $1
    )
    AND a.deleted_at IS NULL
ORDER BY a.created_at DESC
LIMIT $2
OFFSET $3
`

type SearchAccountsParams struct {
	Name   string `json:"name"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) SearchAccounts(ctx context.Context, arg SearchAccountsParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, searchAccounts, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AccountType,
			&i.BusinessName,
			&i.BusinessType,
			&i.WebsiteUrl,
			&i.SupportEmail,
			&i.SupportPhone,
			&i.Metadata,
			&i.FinishedOnboarding,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE accounts
SET
    name = COALESCE($2, name),
    account_type = COALESCE($3, account_type),
    business_name = COALESCE($4, business_name),
    business_type = COALESCE($5, business_type),
    website_url = COALESCE($6, website_url),
    support_email = COALESCE($7, support_email),
    support_phone = COALESCE($8, support_phone),
    finished_onboarding = COALESCE($9, finished_onboarding),
    metadata = COALESCE($10, metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, account_type, business_name, business_type, website_url, support_email, support_phone, metadata, finished_onboarding, created_at, updated_at, deleted_at
`

type UpdateAccountParams struct {
	ID                 uuid.UUID   `json:"id"`
	Name               string      `json:"name"`
	AccountType        AccountType `json:"account_type"`
	BusinessName       pgtype.Text `json:"business_name"`
	BusinessType       pgtype.Text `json:"business_type"`
	WebsiteUrl         pgtype.Text `json:"website_url"`
	SupportEmail       pgtype.Text `json:"support_email"`
	SupportPhone       pgtype.Text `json:"support_phone"`
	FinishedOnboarding pgtype.Bool `json:"finished_onboarding"`
	Metadata           []byte      `json:"metadata"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccount,
		arg.ID,
		arg.Name,
		arg.AccountType,
		arg.BusinessName,
		arg.BusinessType,
		arg.WebsiteUrl,
		arg.SupportEmail,
		arg.SupportPhone,
		arg.FinishedOnboarding,
		arg.Metadata,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AccountType,
		&i.BusinessName,
		&i.BusinessType,
		&i.WebsiteUrl,
		&i.SupportEmail,
		&i.SupportPhone,
		&i.Metadata,
		&i.FinishedOnboarding,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
