// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: accounts.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAccount = `-- name: CreateAccount :one
INSERT INTO accounts (
    user_id,
    name,
    description,
    business_name,
    business_type,
    website_url,
    support_email,
    support_phone,
    metadata,
    livemode
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, user_id, name, description, business_name, business_type, website_url, support_email, support_phone, metadata, created_at, updated_at, deleted_at, livemode
`

type CreateAccountParams struct {
	UserID       uuid.UUID   `json:"user_id"`
	Name         string      `json:"name"`
	Description  pgtype.Text `json:"description"`
	BusinessName pgtype.Text `json:"business_name"`
	BusinessType pgtype.Text `json:"business_type"`
	WebsiteUrl   pgtype.Text `json:"website_url"`
	SupportEmail pgtype.Text `json:"support_email"`
	SupportPhone pgtype.Text `json:"support_phone"`
	Metadata     []byte      `json:"metadata"`
	Livemode     pgtype.Bool `json:"livemode"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.BusinessName,
		arg.BusinessType,
		arg.WebsiteUrl,
		arg.SupportEmail,
		arg.SupportPhone,
		arg.Metadata,
		arg.Livemode,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.BusinessName,
		&i.BusinessType,
		&i.WebsiteUrl,
		&i.SupportEmail,
		&i.SupportPhone,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Livemode,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec
UPDATE accounts
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteAccount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAccount, id)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT id, user_id, name, description, business_name, business_type, website_url, support_email, support_phone, metadata, created_at, updated_at, deleted_at, livemode FROM accounts
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetAccount(ctx context.Context, id uuid.UUID) (Account, error) {
	row := q.db.QueryRow(ctx, getAccount, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.BusinessName,
		&i.BusinessType,
		&i.WebsiteUrl,
		&i.SupportEmail,
		&i.SupportPhone,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Livemode,
	)
	return i, err
}

const getAccountByUserID = `-- name: GetAccountByUserID :one
SELECT id, user_id, name, description, business_name, business_type, website_url, support_email, support_phone, metadata, created_at, updated_at, deleted_at, livemode FROM accounts
WHERE user_id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetAccountByUserID(ctx context.Context, userID uuid.UUID) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByUserID, userID)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.BusinessName,
		&i.BusinessType,
		&i.WebsiteUrl,
		&i.SupportEmail,
		&i.SupportPhone,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Livemode,
	)
	return i, err
}

const getAllAccounts = `-- name: GetAllAccounts :many
SELECT id, user_id, name, description, business_name, business_type, website_url, support_email, support_phone, metadata, created_at, updated_at, deleted_at, livemode FROM accounts
ORDER BY created_at DESC
`

func (q *Queries) GetAllAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.Query(ctx, getAllAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.BusinessName,
			&i.BusinessType,
			&i.WebsiteUrl,
			&i.SupportEmail,
			&i.SupportPhone,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Livemode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteAccount = `-- name: HardDeleteAccount :exec
DELETE FROM accounts
WHERE id = $1
`

func (q *Queries) HardDeleteAccount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteAccount, id)
	return err
}

const listAccountCustomers = `-- name: ListAccountCustomers :many
SELECT c.id, c.account_id, c.email, c.name, c.description, c.metadata, c.created_at, c.updated_at, c.deleted_at, c.balance, c.currency, c.default_source_id, c.invoice_prefix, c.next_invoice_sequence, c.tax_exempt, c.tax_ids, c.livemode FROM customers c
INNER JOIN accounts a ON c.account_id = a.id
WHERE a.id = $1 AND c.deleted_at IS NULL
ORDER BY c.created_at DESC
`

func (q *Queries) ListAccountCustomers(ctx context.Context, id uuid.UUID) ([]Customer, error) {
	rows, err := q.db.Query(ctx, listAccountCustomers, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Email,
			&i.Name,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Balance,
			&i.Currency,
			&i.DefaultSourceID,
			&i.InvoicePrefix,
			&i.NextInvoiceSequence,
			&i.TaxExempt,
			&i.TaxIds,
			&i.Livemode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, user_id, name, description, business_name, business_type, website_url, support_email, support_phone, metadata, created_at, updated_at, deleted_at, livemode FROM accounts
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.BusinessName,
			&i.BusinessType,
			&i.WebsiteUrl,
			&i.SupportEmail,
			&i.SupportPhone,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Livemode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE accounts
SET
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    business_name = COALESCE($4, business_name),
    business_type = COALESCE($5, business_type),
    website_url = COALESCE($6, website_url),
    support_email = COALESCE($7, support_email),
    support_phone = COALESCE($8, support_phone),
    metadata = COALESCE($9, metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, user_id, name, description, business_name, business_type, website_url, support_email, support_phone, metadata, created_at, updated_at, deleted_at, livemode
`

type UpdateAccountParams struct {
	ID           uuid.UUID   `json:"id"`
	Name         string      `json:"name"`
	Description  pgtype.Text `json:"description"`
	BusinessName pgtype.Text `json:"business_name"`
	BusinessType pgtype.Text `json:"business_type"`
	WebsiteUrl   pgtype.Text `json:"website_url"`
	SupportEmail pgtype.Text `json:"support_email"`
	SupportPhone pgtype.Text `json:"support_phone"`
	Metadata     []byte      `json:"metadata"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccount,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.BusinessName,
		arg.BusinessType,
		arg.WebsiteUrl,
		arg.SupportEmail,
		arg.SupportPhone,
		arg.Metadata,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.BusinessName,
		&i.BusinessType,
		&i.WebsiteUrl,
		&i.SupportEmail,
		&i.SupportPhone,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Livemode,
	)
	return i, err
}

const updateAccountFull = `-- name: UpdateAccountFull :one
UPDATE accounts
SET
    name = $2,
    description = $3,
    business_name = $4,
    business_type = $5,
    website_url = $6,
    support_email = $7,
    support_phone = $8,
    metadata = $9,
    livemode = $10,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, user_id, name, description, business_name, business_type, website_url, support_email, support_phone, metadata, created_at, updated_at, deleted_at, livemode
`

type UpdateAccountFullParams struct {
	ID           uuid.UUID   `json:"id"`
	Name         string      `json:"name"`
	Description  pgtype.Text `json:"description"`
	BusinessName pgtype.Text `json:"business_name"`
	BusinessType pgtype.Text `json:"business_type"`
	WebsiteUrl   pgtype.Text `json:"website_url"`
	SupportEmail pgtype.Text `json:"support_email"`
	SupportPhone pgtype.Text `json:"support_phone"`
	Metadata     []byte      `json:"metadata"`
	Livemode     pgtype.Bool `json:"livemode"`
}

func (q *Queries) UpdateAccountFull(ctx context.Context, arg UpdateAccountFullParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccountFull,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.BusinessName,
		arg.BusinessType,
		arg.WebsiteUrl,
		arg.SupportEmail,
		arg.SupportPhone,
		arg.Metadata,
		arg.Livemode,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.BusinessName,
		&i.BusinessType,
		&i.WebsiteUrl,
		&i.SupportEmail,
		&i.SupportPhone,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Livemode,
	)
	return i, err
}
