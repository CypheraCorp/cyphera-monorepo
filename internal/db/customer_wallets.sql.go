// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: customer_wallets.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countCustomerWallets = `-- name: CountCustomerWallets :one
SELECT COUNT(*) FROM customer_wallets
WHERE customer_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountCustomerWallets(ctx context.Context, customerID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countCustomerWallets, customerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVerifiedCustomerWallets = `-- name: CountVerifiedCustomerWallets :one
SELECT COUNT(*) FROM customer_wallets
WHERE customer_id = $1 AND verified = true AND deleted_at IS NULL
`

func (q *Queries) CountVerifiedCustomerWallets(ctx context.Context, customerID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countVerifiedCustomerWallets, customerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCustomerWallet = `-- name: CreateCustomerWallet :one
INSERT INTO customer_wallets (
    customer_id,
    wallet_address,
    network_type,
    nickname,
    ens,
    is_primary,
    verified,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, customer_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at
`

type CreateCustomerWalletParams struct {
	CustomerID    uuid.UUID   `json:"customer_id"`
	WalletAddress string      `json:"wallet_address"`
	NetworkType   NetworkType `json:"network_type"`
	Nickname      pgtype.Text `json:"nickname"`
	Ens           pgtype.Text `json:"ens"`
	IsPrimary     pgtype.Bool `json:"is_primary"`
	Verified      pgtype.Bool `json:"verified"`
	Metadata      []byte      `json:"metadata"`
}

func (q *Queries) CreateCustomerWallet(ctx context.Context, arg CreateCustomerWalletParams) (CustomerWallet, error) {
	row := q.db.QueryRow(ctx, createCustomerWallet,
		arg.CustomerID,
		arg.WalletAddress,
		arg.NetworkType,
		arg.Nickname,
		arg.Ens,
		arg.IsPrimary,
		arg.Verified,
		arg.Metadata,
	)
	var i CustomerWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WalletAddress,
		&i.NetworkType,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteCustomerWallet = `-- name: DeleteCustomerWallet :exec
UPDATE customer_wallets
SET deleted_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) DeleteCustomerWallet(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCustomerWallet, id)
	return err
}

const deleteCustomerWalletsByCustomer = `-- name: DeleteCustomerWalletsByCustomer :exec
UPDATE customer_wallets
SET deleted_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE customer_id = $1
`

func (q *Queries) DeleteCustomerWalletsByCustomer(ctx context.Context, customerID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCustomerWalletsByCustomer, customerID)
	return err
}

const getCustomerIdForWallet = `-- name: GetCustomerIdForWallet :one
SELECT customer_id FROM customer_wallets
WHERE id = $1 AND deleted_at IS NULL
`

// Get the customer_id for a wallet
func (q *Queries) GetCustomerIdForWallet(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getCustomerIdForWallet, id)
	var customer_id uuid.UUID
	err := row.Scan(&customer_id)
	return customer_id, err
}

const getCustomerWallet = `-- name: GetCustomerWallet :one
SELECT id, customer_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM customer_wallets
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetCustomerWallet(ctx context.Context, id uuid.UUID) (CustomerWallet, error) {
	row := q.db.QueryRow(ctx, getCustomerWallet, id)
	var i CustomerWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WalletAddress,
		&i.NetworkType,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCustomerWalletByAddress = `-- name: GetCustomerWalletByAddress :one
SELECT id, customer_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM customer_wallets
WHERE customer_id = $1 AND wallet_address = $2 AND network_type = $3 AND deleted_at IS NULL
`

type GetCustomerWalletByAddressParams struct {
	CustomerID    uuid.UUID   `json:"customer_id"`
	WalletAddress string      `json:"wallet_address"`
	NetworkType   NetworkType `json:"network_type"`
}

func (q *Queries) GetCustomerWalletByAddress(ctx context.Context, arg GetCustomerWalletByAddressParams) (CustomerWallet, error) {
	row := q.db.QueryRow(ctx, getCustomerWalletByAddress, arg.CustomerID, arg.WalletAddress, arg.NetworkType)
	var i CustomerWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WalletAddress,
		&i.NetworkType,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCustomersByWalletAddress = `-- name: GetCustomersByWalletAddress :many
SELECT c.id, c.workspace_id, c.external_id, c.email, c.name, c.phone, c.description, c.balance_in_pennies, c.currency, c.default_source_id, c.invoice_prefix, c.next_invoice_sequence, c.tax_exempt, c.tax_ids, c.metadata, c.livemode, c.created_at, c.updated_at, c.deleted_at FROM customers c
JOIN customer_wallets cw ON c.id = cw.customer_id
WHERE cw.wallet_address = $1 AND c.deleted_at IS NULL AND cw.deleted_at IS NULL
`

func (q *Queries) GetCustomersByWalletAddress(ctx context.Context, walletAddress string) ([]Customer, error) {
	rows, err := q.db.Query(ctx, getCustomersByWalletAddress, walletAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ExternalID,
			&i.Email,
			&i.Name,
			&i.Phone,
			&i.Description,
			&i.BalanceInPennies,
			&i.Currency,
			&i.DefaultSourceID,
			&i.InvoicePrefix,
			&i.NextInvoiceSequence,
			&i.TaxExempt,
			&i.TaxIds,
			&i.Metadata,
			&i.Livemode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrimaryCustomerWallet = `-- name: GetPrimaryCustomerWallet :one
SELECT id, customer_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM customer_wallets
WHERE customer_id = $1 AND is_primary = true AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetPrimaryCustomerWallet(ctx context.Context, customerID uuid.UUID) (CustomerWallet, error) {
	row := q.db.QueryRow(ctx, getPrimaryCustomerWallet, customerID)
	var i CustomerWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WalletAddress,
		&i.NetworkType,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getWalletsWithSimilarAddress = `-- name: GetWalletsWithSimilarAddress :many
SELECT id, customer_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM customer_wallets
WHERE wallet_address ILIKE $1 AND deleted_at IS NULL
ORDER BY customer_id, is_primary DESC
LIMIT $2
`

type GetWalletsWithSimilarAddressParams struct {
	WalletAddress string `json:"wallet_address"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) GetWalletsWithSimilarAddress(ctx context.Context, arg GetWalletsWithSimilarAddressParams) ([]CustomerWallet, error) {
	rows, err := q.db.Query(ctx, getWalletsWithSimilarAddress, arg.WalletAddress, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CustomerWallet{}
	for rows.Next() {
		var i CustomerWallet
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.WalletAddress,
			&i.NetworkType,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomerWallets = `-- name: ListCustomerWallets :many
SELECT id, customer_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM customer_wallets
WHERE customer_id = $1 AND deleted_at IS NULL
ORDER BY is_primary DESC, created_at DESC
`

func (q *Queries) ListCustomerWallets(ctx context.Context, customerID uuid.UUID) ([]CustomerWallet, error) {
	rows, err := q.db.Query(ctx, listCustomerWallets, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CustomerWallet{}
	for rows.Next() {
		var i CustomerWallet
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.WalletAddress,
			&i.NetworkType,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPrimaryCustomerWallets = `-- name: ListPrimaryCustomerWallets :many
SELECT id, customer_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM customer_wallets
WHERE is_primary = true AND deleted_at IS NULL
ORDER BY customer_id
`

func (q *Queries) ListPrimaryCustomerWallets(ctx context.Context) ([]CustomerWallet, error) {
	rows, err := q.db.Query(ctx, listPrimaryCustomerWallets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CustomerWallet{}
	for rows.Next() {
		var i CustomerWallet
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.WalletAddress,
			&i.NetworkType,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markCustomerWalletAsPrimary = `-- name: MarkCustomerWalletAsPrimary :one
UPDATE customer_wallets
SET is_primary = true, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, customer_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at
`

// Set a specific customer wallet as primary
func (q *Queries) MarkCustomerWalletAsPrimary(ctx context.Context, id uuid.UUID) (CustomerWallet, error) {
	row := q.db.QueryRow(ctx, markCustomerWalletAsPrimary, id)
	var i CustomerWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WalletAddress,
		&i.NetworkType,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const unsetPrimaryForCustomerWallets = `-- name: UnsetPrimaryForCustomerWallets :exec
UPDATE customer_wallets
SET is_primary = false, updated_at = CURRENT_TIMESTAMP
WHERE customer_id = $1
AND id != $2
AND deleted_at IS NULL
`

type UnsetPrimaryForCustomerWalletsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	ID         uuid.UUID `json:"id"`
}

// Unset primary flag for all wallets of a customer except the specified wallet
func (q *Queries) UnsetPrimaryForCustomerWallets(ctx context.Context, arg UnsetPrimaryForCustomerWalletsParams) error {
	_, err := q.db.Exec(ctx, unsetPrimaryForCustomerWallets, arg.CustomerID, arg.ID)
	return err
}

const updateCustomerWallet = `-- name: UpdateCustomerWallet :one
UPDATE customer_wallets SET
    nickname = $2,
    ens = $3,
    is_primary = $4,
    verified = $5,
    metadata = $6,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, customer_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at
`

type UpdateCustomerWalletParams struct {
	ID        uuid.UUID   `json:"id"`
	Nickname  pgtype.Text `json:"nickname"`
	Ens       pgtype.Text `json:"ens"`
	IsPrimary pgtype.Bool `json:"is_primary"`
	Verified  pgtype.Bool `json:"verified"`
	Metadata  []byte      `json:"metadata"`
}

func (q *Queries) UpdateCustomerWallet(ctx context.Context, arg UpdateCustomerWalletParams) (CustomerWallet, error) {
	row := q.db.QueryRow(ctx, updateCustomerWallet,
		arg.ID,
		arg.Nickname,
		arg.Ens,
		arg.IsPrimary,
		arg.Verified,
		arg.Metadata,
	)
	var i CustomerWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WalletAddress,
		&i.NetworkType,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateCustomerWalletUsageTime = `-- name: UpdateCustomerWalletUsageTime :one
UPDATE customer_wallets
SET last_used_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, customer_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at
`

func (q *Queries) UpdateCustomerWalletUsageTime(ctx context.Context, id uuid.UUID) (CustomerWallet, error) {
	row := q.db.QueryRow(ctx, updateCustomerWalletUsageTime, id)
	var i CustomerWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WalletAddress,
		&i.NetworkType,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const verifyCustomerWallet = `-- name: VerifyCustomerWallet :one
UPDATE customer_wallets
SET verified = true, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, customer_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at
`

func (q *Queries) VerifyCustomerWallet(ctx context.Context, id uuid.UUID) (CustomerWallet, error) {
	row := q.db.QueryRow(ctx, verifyCustomerWallet, id)
	var i CustomerWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WalletAddress,
		&i.NetworkType,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
