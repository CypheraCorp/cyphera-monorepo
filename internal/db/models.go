// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package db

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type ApiKeyLevel string

const (
	ApiKeyLevelRead  ApiKeyLevel = "read"
	ApiKeyLevelWrite ApiKeyLevel = "write"
	ApiKeyLevelAdmin ApiKeyLevel = "admin"
)

func (e *ApiKeyLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ApiKeyLevel(s)
	case string:
		*e = ApiKeyLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for ApiKeyLevel: %T", src)
	}
	return nil
}

type NullApiKeyLevel struct {
	ApiKeyLevel ApiKeyLevel `json:"api_key_level"`
	Valid       bool        `json:"valid"` // Valid is true if ApiKeyLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullApiKeyLevel) Scan(value interface{}) error {
	if value == nil {
		ns.ApiKeyLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ApiKeyLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullApiKeyLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ApiKeyLevel), nil
}

type SubscriptionStatus string

const (
	SubscriptionStatusActive            SubscriptionStatus = "active"
	SubscriptionStatusCanceled          SubscriptionStatus = "canceled"
	SubscriptionStatusPastDue           SubscriptionStatus = "past_due"
	SubscriptionStatusIncomplete        SubscriptionStatus = "incomplete"
	SubscriptionStatusIncompleteExpired SubscriptionStatus = "incomplete_expired"
	SubscriptionStatusTrialing          SubscriptionStatus = "trialing"
	SubscriptionStatusUnpaid            SubscriptionStatus = "unpaid"
)

func (e *SubscriptionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SubscriptionStatus(s)
	case string:
		*e = SubscriptionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SubscriptionStatus: %T", src)
	}
	return nil
}

type NullSubscriptionStatus struct {
	SubscriptionStatus SubscriptionStatus `json:"subscription_status"`
	Valid              bool               `json:"valid"` // Valid is true if SubscriptionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSubscriptionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SubscriptionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SubscriptionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSubscriptionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SubscriptionStatus), nil
}

type ApiKey struct {
	ID         uuid.UUID          `json:"id"`
	CustomerID pgtype.UUID        `json:"customer_id"`
	Name       string             `json:"name"`
	KeyHash    string             `json:"key_hash"`
	Level      ApiKeyLevel        `json:"level"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	ExpiresAt  pgtype.Timestamptz `json:"expires_at"`
	LastUsedAt pgtype.Timestamptz `json:"last_used_at"`
	IsActive   pgtype.Bool        `json:"is_active"`
	Metadata   []byte             `json:"metadata"`
	Livemode   pgtype.Bool        `json:"livemode"`
}

type Customer struct {
	ID                  uuid.UUID          `json:"id"`
	Email               string             `json:"email"`
	Name                pgtype.Text        `json:"name"`
	Description         pgtype.Text        `json:"description"`
	Metadata            []byte             `json:"metadata"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	DeletedAt           pgtype.Timestamptz `json:"deleted_at"`
	Balance             pgtype.Int4        `json:"balance"`
	Currency            pgtype.Text        `json:"currency"`
	DefaultSourceID     pgtype.UUID        `json:"default_source_id"`
	InvoicePrefix       pgtype.Text        `json:"invoice_prefix"`
	NextInvoiceSequence pgtype.Int4        `json:"next_invoice_sequence"`
	TaxExempt           pgtype.Text        `json:"tax_exempt"`
	TaxIds              []byte             `json:"tax_ids"`
	Livemode            pgtype.Bool        `json:"livemode"`
}

type Invoice struct {
	ID                 uuid.UUID          `json:"id"`
	CustomerID         pgtype.UUID        `json:"customer_id"`
	SubscriptionID     pgtype.UUID        `json:"subscription_id"`
	Status             string             `json:"status"`
	Currency           string             `json:"currency"`
	AmountDue          int32              `json:"amount_due"`
	AmountPaid         pgtype.Int4        `json:"amount_paid"`
	AmountRemaining    pgtype.Int4        `json:"amount_remaining"`
	Paid               pgtype.Bool        `json:"paid"`
	AttemptCount       pgtype.Int4        `json:"attempt_count"`
	NextPaymentAttempt pgtype.Timestamptz `json:"next_payment_attempt"`
	Metadata           []byte             `json:"metadata"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	Livemode           pgtype.Bool        `json:"livemode"`
}

type PaymentMethod struct {
	ID         uuid.UUID          `json:"id"`
	CustomerID pgtype.UUID        `json:"customer_id"`
	Type       string             `json:"type"`
	Details    json.RawMessage    `json:"details"`
	IsDefault  pgtype.Bool        `json:"is_default"`
	Metadata   []byte             `json:"metadata"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	Livemode   pgtype.Bool        `json:"livemode"`
}

type Price struct {
	ID                     uuid.UUID          `json:"id"`
	ProductID              pgtype.UUID        `json:"product_id"`
	Currency               string             `json:"currency"`
	UnitAmount             pgtype.Int4        `json:"unit_amount"`
	RecurringInterval      pgtype.Text        `json:"recurring_interval"`
	RecurringIntervalCount pgtype.Int4        `json:"recurring_interval_count"`
	UsageType              pgtype.Text        `json:"usage_type"`
	BillingScheme          pgtype.Text        `json:"billing_scheme"`
	Active                 pgtype.Bool        `json:"active"`
	Metadata               []byte             `json:"metadata"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	Livemode               pgtype.Bool        `json:"livemode"`
}

type Product struct {
	ID             uuid.UUID          `json:"id"`
	Name           string             `json:"name"`
	Description    pgtype.Text        `json:"description"`
	Active         pgtype.Bool        `json:"active"`
	DefaultPriceID pgtype.UUID        `json:"default_price_id"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	Livemode       pgtype.Bool        `json:"livemode"`
}

type Subscription struct {
	ID                 uuid.UUID          `json:"id"`
	CustomerID         pgtype.UUID        `json:"customer_id"`
	Status             SubscriptionStatus `json:"status"`
	CurrentPeriodStart pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamptz `json:"current_period_end"`
	CancelAt           pgtype.Timestamptz `json:"cancel_at"`
	CanceledAt         pgtype.Timestamptz `json:"canceled_at"`
	EndedAt            pgtype.Timestamptz `json:"ended_at"`
	TrialStart         pgtype.Timestamptz `json:"trial_start"`
	TrialEnd           pgtype.Timestamptz `json:"trial_end"`
	Metadata           []byte             `json:"metadata"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	Livemode           pgtype.Bool        `json:"livemode"`
}

type SubscriptionItem struct {
	ID             uuid.UUID          `json:"id"`
	SubscriptionID pgtype.UUID        `json:"subscription_id"`
	PriceID        pgtype.UUID        `json:"price_id"`
	Quantity       pgtype.Int4        `json:"quantity"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}
