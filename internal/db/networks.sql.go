// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: networks.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const activateNetwork = `-- name: ActivateNetwork :one
UPDATE networks
SET 
    active = true,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, type, network_type, circle_network_type, block_explorer_url, chain_id, is_testnet, active, created_at, updated_at, deleted_at
`

func (q *Queries) ActivateNetwork(ctx context.Context, id uuid.UUID) (Network, error) {
	row := q.db.QueryRow(ctx, activateNetwork, id)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.NetworkType,
		&i.CircleNetworkType,
		&i.BlockExplorerUrl,
		&i.ChainID,
		&i.IsTestnet,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createNetwork = `-- name: CreateNetwork :one
INSERT INTO networks (
    name,
    type,
    network_type,
    circle_network_type,
    block_explorer_url,
    chain_id,
    is_testnet,
    active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, name, type, network_type, circle_network_type, block_explorer_url, chain_id, is_testnet, active, created_at, updated_at, deleted_at
`

type CreateNetworkParams struct {
	Name              string            `json:"name"`
	Type              string            `json:"type"`
	NetworkType       NetworkType       `json:"network_type"`
	CircleNetworkType CircleNetworkType `json:"circle_network_type"`
	BlockExplorerUrl  pgtype.Text       `json:"block_explorer_url"`
	ChainID           int32             `json:"chain_id"`
	IsTestnet         bool              `json:"is_testnet"`
	Active            bool              `json:"active"`
}

func (q *Queries) CreateNetwork(ctx context.Context, arg CreateNetworkParams) (Network, error) {
	row := q.db.QueryRow(ctx, createNetwork,
		arg.Name,
		arg.Type,
		arg.NetworkType,
		arg.CircleNetworkType,
		arg.BlockExplorerUrl,
		arg.ChainID,
		arg.IsTestnet,
		arg.Active,
	)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.NetworkType,
		&i.CircleNetworkType,
		&i.BlockExplorerUrl,
		&i.ChainID,
		&i.IsTestnet,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deactivateNetwork = `-- name: DeactivateNetwork :one
UPDATE networks
SET 
    active = false,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, type, network_type, circle_network_type, block_explorer_url, chain_id, is_testnet, active, created_at, updated_at, deleted_at
`

func (q *Queries) DeactivateNetwork(ctx context.Context, id uuid.UUID) (Network, error) {
	row := q.db.QueryRow(ctx, deactivateNetwork, id)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.NetworkType,
		&i.CircleNetworkType,
		&i.BlockExplorerUrl,
		&i.ChainID,
		&i.IsTestnet,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteNetwork = `-- name: DeleteNetwork :exec
UPDATE networks
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteNetwork(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteNetwork, id)
	return err
}

const getNetwork = `-- name: GetNetwork :one
SELECT id, name, type, network_type, circle_network_type, block_explorer_url, chain_id, is_testnet, active, created_at, updated_at, deleted_at FROM networks
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetNetwork(ctx context.Context, id uuid.UUID) (Network, error) {
	row := q.db.QueryRow(ctx, getNetwork, id)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.NetworkType,
		&i.CircleNetworkType,
		&i.BlockExplorerUrl,
		&i.ChainID,
		&i.IsTestnet,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getNetworkByChainID = `-- name: GetNetworkByChainID :one
SELECT id, name, type, network_type, circle_network_type, block_explorer_url, chain_id, is_testnet, active, created_at, updated_at, deleted_at FROM networks
WHERE chain_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetNetworkByChainID(ctx context.Context, chainID int32) (Network, error) {
	row := q.db.QueryRow(ctx, getNetworkByChainID, chainID)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.NetworkType,
		&i.CircleNetworkType,
		&i.BlockExplorerUrl,
		&i.ChainID,
		&i.IsTestnet,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getNetworkByCircleNetworkType = `-- name: GetNetworkByCircleNetworkType :one
SELECT id, name, type, network_type, circle_network_type, block_explorer_url, chain_id, is_testnet, active, created_at, updated_at, deleted_at FROM networks
WHERE circle_network_type = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetNetworkByCircleNetworkType(ctx context.Context, circleNetworkType CircleNetworkType) (Network, error) {
	row := q.db.QueryRow(ctx, getNetworkByCircleNetworkType, circleNetworkType)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.NetworkType,
		&i.CircleNetworkType,
		&i.BlockExplorerUrl,
		&i.ChainID,
		&i.IsTestnet,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listNetworks = `-- name: ListNetworks :many
SELECT id, name, type, network_type, circle_network_type, block_explorer_url, chain_id, is_testnet, active, created_at, updated_at, deleted_at FROM networks
WHERE deleted_at IS NULL
    AND CASE WHEN $1::boolean IS NOT NULL THEN is_testnet = $1::boolean ELSE TRUE END
    AND CASE WHEN $2::boolean IS NOT NULL THEN active = $2::boolean ELSE TRUE END
ORDER BY chain_id ASC
`

type ListNetworksParams struct {
	IsTestnet pgtype.Bool `json:"is_testnet"`
	IsActive  pgtype.Bool `json:"is_active"`
}

func (q *Queries) ListNetworks(ctx context.Context, arg ListNetworksParams) ([]Network, error) {
	rows, err := q.db.Query(ctx, listNetworks, arg.IsTestnet, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Network{}
	for rows.Next() {
		var i Network
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.NetworkType,
			&i.CircleNetworkType,
			&i.BlockExplorerUrl,
			&i.ChainID,
			&i.IsTestnet,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNetwork = `-- name: UpdateNetwork :one
UPDATE networks
SET
    name = COALESCE($2, name),
    type = COALESCE($3, type),
    network_type = COALESCE($4, network_type),
    circle_network_type = COALESCE($5, circle_network_type),
    block_explorer_url = COALESCE($6, block_explorer_url),
    chain_id = COALESCE($7, chain_id),
    is_testnet = COALESCE($8, is_testnet),
    active = COALESCE($9, active),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, type, network_type, circle_network_type, block_explorer_url, chain_id, is_testnet, active, created_at, updated_at, deleted_at
`

type UpdateNetworkParams struct {
	ID                uuid.UUID         `json:"id"`
	Name              string            `json:"name"`
	Type              string            `json:"type"`
	NetworkType       NetworkType       `json:"network_type"`
	CircleNetworkType CircleNetworkType `json:"circle_network_type"`
	BlockExplorerUrl  pgtype.Text       `json:"block_explorer_url"`
	ChainID           int32             `json:"chain_id"`
	IsTestnet         bool              `json:"is_testnet"`
	Active            bool              `json:"active"`
}

func (q *Queries) UpdateNetwork(ctx context.Context, arg UpdateNetworkParams) (Network, error) {
	row := q.db.QueryRow(ctx, updateNetwork,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.NetworkType,
		arg.CircleNetworkType,
		arg.BlockExplorerUrl,
		arg.ChainID,
		arg.IsTestnet,
		arg.Active,
	)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.NetworkType,
		&i.CircleNetworkType,
		&i.BlockExplorerUrl,
		&i.ChainID,
		&i.IsTestnet,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
