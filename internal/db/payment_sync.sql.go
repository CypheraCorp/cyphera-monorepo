// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: payment_sync.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const bulkUpdateCustomerSyncStatus = `-- name: BulkUpdateCustomerSyncStatus :exec

UPDATE customers 
SET payment_sync_status = $1, 
    payment_synced_at = CURRENT_TIMESTAMP, 
    payment_sync_version = payment_sync_version + 1, 
    payment_provider = $2, 
    updated_at = CURRENT_TIMESTAMP
WHERE external_id = ANY($3::text[]) 
  AND deleted_at IS NULL
`

type BulkUpdateCustomerSyncStatusParams struct {
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
	Column3           []string    `json:"column_3"`
}

// Bulk Operations for Initial Sync
func (q *Queries) BulkUpdateCustomerSyncStatus(ctx context.Context, arg BulkUpdateCustomerSyncStatusParams) error {
	_, err := q.db.Exec(ctx, bulkUpdateCustomerSyncStatus, arg.PaymentSyncStatus, arg.PaymentProvider, arg.Column3)
	return err
}

const bulkUpdatePriceSyncStatus = `-- name: BulkUpdatePriceSyncStatus :exec
UPDATE prices 
SET payment_sync_status = $2, 
    payment_synced_at = CURRENT_TIMESTAMP, 
    payment_sync_version = payment_sync_version + 1, 
    payment_provider = $3, 
    updated_at = CURRENT_TIMESTAMP
FROM products p
WHERE prices.product_id = p.id
  AND p.workspace_id = $1 
  AND prices.external_id = ANY($4::text[])
  AND prices.deleted_at IS NULL
`

type BulkUpdatePriceSyncStatusParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
	Column4           []string    `json:"column_4"`
}

func (q *Queries) BulkUpdatePriceSyncStatus(ctx context.Context, arg BulkUpdatePriceSyncStatusParams) error {
	_, err := q.db.Exec(ctx, bulkUpdatePriceSyncStatus,
		arg.WorkspaceID,
		arg.PaymentSyncStatus,
		arg.PaymentProvider,
		arg.Column4,
	)
	return err
}

const bulkUpdateProductSyncStatus = `-- name: BulkUpdateProductSyncStatus :exec
UPDATE products 
SET payment_sync_status = $2, 
    payment_synced_at = CURRENT_TIMESTAMP, 
    payment_sync_version = payment_sync_version + 1, 
    payment_provider = $3, 
    updated_at = CURRENT_TIMESTAMP
WHERE workspace_id = $1 
  AND external_id = ANY($4::text[]) 
  AND deleted_at IS NULL
`

type BulkUpdateProductSyncStatusParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
	Column4           []string    `json:"column_4"`
}

func (q *Queries) BulkUpdateProductSyncStatus(ctx context.Context, arg BulkUpdateProductSyncStatusParams) error {
	_, err := q.db.Exec(ctx, bulkUpdateProductSyncStatus,
		arg.WorkspaceID,
		arg.PaymentSyncStatus,
		arg.PaymentProvider,
		arg.Column4,
	)
	return err
}

const bulkUpdateSubscriptionSyncStatus = `-- name: BulkUpdateSubscriptionSyncStatus :exec
UPDATE subscriptions 
SET payment_sync_status = $2, 
    payment_synced_at = CURRENT_TIMESTAMP, 
    payment_sync_version = payment_sync_version + 1, 
    payment_provider = $3, 
    updated_at = CURRENT_TIMESTAMP
WHERE workspace_id = $1 
  AND external_id = ANY($4::text[]) 
  AND deleted_at IS NULL
`

type BulkUpdateSubscriptionSyncStatusParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
	Column4           []string    `json:"column_4"`
}

func (q *Queries) BulkUpdateSubscriptionSyncStatus(ctx context.Context, arg BulkUpdateSubscriptionSyncStatusParams) error {
	_, err := q.db.Exec(ctx, bulkUpdateSubscriptionSyncStatus,
		arg.WorkspaceID,
		arg.PaymentSyncStatus,
		arg.PaymentProvider,
		arg.Column4,
	)
	return err
}

const countSyncEventsByEntityType = `-- name: CountSyncEventsByEntityType :one
SELECT COUNT(*) FROM payment_sync_events 
WHERE session_id = $1 AND entity_type = $2
`

type CountSyncEventsByEntityTypeParams struct {
	SessionID  uuid.UUID `json:"session_id"`
	EntityType string    `json:"entity_type"`
}

func (q *Queries) CountSyncEventsByEntityType(ctx context.Context, arg CountSyncEventsByEntityTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSyncEventsByEntityType, arg.SessionID, arg.EntityType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSyncEventsBySession = `-- name: CountSyncEventsBySession :one
SELECT COUNT(*) FROM payment_sync_events 
WHERE session_id = $1
`

func (q *Queries) CountSyncEventsBySession(ctx context.Context, sessionID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSyncEventsBySession, sessionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSyncEventsBySessionAndType = `-- name: CountSyncEventsBySessionAndType :one
SELECT COUNT(*) FROM payment_sync_events 
WHERE session_id = $1 AND event_type = $2
`

type CountSyncEventsBySessionAndTypeParams struct {
	SessionID uuid.UUID `json:"session_id"`
	EventType string    `json:"event_type"`
}

func (q *Queries) CountSyncEventsBySessionAndType(ctx context.Context, arg CountSyncEventsBySessionAndTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSyncEventsBySessionAndType, arg.SessionID, arg.EventType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSyncSessions = `-- name: CountSyncSessions :one
SELECT COUNT(*) FROM payment_sync_sessions 
WHERE workspace_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountSyncSessions(ctx context.Context, workspaceID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSyncSessions, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSyncSessionsByProvider = `-- name: CountSyncSessionsByProvider :one
SELECT COUNT(*) FROM payment_sync_sessions 
WHERE workspace_id = $1 AND provider_name = $2 AND deleted_at IS NULL
`

type CountSyncSessionsByProviderParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
}

func (q *Queries) CountSyncSessionsByProvider(ctx context.Context, arg CountSyncSessionsByProviderParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSyncSessionsByProvider, arg.WorkspaceID, arg.ProviderName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWebhookEventsByProvider = `-- name: CountWebhookEventsByProvider :one
SELECT COUNT(*) FROM payment_sync_events 
WHERE workspace_id = $1 
  AND provider_name = $2 
  AND webhook_event_id IS NOT NULL
`

type CountWebhookEventsByProviderParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
}

// NEW: Count webhook events for a provider
func (q *Queries) CountWebhookEventsByProvider(ctx context.Context, arg CountWebhookEventsByProviderParams) (int64, error) {
	row := q.db.QueryRow(ctx, countWebhookEventsByProvider, arg.WorkspaceID, arg.ProviderName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSyncEvent = `-- name: CreateSyncEvent :one

INSERT INTO payment_sync_events (
    session_id, 
    workspace_id, 
    provider_name, 
    entity_type, 
    entity_id, 
    external_id, 
    event_type, 
    event_message, 
    event_details
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at
`

type CreateSyncEventParams struct {
	SessionID    uuid.UUID   `json:"session_id"`
	WorkspaceID  uuid.UUID   `json:"workspace_id"`
	ProviderName string      `json:"provider_name"`
	EntityType   string      `json:"entity_type"`
	EntityID     pgtype.UUID `json:"entity_id"`
	ExternalID   pgtype.Text `json:"external_id"`
	EventType    string      `json:"event_type"`
	EventMessage pgtype.Text `json:"event_message"`
	EventDetails []byte      `json:"event_details"`
}

// Payment Sync Events Queries
func (q *Queries) CreateSyncEvent(ctx context.Context, arg CreateSyncEventParams) (PaymentSyncEvent, error) {
	row := q.db.QueryRow(ctx, createSyncEvent,
		arg.SessionID,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.EntityType,
		arg.EntityID,
		arg.ExternalID,
		arg.EventType,
		arg.EventMessage,
		arg.EventDetails,
	)
	var i PaymentSyncEvent
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.EntityType,
		&i.EntityID,
		&i.ExternalID,
		&i.EventType,
		&i.EventMessage,
		&i.EventDetails,
		&i.WebhookEventID,
		&i.ProviderAccountID,
		&i.IdempotencyKey,
		&i.ProcessingAttempts,
		&i.SignatureValid,
		&i.OccurredAt,
	)
	return i, err
}

const createSyncSession = `-- name: CreateSyncSession :one

INSERT INTO payment_sync_sessions (
    workspace_id, 
    provider_name, 
    session_type, 
    status, 
    entity_types, 
    config
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at
`

type CreateSyncSessionParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
	SessionType  string    `json:"session_type"`
	Status       string    `json:"status"`
	EntityTypes  []string  `json:"entity_types"`
	Config       []byte    `json:"config"`
}

// Payment Sync Sessions Queries
func (q *Queries) CreateSyncSession(ctx context.Context, arg CreateSyncSessionParams) (PaymentSyncSession, error) {
	row := q.db.QueryRow(ctx, createSyncSession,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.SessionType,
		arg.Status,
		arg.EntityTypes,
		arg.Config,
	)
	var i PaymentSyncSession
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.SessionType,
		&i.Status,
		&i.EntityTypes,
		&i.Config,
		&i.Progress,
		&i.ErrorSummary,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createWebhookEvent = `-- name: CreateWebhookEvent :one
INSERT INTO payment_sync_events (
    workspace_id, 
    provider_name, 
    entity_type, 
    entity_id, 
    external_id, 
    event_type, 
    event_message, 
    event_details,
    webhook_event_id,
    provider_account_id,
    idempotency_key,
    processing_attempts,
    signature_valid
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at
`

type CreateWebhookEventParams struct {
	WorkspaceID        uuid.UUID   `json:"workspace_id"`
	ProviderName       string      `json:"provider_name"`
	EntityType         string      `json:"entity_type"`
	EntityID           pgtype.UUID `json:"entity_id"`
	ExternalID         pgtype.Text `json:"external_id"`
	EventType          string      `json:"event_type"`
	EventMessage       pgtype.Text `json:"event_message"`
	EventDetails       []byte      `json:"event_details"`
	WebhookEventID     pgtype.Text `json:"webhook_event_id"`
	ProviderAccountID  pgtype.Text `json:"provider_account_id"`
	IdempotencyKey     pgtype.Text `json:"idempotency_key"`
	ProcessingAttempts pgtype.Int4 `json:"processing_attempts"`
	SignatureValid     pgtype.Bool `json:"signature_valid"`
}

// NEW: Create webhook-specific sync event with all webhook fields
func (q *Queries) CreateWebhookEvent(ctx context.Context, arg CreateWebhookEventParams) (PaymentSyncEvent, error) {
	row := q.db.QueryRow(ctx, createWebhookEvent,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.EntityType,
		arg.EntityID,
		arg.ExternalID,
		arg.EventType,
		arg.EventMessage,
		arg.EventDetails,
		arg.WebhookEventID,
		arg.ProviderAccountID,
		arg.IdempotencyKey,
		arg.ProcessingAttempts,
		arg.SignatureValid,
	)
	var i PaymentSyncEvent
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.EntityType,
		&i.EntityID,
		&i.ExternalID,
		&i.EventType,
		&i.EventMessage,
		&i.EventDetails,
		&i.WebhookEventID,
		&i.ProviderAccountID,
		&i.IdempotencyKey,
		&i.ProcessingAttempts,
		&i.SignatureValid,
		&i.OccurredAt,
	)
	return i, err
}

const deleteSyncEventsBySession = `-- name: DeleteSyncEventsBySession :exec
DELETE FROM payment_sync_events
WHERE session_id = $1
`

func (q *Queries) DeleteSyncEventsBySession(ctx context.Context, sessionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSyncEventsBySession, sessionID)
	return err
}

const deleteSyncSession = `-- name: DeleteSyncSession :exec
UPDATE payment_sync_sessions
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
`

type DeleteSyncSessionParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) DeleteSyncSession(ctx context.Context, arg DeleteSyncSessionParams) error {
	_, err := q.db.Exec(ctx, deleteSyncSession, arg.ID, arg.WorkspaceID)
	return err
}

const getActiveSyncSessionsByProvider = `-- name: GetActiveSyncSessionsByProvider :many
SELECT id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at FROM payment_sync_sessions 
WHERE workspace_id = $1 AND provider_name = $2 AND status IN ('pending', 'running') AND deleted_at IS NULL
ORDER BY created_at DESC
`

type GetActiveSyncSessionsByProviderParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
}

func (q *Queries) GetActiveSyncSessionsByProvider(ctx context.Context, arg GetActiveSyncSessionsByProviderParams) ([]PaymentSyncSession, error) {
	rows, err := q.db.Query(ctx, getActiveSyncSessionsByProvider, arg.WorkspaceID, arg.ProviderName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncSession{}
	for rows.Next() {
		var i PaymentSyncSession
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.SessionType,
			&i.Status,
			&i.EntityTypes,
			&i.Config,
			&i.Progress,
			&i.ErrorSummary,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerByExternalIDAndProvider = `-- name: GetCustomerByExternalIDAndProvider :one
SELECT 
    'customer' as entity_type,
    c.id as entity_id,
    c.external_id,
    c.payment_provider
FROM customers c
WHERE c.external_id = $1 
    AND c.payment_provider = $2 
    AND c.deleted_at IS NULL
LIMIT 1
`

type GetCustomerByExternalIDAndProviderParams struct {
	ExternalID      pgtype.Text `json:"external_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
}

type GetCustomerByExternalIDAndProviderRow struct {
	EntityType      string      `json:"entity_type"`
	EntityID        uuid.UUID   `json:"entity_id"`
	ExternalID      pgtype.Text `json:"external_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
}

func (q *Queries) GetCustomerByExternalIDAndProvider(ctx context.Context, arg GetCustomerByExternalIDAndProviderParams) (GetCustomerByExternalIDAndProviderRow, error) {
	row := q.db.QueryRow(ctx, getCustomerByExternalIDAndProvider, arg.ExternalID, arg.PaymentProvider)
	var i GetCustomerByExternalIDAndProviderRow
	err := row.Scan(
		&i.EntityType,
		&i.EntityID,
		&i.ExternalID,
		&i.PaymentProvider,
	)
	return i, err
}

const getCustomersByPaymentProvider = `-- name: GetCustomersByPaymentProvider :many

SELECT id, web3auth_id, external_id, email, name, phone, description, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at FROM customers 
WHERE payment_provider = $1 AND deleted_at IS NULL
`

// Payment Sync Status Queries for Entities
func (q *Queries) GetCustomersByPaymentProvider(ctx context.Context, paymentProvider pgtype.Text) ([]Customer, error) {
	rows, err := q.db.Query(ctx, getCustomersByPaymentProvider, paymentProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Web3authID,
			&i.ExternalID,
			&i.Email,
			&i.Name,
			&i.Phone,
			&i.Description,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomersByPaymentSyncStatus = `-- name: GetCustomersByPaymentSyncStatus :many
SELECT id, web3auth_id, external_id, email, name, phone, description, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at FROM customers 
WHERE payment_sync_status = $1 AND deleted_at IS NULL
`

func (q *Queries) GetCustomersByPaymentSyncStatus(ctx context.Context, paymentSyncStatus pgtype.Text) ([]Customer, error) {
	rows, err := q.db.Query(ctx, getCustomersByPaymentSyncStatus, paymentSyncStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Web3authID,
			&i.ExternalID,
			&i.Email,
			&i.Name,
			&i.Phone,
			&i.Description,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntitiesBySyncStatusAndProvider = `-- name: GetEntitiesBySyncStatusAndProvider :many
SELECT 
    'customer' as entity_type,
    c.id as entity_id,
    c.external_id,
    c.payment_sync_status,
    c.payment_synced_at,
    c.payment_provider
FROM customers c
INNER JOIN workspace_customers wc ON c.id = wc.customer_id
WHERE wc.workspace_id = $1 AND c.payment_provider = $2 AND c.payment_sync_status = $3 AND wc.deleted_at IS NULL AND c.deleted_at IS NULL

UNION ALL

SELECT 
    'product' as entity_type,
    p.id as entity_id,
    p.external_id,
    p.payment_sync_status,
    p.payment_synced_at,
    p.payment_provider
FROM products p
WHERE p.workspace_id = $1 AND p.payment_provider = $2 AND p.payment_sync_status = $3 AND p.deleted_at IS NULL

UNION ALL

SELECT 
    'price' as entity_type,
    pr.id as entity_id,
    pr.external_id,
    pr.payment_sync_status,
    pr.payment_synced_at,
    pr.payment_provider
FROM prices pr
JOIN products prod ON pr.product_id = prod.id
WHERE prod.workspace_id = $1 AND pr.payment_provider = $2 AND pr.payment_sync_status = $3 AND pr.deleted_at IS NULL AND prod.deleted_at IS NULL

UNION ALL

SELECT 
    'subscription' as entity_type,
    s.id as entity_id,
    s.external_id,
    s.payment_sync_status,
    s.payment_synced_at,
    s.payment_provider
FROM subscriptions s
WHERE s.workspace_id = $1 AND s.payment_provider = $2 AND s.payment_sync_status = $3 AND s.deleted_at IS NULL

ORDER BY payment_synced_at DESC
`

type GetEntitiesBySyncStatusAndProviderParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
}

type GetEntitiesBySyncStatusAndProviderRow struct {
	EntityType        string             `json:"entity_type"`
	EntityID          uuid.UUID          `json:"entity_id"`
	ExternalID        pgtype.Text        `json:"external_id"`
	PaymentSyncStatus pgtype.Text        `json:"payment_sync_status"`
	PaymentSyncedAt   pgtype.Timestamptz `json:"payment_synced_at"`
	PaymentProvider   pgtype.Text        `json:"payment_provider"`
}

func (q *Queries) GetEntitiesBySyncStatusAndProvider(ctx context.Context, arg GetEntitiesBySyncStatusAndProviderParams) ([]GetEntitiesBySyncStatusAndProviderRow, error) {
	rows, err := q.db.Query(ctx, getEntitiesBySyncStatusAndProvider, arg.WorkspaceID, arg.PaymentProvider, arg.PaymentSyncStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntitiesBySyncStatusAndProviderRow{}
	for rows.Next() {
		var i GetEntitiesBySyncStatusAndProviderRow
		if err := rows.Scan(
			&i.EntityType,
			&i.EntityID,
			&i.ExternalID,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentProvider,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityByExternalIDWithWorkspace = `-- name: GetEntityByExternalIDWithWorkspace :one

SELECT 
    CASE 
        WHEN p.id IS NOT NULL THEN 'product'
        WHEN pr.id IS NOT NULL THEN 'price'
        WHEN s.id IS NOT NULL THEN 'subscription'
        ELSE 'unknown'
    END as entity_type,
    COALESCE(p.id, pr.id, s.id) as entity_id,
    COALESCE(p.external_id, pr.external_id, s.external_id) as external_id,
    COALESCE(p.payment_provider, pr.payment_provider, s.payment_provider) as payment_provider
FROM (SELECT $1 as workspace_id, $2 as external_id, $3 as payment_provider) params
LEFT JOIN products p ON p.workspace_id = params.workspace_id 
    AND p.external_id = params.external_id 
    AND p.payment_provider = params.payment_provider 
    AND p.deleted_at IS NULL
LEFT JOIN prices pr ON pr.external_id = params.external_id 
    AND pr.payment_provider = params.payment_provider 
    AND pr.deleted_at IS NULL
    AND EXISTS (SELECT 1 FROM products prod WHERE prod.id = pr.product_id AND prod.workspace_id = params.workspace_id AND prod.deleted_at IS NULL)
LEFT JOIN subscriptions s ON s.workspace_id = params.workspace_id 
    AND s.external_id = params.external_id 
    AND s.payment_provider = params.payment_provider 
    AND s.deleted_at IS NULL
WHERE COALESCE(p.id, pr.id, s.id) IS NOT NULL
LIMIT 1
`

type GetEntityByExternalIDWithWorkspaceParams struct {
	WorkspaceID     uuid.UUID   `json:"workspace_id"`
	ExternalID      pgtype.Text `json:"external_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
}

type GetEntityByExternalIDWithWorkspaceRow struct {
	EntityType      string      `json:"entity_type"`
	EntityID        uuid.UUID   `json:"entity_id"`
	ExternalID      pgtype.Text `json:"external_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
}

// Cross-Entity Lookup Queries for External IDs
func (q *Queries) GetEntityByExternalIDWithWorkspace(ctx context.Context, arg GetEntityByExternalIDWithWorkspaceParams) (GetEntityByExternalIDWithWorkspaceRow, error) {
	row := q.db.QueryRow(ctx, getEntityByExternalIDWithWorkspace, arg.WorkspaceID, arg.ExternalID, arg.PaymentProvider)
	var i GetEntityByExternalIDWithWorkspaceRow
	err := row.Scan(
		&i.EntityType,
		&i.EntityID,
		&i.ExternalID,
		&i.PaymentProvider,
	)
	return i, err
}

const getLatestSyncEventsByEntityType = `-- name: GetLatestSyncEventsByEntityType :many
SELECT DISTINCT ON (entity_type, external_id) 
    id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at
FROM payment_sync_events 
WHERE session_id = $1
ORDER BY entity_type, external_id, occurred_at DESC
`

func (q *Queries) GetLatestSyncEventsByEntityType(ctx context.Context, sessionID uuid.UUID) ([]PaymentSyncEvent, error) {
	rows, err := q.db.Query(ctx, getLatestSyncEventsByEntityType, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncEvent{}
	for rows.Next() {
		var i PaymentSyncEvent
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.EntityType,
			&i.EntityID,
			&i.ExternalID,
			&i.EventType,
			&i.EventMessage,
			&i.EventDetails,
			&i.WebhookEventID,
			&i.ProviderAccountID,
			&i.IdempotencyKey,
			&i.ProcessingAttempts,
			&i.SignatureValid,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestSyncSessionByProvider = `-- name: GetLatestSyncSessionByProvider :one
SELECT id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at FROM payment_sync_sessions 
WHERE workspace_id = $1 AND provider_name = $2 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT 1
`

type GetLatestSyncSessionByProviderParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
}

func (q *Queries) GetLatestSyncSessionByProvider(ctx context.Context, arg GetLatestSyncSessionByProviderParams) (PaymentSyncSession, error) {
	row := q.db.QueryRow(ctx, getLatestSyncSessionByProvider, arg.WorkspaceID, arg.ProviderName)
	var i PaymentSyncSession
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.SessionType,
		&i.Status,
		&i.EntityTypes,
		&i.Config,
		&i.Progress,
		&i.ErrorSummary,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPricesByPaymentProvider = `-- name: GetPricesByPaymentProvider :many
SELECT p.id, p.product_id, p.external_id, p.active, p.type, p.nickname, p.currency, p.unit_amount_in_pennies, p.interval_type, p.term_length, p.metadata, p.payment_sync_status, p.payment_synced_at, p.payment_sync_version, p.payment_provider, p.created_at, p.updated_at, p.deleted_at FROM prices p
JOIN products pr ON p.product_id = pr.id
WHERE pr.workspace_id = $1 AND p.payment_provider = $2 AND p.deleted_at IS NULL AND pr.deleted_at IS NULL
`

type GetPricesByPaymentProviderParams struct {
	WorkspaceID     uuid.UUID   `json:"workspace_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
}

func (q *Queries) GetPricesByPaymentProvider(ctx context.Context, arg GetPricesByPaymentProviderParams) ([]Price, error) {
	rows, err := q.db.Query(ctx, getPricesByPaymentProvider, arg.WorkspaceID, arg.PaymentProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Price{}
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ExternalID,
			&i.Active,
			&i.Type,
			&i.Nickname,
			&i.Currency,
			&i.UnitAmountInPennies,
			&i.IntervalType,
			&i.TermLength,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPricesByPaymentSyncStatus = `-- name: GetPricesByPaymentSyncStatus :many
SELECT p.id, p.product_id, p.external_id, p.active, p.type, p.nickname, p.currency, p.unit_amount_in_pennies, p.interval_type, p.term_length, p.metadata, p.payment_sync_status, p.payment_synced_at, p.payment_sync_version, p.payment_provider, p.created_at, p.updated_at, p.deleted_at FROM prices p
JOIN products pr ON p.product_id = pr.id
WHERE pr.workspace_id = $1 AND p.payment_sync_status = $2 AND p.deleted_at IS NULL AND pr.deleted_at IS NULL
`

type GetPricesByPaymentSyncStatusParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
}

func (q *Queries) GetPricesByPaymentSyncStatus(ctx context.Context, arg GetPricesByPaymentSyncStatusParams) ([]Price, error) {
	rows, err := q.db.Query(ctx, getPricesByPaymentSyncStatus, arg.WorkspaceID, arg.PaymentSyncStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Price{}
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ExternalID,
			&i.Active,
			&i.Type,
			&i.Nickname,
			&i.Currency,
			&i.UnitAmountInPennies,
			&i.IntervalType,
			&i.TermLength,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByPaymentProvider = `-- name: GetProductsByPaymentProvider :many
SELECT id, workspace_id, wallet_id, external_id, name, description, image_url, url, active, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at FROM products 
WHERE workspace_id = $1 AND payment_provider = $2 AND deleted_at IS NULL
`

type GetProductsByPaymentProviderParams struct {
	WorkspaceID     uuid.UUID   `json:"workspace_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
}

func (q *Queries) GetProductsByPaymentProvider(ctx context.Context, arg GetProductsByPaymentProviderParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsByPaymentProvider, arg.WorkspaceID, arg.PaymentProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletID,
			&i.ExternalID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Url,
			&i.Active,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByPaymentSyncStatus = `-- name: GetProductsByPaymentSyncStatus :many
SELECT id, workspace_id, wallet_id, external_id, name, description, image_url, url, active, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at FROM products 
WHERE workspace_id = $1 AND payment_sync_status = $2 AND deleted_at IS NULL
`

type GetProductsByPaymentSyncStatusParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
}

func (q *Queries) GetProductsByPaymentSyncStatus(ctx context.Context, arg GetProductsByPaymentSyncStatusParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsByPaymentSyncStatus, arg.WorkspaceID, arg.PaymentSyncStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletID,
			&i.ExternalID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Url,
			&i.Active,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProviderSyncStatusByWorkspace = `-- name: GetProviderSyncStatusByWorkspace :many
SELECT 
    provider_name,
    COUNT(*) as total_sessions,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_sessions,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_sessions,
    COUNT(CASE WHEN status IN ('pending', 'running') THEN 1 END) as active_sessions,
    MAX(completed_at) as last_successful_sync,
    MIN(created_at) as first_sync_session
FROM payment_sync_sessions
WHERE workspace_id = $1 AND deleted_at IS NULL
GROUP BY provider_name
ORDER BY last_successful_sync DESC
`

type GetProviderSyncStatusByWorkspaceRow struct {
	ProviderName       string      `json:"provider_name"`
	TotalSessions      int64       `json:"total_sessions"`
	CompletedSessions  int64       `json:"completed_sessions"`
	FailedSessions     int64       `json:"failed_sessions"`
	ActiveSessions     int64       `json:"active_sessions"`
	LastSuccessfulSync interface{} `json:"last_successful_sync"`
	FirstSyncSession   interface{} `json:"first_sync_session"`
}

func (q *Queries) GetProviderSyncStatusByWorkspace(ctx context.Context, workspaceID uuid.UUID) ([]GetProviderSyncStatusByWorkspaceRow, error) {
	rows, err := q.db.Query(ctx, getProviderSyncStatusByWorkspace, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProviderSyncStatusByWorkspaceRow{}
	for rows.Next() {
		var i GetProviderSyncStatusByWorkspaceRow
		if err := rows.Scan(
			&i.ProviderName,
			&i.TotalSessions,
			&i.CompletedSessions,
			&i.FailedSessions,
			&i.ActiveSessions,
			&i.LastSuccessfulSync,
			&i.FirstSyncSession,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionsByPaymentProvider = `-- name: GetSubscriptionsByPaymentProvider :many
SELECT id, customer_id, product_id, workspace_id, price_id, product_token_id, external_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at FROM subscriptions 
WHERE workspace_id = $1 AND payment_provider = $2 AND deleted_at IS NULL
`

type GetSubscriptionsByPaymentProviderParams struct {
	WorkspaceID     uuid.UUID   `json:"workspace_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
}

func (q *Queries) GetSubscriptionsByPaymentProvider(ctx context.Context, arg GetSubscriptionsByPaymentProviderParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsByPaymentProvider, arg.WorkspaceID, arg.PaymentProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.WorkspaceID,
			&i.PriceID,
			&i.ProductTokenID,
			&i.ExternalID,
			&i.TokenAmount,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionsByPaymentSyncStatus = `-- name: GetSubscriptionsByPaymentSyncStatus :many
SELECT id, customer_id, product_id, workspace_id, price_id, product_token_id, external_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at FROM subscriptions 
WHERE workspace_id = $1 AND payment_sync_status = $2 AND deleted_at IS NULL
`

type GetSubscriptionsByPaymentSyncStatusParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
}

func (q *Queries) GetSubscriptionsByPaymentSyncStatus(ctx context.Context, arg GetSubscriptionsByPaymentSyncStatusParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsByPaymentSyncStatus, arg.WorkspaceID, arg.PaymentSyncStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.WorkspaceID,
			&i.PriceID,
			&i.ProductTokenID,
			&i.ExternalID,
			&i.TokenAmount,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSyncEvent = `-- name: GetSyncEvent :one
SELECT id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at FROM payment_sync_events 
WHERE id = $1
`

func (q *Queries) GetSyncEvent(ctx context.Context, id uuid.UUID) (PaymentSyncEvent, error) {
	row := q.db.QueryRow(ctx, getSyncEvent, id)
	var i PaymentSyncEvent
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.EntityType,
		&i.EntityID,
		&i.ExternalID,
		&i.EventType,
		&i.EventMessage,
		&i.EventDetails,
		&i.WebhookEventID,
		&i.ProviderAccountID,
		&i.IdempotencyKey,
		&i.ProcessingAttempts,
		&i.SignatureValid,
		&i.OccurredAt,
	)
	return i, err
}

const getSyncEventsByExternalID = `-- name: GetSyncEventsByExternalID :many
SELECT id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at FROM payment_sync_events 
WHERE workspace_id = $1 AND provider_name = $2 AND external_id = $3
ORDER BY occurred_at DESC
`

type GetSyncEventsByExternalIDParams struct {
	WorkspaceID  uuid.UUID   `json:"workspace_id"`
	ProviderName string      `json:"provider_name"`
	ExternalID   pgtype.Text `json:"external_id"`
}

func (q *Queries) GetSyncEventsByExternalID(ctx context.Context, arg GetSyncEventsByExternalIDParams) ([]PaymentSyncEvent, error) {
	rows, err := q.db.Query(ctx, getSyncEventsByExternalID, arg.WorkspaceID, arg.ProviderName, arg.ExternalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncEvent{}
	for rows.Next() {
		var i PaymentSyncEvent
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.EntityType,
			&i.EntityID,
			&i.ExternalID,
			&i.EventType,
			&i.EventMessage,
			&i.EventDetails,
			&i.WebhookEventID,
			&i.ProviderAccountID,
			&i.IdempotencyKey,
			&i.ProcessingAttempts,
			&i.SignatureValid,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSyncEventsSummaryBySession = `-- name: GetSyncEventsSummaryBySession :one
SELECT 
    session_id,
    COUNT(*) as total_events,
    COUNT(CASE WHEN event_type = 'sync_completed' THEN 1 END) as completed_count,
    COUNT(CASE WHEN event_type = 'sync_failed' THEN 1 END) as failed_count,
    COUNT(CASE WHEN event_type = 'sync_skipped' THEN 1 END) as skipped_count
FROM payment_sync_events 
WHERE session_id = $1
GROUP BY session_id
`

type GetSyncEventsSummaryBySessionRow struct {
	SessionID      uuid.UUID `json:"session_id"`
	TotalEvents    int64     `json:"total_events"`
	CompletedCount int64     `json:"completed_count"`
	FailedCount    int64     `json:"failed_count"`
	SkippedCount   int64     `json:"skipped_count"`
}

func (q *Queries) GetSyncEventsSummaryBySession(ctx context.Context, sessionID uuid.UUID) (GetSyncEventsSummaryBySessionRow, error) {
	row := q.db.QueryRow(ctx, getSyncEventsSummaryBySession, sessionID)
	var i GetSyncEventsSummaryBySessionRow
	err := row.Scan(
		&i.SessionID,
		&i.TotalEvents,
		&i.CompletedCount,
		&i.FailedCount,
		&i.SkippedCount,
	)
	return i, err
}

const getSyncSession = `-- name: GetSyncSession :one
SELECT id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at FROM payment_sync_sessions 
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
`

type GetSyncSessionParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) GetSyncSession(ctx context.Context, arg GetSyncSessionParams) (PaymentSyncSession, error) {
	row := q.db.QueryRow(ctx, getSyncSession, arg.ID, arg.WorkspaceID)
	var i PaymentSyncSession
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.SessionType,
		&i.Status,
		&i.EntityTypes,
		&i.Config,
		&i.Progress,
		&i.ErrorSummary,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSyncSessionByProvider = `-- name: GetSyncSessionByProvider :one
SELECT id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at FROM payment_sync_sessions 
WHERE id = $1 AND workspace_id = $2 AND provider_name = $3 AND deleted_at IS NULL
`

type GetSyncSessionByProviderParams struct {
	ID           uuid.UUID `json:"id"`
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
}

func (q *Queries) GetSyncSessionByProvider(ctx context.Context, arg GetSyncSessionByProviderParams) (PaymentSyncSession, error) {
	row := q.db.QueryRow(ctx, getSyncSessionByProvider, arg.ID, arg.WorkspaceID, arg.ProviderName)
	var i PaymentSyncSession
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.SessionType,
		&i.Status,
		&i.EntityTypes,
		&i.Config,
		&i.Progress,
		&i.ErrorSummary,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getWebhookEventByIdempotencyKey = `-- name: GetWebhookEventByIdempotencyKey :one
SELECT id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at FROM payment_sync_events 
WHERE workspace_id = $1 
  AND provider_name = $2 
  AND idempotency_key = $3
  AND idempotency_key IS NOT NULL
ORDER BY occurred_at DESC
LIMIT 1
`

type GetWebhookEventByIdempotencyKeyParams struct {
	WorkspaceID    uuid.UUID   `json:"workspace_id"`
	ProviderName   string      `json:"provider_name"`
	IdempotencyKey pgtype.Text `json:"idempotency_key"`
}

// NEW: Check for duplicate webhook processing using idempotency key
func (q *Queries) GetWebhookEventByIdempotencyKey(ctx context.Context, arg GetWebhookEventByIdempotencyKeyParams) (PaymentSyncEvent, error) {
	row := q.db.QueryRow(ctx, getWebhookEventByIdempotencyKey, arg.WorkspaceID, arg.ProviderName, arg.IdempotencyKey)
	var i PaymentSyncEvent
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.EntityType,
		&i.EntityID,
		&i.ExternalID,
		&i.EventType,
		&i.EventMessage,
		&i.EventDetails,
		&i.WebhookEventID,
		&i.ProviderAccountID,
		&i.IdempotencyKey,
		&i.ProcessingAttempts,
		&i.SignatureValid,
		&i.OccurredAt,
	)
	return i, err
}

const getWebhookEventByProviderEventID = `-- name: GetWebhookEventByProviderEventID :one
SELECT id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at FROM payment_sync_events 
WHERE workspace_id = $1 
  AND provider_name = $2 
  AND webhook_event_id = $3
  AND webhook_event_id IS NOT NULL
ORDER BY occurred_at DESC
LIMIT 1
`

type GetWebhookEventByProviderEventIDParams struct {
	WorkspaceID    uuid.UUID   `json:"workspace_id"`
	ProviderName   string      `json:"provider_name"`
	WebhookEventID pgtype.Text `json:"webhook_event_id"`
}

// NEW: Get webhook event by provider's event ID
func (q *Queries) GetWebhookEventByProviderEventID(ctx context.Context, arg GetWebhookEventByProviderEventIDParams) (PaymentSyncEvent, error) {
	row := q.db.QueryRow(ctx, getWebhookEventByProviderEventID, arg.WorkspaceID, arg.ProviderName, arg.WebhookEventID)
	var i PaymentSyncEvent
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.EntityType,
		&i.EntityID,
		&i.ExternalID,
		&i.EventType,
		&i.EventMessage,
		&i.EventDetails,
		&i.WebhookEventID,
		&i.ProviderAccountID,
		&i.IdempotencyKey,
		&i.ProcessingAttempts,
		&i.SignatureValid,
		&i.OccurredAt,
	)
	return i, err
}

const getWebhookEventsSummaryByProvider = `-- name: GetWebhookEventsSummaryByProvider :one
SELECT 
    provider_name,
    COUNT(*) as total_webhook_events,
    COUNT(CASE WHEN event_type = 'webhook_processed_successfully' THEN 1 END) as successful_count,
    COUNT(CASE WHEN event_type = 'webhook_processing_failed' THEN 1 END) as failed_count,
    COUNT(CASE WHEN processing_attempts > 1 THEN 1 END) as retry_count,
    COUNT(CASE WHEN signature_valid = false THEN 1 END) as invalid_signature_count,
    MAX(occurred_at) as last_webhook_at
FROM payment_sync_events 
WHERE workspace_id = $1 
  AND provider_name = $2 
  AND webhook_event_id IS NOT NULL
GROUP BY provider_name
`

type GetWebhookEventsSummaryByProviderParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
}

type GetWebhookEventsSummaryByProviderRow struct {
	ProviderName          string      `json:"provider_name"`
	TotalWebhookEvents    int64       `json:"total_webhook_events"`
	SuccessfulCount       int64       `json:"successful_count"`
	FailedCount           int64       `json:"failed_count"`
	RetryCount            int64       `json:"retry_count"`
	InvalidSignatureCount int64       `json:"invalid_signature_count"`
	LastWebhookAt         interface{} `json:"last_webhook_at"`
}

// NEW: Get webhook processing summary for a provider
func (q *Queries) GetWebhookEventsSummaryByProvider(ctx context.Context, arg GetWebhookEventsSummaryByProviderParams) (GetWebhookEventsSummaryByProviderRow, error) {
	row := q.db.QueryRow(ctx, getWebhookEventsSummaryByProvider, arg.WorkspaceID, arg.ProviderName)
	var i GetWebhookEventsSummaryByProviderRow
	err := row.Scan(
		&i.ProviderName,
		&i.TotalWebhookEvents,
		&i.SuccessfulCount,
		&i.FailedCount,
		&i.RetryCount,
		&i.InvalidSignatureCount,
		&i.LastWebhookAt,
	)
	return i, err
}

const getWorkspaceCustomersByPaymentProvider = `-- name: GetWorkspaceCustomersByPaymentProvider :many
SELECT c.id, c.web3auth_id, c.external_id, c.email, c.name, c.phone, c.description, c.metadata, c.payment_sync_status, c.payment_synced_at, c.payment_sync_version, c.payment_provider, c.created_at, c.updated_at, c.deleted_at FROM customers c
INNER JOIN workspace_customers wc ON c.id = wc.customer_id
WHERE wc.workspace_id = $1 AND c.payment_provider = $2 AND wc.deleted_at IS NULL AND c.deleted_at IS NULL
`

type GetWorkspaceCustomersByPaymentProviderParams struct {
	WorkspaceID     uuid.UUID   `json:"workspace_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
}

func (q *Queries) GetWorkspaceCustomersByPaymentProvider(ctx context.Context, arg GetWorkspaceCustomersByPaymentProviderParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, getWorkspaceCustomersByPaymentProvider, arg.WorkspaceID, arg.PaymentProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Web3authID,
			&i.ExternalID,
			&i.Email,
			&i.Name,
			&i.Phone,
			&i.Description,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspaceCustomersByPaymentSyncStatus = `-- name: GetWorkspaceCustomersByPaymentSyncStatus :many
SELECT c.id, c.web3auth_id, c.external_id, c.email, c.name, c.phone, c.description, c.metadata, c.payment_sync_status, c.payment_synced_at, c.payment_sync_version, c.payment_provider, c.created_at, c.updated_at, c.deleted_at FROM customers c
INNER JOIN workspace_customers wc ON c.id = wc.customer_id
WHERE wc.workspace_id = $1 AND c.payment_sync_status = $2 AND wc.deleted_at IS NULL AND c.deleted_at IS NULL
`

type GetWorkspaceCustomersByPaymentSyncStatusParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
}

func (q *Queries) GetWorkspaceCustomersByPaymentSyncStatus(ctx context.Context, arg GetWorkspaceCustomersByPaymentSyncStatusParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, getWorkspaceCustomersByPaymentSyncStatus, arg.WorkspaceID, arg.PaymentSyncStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Web3authID,
			&i.ExternalID,
			&i.Email,
			&i.Name,
			&i.Phone,
			&i.Description,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspaceProviderConfig = `-- name: GetWorkspaceProviderConfig :one

SELECT 
    w.id,
    w.metadata,
    COALESCE(w.metadata ->> 'payment_providers', '{}') as provider_configs
FROM workspaces w
WHERE w.id = $1 AND w.deleted_at IS NULL
`

type GetWorkspaceProviderConfigRow struct {
	ID              uuid.UUID   `json:"id"`
	Metadata        []byte      `json:"metadata"`
	ProviderConfigs interface{} `json:"provider_configs"`
}

// Workspace Provider Configuration Queries (using workspace metadata for now)
func (q *Queries) GetWorkspaceProviderConfig(ctx context.Context, id uuid.UUID) (GetWorkspaceProviderConfigRow, error) {
	row := q.db.QueryRow(ctx, getWorkspaceProviderConfig, id)
	var i GetWorkspaceProviderConfigRow
	err := row.Scan(&i.ID, &i.Metadata, &i.ProviderConfigs)
	return i, err
}

const getWorkspaceSyncSummary = `-- name: GetWorkspaceSyncSummary :one

SELECT 
    w.id as workspace_id,
    w.name as workspace_name,
    COUNT(DISTINCT pss.id) as total_sync_sessions,
    COUNT(DISTINCT CASE WHEN pss.status = 'completed' THEN pss.id END) as completed_sessions,
    COUNT(DISTINCT CASE WHEN pss.status = 'failed' THEN pss.id END) as failed_sessions,
    COUNT(DISTINCT CASE WHEN pss.status IN ('pending', 'running') THEN pss.id END) as active_sessions,
    COUNT(DISTINCT CASE WHEN c.payment_sync_status = 'synced' THEN c.id END) as synced_customers,
    COUNT(DISTINCT CASE WHEN p.payment_sync_status = 'synced' THEN p.id END) as synced_products,
    COUNT(DISTINCT CASE WHEN pr.payment_sync_status = 'synced' THEN pr.id END) as synced_prices,
    COUNT(DISTINCT CASE WHEN s.payment_sync_status = 'synced' THEN s.id END) as synced_subscriptions,
    MAX(pss.completed_at) as last_successful_sync
FROM workspaces w
LEFT JOIN payment_sync_sessions pss ON w.id = pss.workspace_id AND pss.deleted_at IS NULL
LEFT JOIN workspace_customers wc ON w.id = wc.workspace_id AND wc.deleted_at IS NULL
LEFT JOIN customers c ON wc.customer_id = c.id AND c.deleted_at IS NULL
LEFT JOIN products p ON w.id = p.workspace_id AND p.deleted_at IS NULL
LEFT JOIN prices pr ON p.id = pr.product_id AND pr.deleted_at IS NULL
LEFT JOIN subscriptions s ON w.id = s.workspace_id AND s.deleted_at IS NULL
WHERE w.id = $1 AND w.deleted_at IS NULL
GROUP BY w.id, w.name
`

type GetWorkspaceSyncSummaryRow struct {
	WorkspaceID         uuid.UUID   `json:"workspace_id"`
	WorkspaceName       string      `json:"workspace_name"`
	TotalSyncSessions   int64       `json:"total_sync_sessions"`
	CompletedSessions   int64       `json:"completed_sessions"`
	FailedSessions      int64       `json:"failed_sessions"`
	ActiveSessions      int64       `json:"active_sessions"`
	SyncedCustomers     int64       `json:"synced_customers"`
	SyncedProducts      int64       `json:"synced_products"`
	SyncedPrices        int64       `json:"synced_prices"`
	SyncedSubscriptions int64       `json:"synced_subscriptions"`
	LastSuccessfulSync  interface{} `json:"last_successful_sync"`
}

// Additional Workspace-specific Queries
func (q *Queries) GetWorkspaceSyncSummary(ctx context.Context, id uuid.UUID) (GetWorkspaceSyncSummaryRow, error) {
	row := q.db.QueryRow(ctx, getWorkspaceSyncSummary, id)
	var i GetWorkspaceSyncSummaryRow
	err := row.Scan(
		&i.WorkspaceID,
		&i.WorkspaceName,
		&i.TotalSyncSessions,
		&i.CompletedSessions,
		&i.FailedSessions,
		&i.ActiveSessions,
		&i.SyncedCustomers,
		&i.SyncedProducts,
		&i.SyncedPrices,
		&i.SyncedSubscriptions,
		&i.LastSuccessfulSync,
	)
	return i, err
}

const getWorkspacesByProvider = `-- name: GetWorkspacesByProvider :many
SELECT w.id, w.account_id, w.name, w.description, w.business_name, w.business_type, w.website_url, w.support_email, w.support_phone, w.metadata, w.livemode, w.created_at, w.updated_at, w.deleted_at
FROM workspaces w
WHERE w.metadata -> 'payment_providers' ? $1 
  AND w.deleted_at IS NULL
ORDER BY w.created_at DESC
`

func (q *Queries) GetWorkspacesByProvider(ctx context.Context, metadata []byte) ([]Workspace, error) {
	rows, err := q.db.Query(ctx, getWorkspacesByProvider, metadata)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workspace{}
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Name,
			&i.Description,
			&i.BusinessName,
			&i.BusinessType,
			&i.WebsiteUrl,
			&i.SupportEmail,
			&i.SupportPhone,
			&i.Metadata,
			&i.Livemode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFailedWebhookEvents = `-- name: ListFailedWebhookEvents :many
SELECT id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at FROM payment_sync_events 
WHERE workspace_id = $1 
  AND provider_name = $2
  AND webhook_event_id IS NOT NULL
  AND event_type = 'webhook_processing_failed'
  AND processing_attempts >= $3
ORDER BY occurred_at DESC
LIMIT $4 OFFSET $5
`

type ListFailedWebhookEventsParams struct {
	WorkspaceID        uuid.UUID   `json:"workspace_id"`
	ProviderName       string      `json:"provider_name"`
	ProcessingAttempts pgtype.Int4 `json:"processing_attempts"`
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
}

// NEW: List webhook events that failed processing
func (q *Queries) ListFailedWebhookEvents(ctx context.Context, arg ListFailedWebhookEventsParams) ([]PaymentSyncEvent, error) {
	rows, err := q.db.Query(ctx, listFailedWebhookEvents,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.ProcessingAttempts,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncEvent{}
	for rows.Next() {
		var i PaymentSyncEvent
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.EntityType,
			&i.EntityID,
			&i.ExternalID,
			&i.EventType,
			&i.EventMessage,
			&i.EventDetails,
			&i.WebhookEventID,
			&i.ProviderAccountID,
			&i.IdempotencyKey,
			&i.ProcessingAttempts,
			&i.SignatureValid,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncEventsByEntityType = `-- name: ListSyncEventsByEntityType :many
SELECT id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at FROM payment_sync_events 
WHERE session_id = $1 AND entity_type = $2
ORDER BY occurred_at DESC
LIMIT $3 OFFSET $4
`

type ListSyncEventsByEntityTypeParams struct {
	SessionID  uuid.UUID `json:"session_id"`
	EntityType string    `json:"entity_type"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

func (q *Queries) ListSyncEventsByEntityType(ctx context.Context, arg ListSyncEventsByEntityTypeParams) ([]PaymentSyncEvent, error) {
	rows, err := q.db.Query(ctx, listSyncEventsByEntityType,
		arg.SessionID,
		arg.EntityType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncEvent{}
	for rows.Next() {
		var i PaymentSyncEvent
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.EntityType,
			&i.EntityID,
			&i.ExternalID,
			&i.EventType,
			&i.EventMessage,
			&i.EventDetails,
			&i.WebhookEventID,
			&i.ProviderAccountID,
			&i.IdempotencyKey,
			&i.ProcessingAttempts,
			&i.SignatureValid,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncEventsByEventType = `-- name: ListSyncEventsByEventType :many
SELECT id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at FROM payment_sync_events 
WHERE session_id = $1 AND event_type = $2
ORDER BY occurred_at DESC
LIMIT $3 OFFSET $4
`

type ListSyncEventsByEventTypeParams struct {
	SessionID uuid.UUID `json:"session_id"`
	EventType string    `json:"event_type"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) ListSyncEventsByEventType(ctx context.Context, arg ListSyncEventsByEventTypeParams) ([]PaymentSyncEvent, error) {
	rows, err := q.db.Query(ctx, listSyncEventsByEventType,
		arg.SessionID,
		arg.EventType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncEvent{}
	for rows.Next() {
		var i PaymentSyncEvent
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.EntityType,
			&i.EntityID,
			&i.ExternalID,
			&i.EventType,
			&i.EventMessage,
			&i.EventDetails,
			&i.WebhookEventID,
			&i.ProviderAccountID,
			&i.IdempotencyKey,
			&i.ProcessingAttempts,
			&i.SignatureValid,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncEventsByProvider = `-- name: ListSyncEventsByProvider :many
SELECT id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at FROM payment_sync_events 
WHERE workspace_id = $1 AND provider_name = $2
ORDER BY occurred_at DESC
LIMIT $3 OFFSET $4
`

type ListSyncEventsByProviderParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

func (q *Queries) ListSyncEventsByProvider(ctx context.Context, arg ListSyncEventsByProviderParams) ([]PaymentSyncEvent, error) {
	rows, err := q.db.Query(ctx, listSyncEventsByProvider,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncEvent{}
	for rows.Next() {
		var i PaymentSyncEvent
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.EntityType,
			&i.EntityID,
			&i.ExternalID,
			&i.EventType,
			&i.EventMessage,
			&i.EventDetails,
			&i.WebhookEventID,
			&i.ProviderAccountID,
			&i.IdempotencyKey,
			&i.ProcessingAttempts,
			&i.SignatureValid,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncEventsBySession = `-- name: ListSyncEventsBySession :many
SELECT id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at FROM payment_sync_events 
WHERE session_id = $1
ORDER BY occurred_at DESC
LIMIT $2 OFFSET $3
`

type ListSyncEventsBySessionParams struct {
	SessionID uuid.UUID `json:"session_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) ListSyncEventsBySession(ctx context.Context, arg ListSyncEventsBySessionParams) ([]PaymentSyncEvent, error) {
	rows, err := q.db.Query(ctx, listSyncEventsBySession, arg.SessionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncEvent{}
	for rows.Next() {
		var i PaymentSyncEvent
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.EntityType,
			&i.EntityID,
			&i.ExternalID,
			&i.EventType,
			&i.EventMessage,
			&i.EventDetails,
			&i.WebhookEventID,
			&i.ProviderAccountID,
			&i.IdempotencyKey,
			&i.ProcessingAttempts,
			&i.SignatureValid,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncSessions = `-- name: ListSyncSessions :many
SELECT id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at FROM payment_sync_sessions 
WHERE workspace_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListSyncSessionsParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListSyncSessions(ctx context.Context, arg ListSyncSessionsParams) ([]PaymentSyncSession, error) {
	rows, err := q.db.Query(ctx, listSyncSessions, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncSession{}
	for rows.Next() {
		var i PaymentSyncSession
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.SessionType,
			&i.Status,
			&i.EntityTypes,
			&i.Config,
			&i.Progress,
			&i.ErrorSummary,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncSessionsByProvider = `-- name: ListSyncSessionsByProvider :many
SELECT id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at FROM payment_sync_sessions 
WHERE workspace_id = $1 AND provider_name = $2 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListSyncSessionsByProviderParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

func (q *Queries) ListSyncSessionsByProvider(ctx context.Context, arg ListSyncSessionsByProviderParams) ([]PaymentSyncSession, error) {
	rows, err := q.db.Query(ctx, listSyncSessionsByProvider,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncSession{}
	for rows.Next() {
		var i PaymentSyncSession
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.SessionType,
			&i.Status,
			&i.EntityTypes,
			&i.Config,
			&i.Progress,
			&i.ErrorSummary,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncSessionsByStatus = `-- name: ListSyncSessionsByStatus :many
SELECT id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at FROM payment_sync_sessions 
WHERE workspace_id = $1 AND status = $2 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListSyncSessionsByStatusParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Status      string    `json:"status"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListSyncSessionsByStatus(ctx context.Context, arg ListSyncSessionsByStatusParams) ([]PaymentSyncSession, error) {
	rows, err := q.db.Query(ctx, listSyncSessionsByStatus,
		arg.WorkspaceID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncSession{}
	for rows.Next() {
		var i PaymentSyncSession
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.SessionType,
			&i.Status,
			&i.EntityTypes,
			&i.Config,
			&i.Progress,
			&i.ErrorSummary,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookEventsByProvider = `-- name: ListWebhookEventsByProvider :many
SELECT id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at FROM payment_sync_events 
WHERE workspace_id = $1 
  AND provider_name = $2
  AND webhook_event_id IS NOT NULL
ORDER BY occurred_at DESC
LIMIT $3 OFFSET $4
`

type ListWebhookEventsByProviderParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

// NEW: List webhook events specifically (those with webhook_event_id)
func (q *Queries) ListWebhookEventsByProvider(ctx context.Context, arg ListWebhookEventsByProviderParams) ([]PaymentSyncEvent, error) {
	rows, err := q.db.Query(ctx, listWebhookEventsByProvider,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncEvent{}
	for rows.Next() {
		var i PaymentSyncEvent
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.EntityType,
			&i.EntityID,
			&i.ExternalID,
			&i.EventType,
			&i.EventMessage,
			&i.EventDetails,
			&i.WebhookEventID,
			&i.ProviderAccountID,
			&i.IdempotencyKey,
			&i.ProcessingAttempts,
			&i.SignatureValid,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomerSyncStatus = `-- name: UpdateCustomerSyncStatus :one
UPDATE customers 
SET payment_sync_status = $2, payment_synced_at = CURRENT_TIMESTAMP, 
    payment_sync_version = payment_sync_version + 1, payment_provider = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
RETURNING id, web3auth_id, external_id, email, name, phone, description, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at
`

type UpdateCustomerSyncStatusParams struct {
	ID                uuid.UUID   `json:"id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
}

func (q *Queries) UpdateCustomerSyncStatus(ctx context.Context, arg UpdateCustomerSyncStatusParams) (Customer, error) {
	row := q.db.QueryRow(ctx, updateCustomerSyncStatus, arg.ID, arg.PaymentSyncStatus, arg.PaymentProvider)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Web3authID,
		&i.ExternalID,
		&i.Email,
		&i.Name,
		&i.Phone,
		&i.Description,
		&i.Metadata,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.PaymentSyncVersion,
		&i.PaymentProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updatePriceSyncStatus = `-- name: UpdatePriceSyncStatus :one
UPDATE prices 
SET payment_sync_status = $2, payment_synced_at = CURRENT_TIMESTAMP, 
    payment_sync_version = payment_sync_version + 1, payment_provider = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
RETURNING id, product_id, external_id, active, type, nickname, currency, unit_amount_in_pennies, interval_type, term_length, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at
`

type UpdatePriceSyncStatusParams struct {
	ID                uuid.UUID   `json:"id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
}

func (q *Queries) UpdatePriceSyncStatus(ctx context.Context, arg UpdatePriceSyncStatusParams) (Price, error) {
	row := q.db.QueryRow(ctx, updatePriceSyncStatus, arg.ID, arg.PaymentSyncStatus, arg.PaymentProvider)
	var i Price
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ExternalID,
		&i.Active,
		&i.Type,
		&i.Nickname,
		&i.Currency,
		&i.UnitAmountInPennies,
		&i.IntervalType,
		&i.TermLength,
		&i.Metadata,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.PaymentSyncVersion,
		&i.PaymentProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateProductSyncStatus = `-- name: UpdateProductSyncStatus :one
UPDATE products 
SET payment_sync_status = $2, payment_synced_at = CURRENT_TIMESTAMP, 
    payment_sync_version = payment_sync_version + 1, payment_provider = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
RETURNING id, workspace_id, wallet_id, external_id, name, description, image_url, url, active, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at
`

type UpdateProductSyncStatusParams struct {
	ID                uuid.UUID   `json:"id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
}

func (q *Queries) UpdateProductSyncStatus(ctx context.Context, arg UpdateProductSyncStatusParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProductSyncStatus, arg.ID, arg.PaymentSyncStatus, arg.PaymentProvider)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.WalletID,
		&i.ExternalID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Url,
		&i.Active,
		&i.Metadata,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.PaymentSyncVersion,
		&i.PaymentProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSubscriptionSyncStatus = `-- name: UpdateSubscriptionSyncStatus :one
UPDATE subscriptions 
SET payment_sync_status = $2, payment_synced_at = CURRENT_TIMESTAMP, 
    payment_sync_version = payment_sync_version + 1, payment_provider = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
RETURNING id, customer_id, product_id, workspace_id, price_id, product_token_id, external_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at
`

type UpdateSubscriptionSyncStatusParams struct {
	ID                uuid.UUID   `json:"id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
}

func (q *Queries) UpdateSubscriptionSyncStatus(ctx context.Context, arg UpdateSubscriptionSyncStatusParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionSyncStatus, arg.ID, arg.PaymentSyncStatus, arg.PaymentProvider)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.WorkspaceID,
		&i.PriceID,
		&i.ProductTokenID,
		&i.ExternalID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.PaymentSyncVersion,
		&i.PaymentProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSyncSessionError = `-- name: UpdateSyncSessionError :one
UPDATE payment_sync_sessions
SET error_summary = $2, status = 'failed', updated_at = CURRENT_TIMESTAMP,
    completed_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at
`

type UpdateSyncSessionErrorParams struct {
	ID           uuid.UUID `json:"id"`
	ErrorSummary []byte    `json:"error_summary"`
}

func (q *Queries) UpdateSyncSessionError(ctx context.Context, arg UpdateSyncSessionErrorParams) (PaymentSyncSession, error) {
	row := q.db.QueryRow(ctx, updateSyncSessionError, arg.ID, arg.ErrorSummary)
	var i PaymentSyncSession
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.SessionType,
		&i.Status,
		&i.EntityTypes,
		&i.Config,
		&i.Progress,
		&i.ErrorSummary,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSyncSessionProgress = `-- name: UpdateSyncSessionProgress :one
UPDATE payment_sync_sessions
SET progress = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at
`

type UpdateSyncSessionProgressParams struct {
	ID       uuid.UUID `json:"id"`
	Progress []byte    `json:"progress"`
}

func (q *Queries) UpdateSyncSessionProgress(ctx context.Context, arg UpdateSyncSessionProgressParams) (PaymentSyncSession, error) {
	row := q.db.QueryRow(ctx, updateSyncSessionProgress, arg.ID, arg.Progress)
	var i PaymentSyncSession
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.SessionType,
		&i.Status,
		&i.EntityTypes,
		&i.Config,
		&i.Progress,
		&i.ErrorSummary,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSyncSessionStatus = `-- name: UpdateSyncSessionStatus :one
UPDATE payment_sync_sessions 
SET status = $2, updated_at = CURRENT_TIMESTAMP,
    started_at = CASE WHEN $2 = 'running' AND started_at IS NULL THEN CURRENT_TIMESTAMP ELSE started_at END,
    completed_at = CASE WHEN $2 IN ('completed', 'failed', 'cancelled') THEN CURRENT_TIMESTAMP ELSE completed_at END
WHERE id = $1 
RETURNING id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at
`

type UpdateSyncSessionStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateSyncSessionStatus(ctx context.Context, arg UpdateSyncSessionStatusParams) (PaymentSyncSession, error) {
	row := q.db.QueryRow(ctx, updateSyncSessionStatus, arg.ID, arg.Status)
	var i PaymentSyncSession
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.SessionType,
		&i.Status,
		&i.EntityTypes,
		&i.Config,
		&i.Progress,
		&i.ErrorSummary,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateWebhookEventProcessingAttempts = `-- name: UpdateWebhookEventProcessingAttempts :one
UPDATE payment_sync_events
SET 
    processing_attempts = processing_attempts + 1,
    event_details = COALESCE(event_details, '{}'::jsonb) || jsonb_build_object(
        'last_attempt_at', EXTRACT(epoch FROM CURRENT_TIMESTAMP),
        'retry_reason', $2
    )
WHERE id = $1
RETURNING id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at
`

type UpdateWebhookEventProcessingAttemptsParams struct {
	ID               uuid.UUID   `json:"id"`
	JsonbBuildObject interface{} `json:"jsonb_build_object"`
}

// NEW: Update processing attempts for retry logic
func (q *Queries) UpdateWebhookEventProcessingAttempts(ctx context.Context, arg UpdateWebhookEventProcessingAttemptsParams) (PaymentSyncEvent, error) {
	row := q.db.QueryRow(ctx, updateWebhookEventProcessingAttempts, arg.ID, arg.JsonbBuildObject)
	var i PaymentSyncEvent
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.EntityType,
		&i.EntityID,
		&i.ExternalID,
		&i.EventType,
		&i.EventMessage,
		&i.EventDetails,
		&i.WebhookEventID,
		&i.ProviderAccountID,
		&i.IdempotencyKey,
		&i.ProcessingAttempts,
		&i.SignatureValid,
		&i.OccurredAt,
	)
	return i, err
}

const updateWorkspaceProviderConfig = `-- name: UpdateWorkspaceProviderConfig :one
UPDATE workspaces
SET 
    metadata = COALESCE(metadata, '{}'::jsonb) || jsonb_build_object('payment_providers', $2),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, account_id, name, description, business_name, business_type, website_url, support_email, support_phone, metadata, livemode, created_at, updated_at, deleted_at
`

type UpdateWorkspaceProviderConfigParams struct {
	ID               uuid.UUID   `json:"id"`
	JsonbBuildObject interface{} `json:"jsonb_build_object"`
}

func (q *Queries) UpdateWorkspaceProviderConfig(ctx context.Context, arg UpdateWorkspaceProviderConfigParams) (Workspace, error) {
	row := q.db.QueryRow(ctx, updateWorkspaceProviderConfig, arg.ID, arg.JsonbBuildObject)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Name,
		&i.Description,
		&i.BusinessName,
		&i.BusinessType,
		&i.WebsiteUrl,
		&i.SupportEmail,
		&i.SupportPhone,
		&i.Metadata,
		&i.Livemode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
