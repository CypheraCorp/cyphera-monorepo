// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: payment_sync.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countSyncEventsByEntityType = `-- name: CountSyncEventsByEntityType :one
SELECT COUNT(*) FROM payment_sync_events 
WHERE session_id = $1 AND entity_type = $2
`

type CountSyncEventsByEntityTypeParams struct {
	SessionID  uuid.UUID `json:"session_id"`
	EntityType string    `json:"entity_type"`
}

func (q *Queries) CountSyncEventsByEntityType(ctx context.Context, arg CountSyncEventsByEntityTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSyncEventsByEntityType, arg.SessionID, arg.EntityType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSyncEventsBySession = `-- name: CountSyncEventsBySession :one
SELECT COUNT(*) FROM payment_sync_events 
WHERE session_id = $1
`

func (q *Queries) CountSyncEventsBySession(ctx context.Context, sessionID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSyncEventsBySession, sessionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSyncEventsBySessionAndType = `-- name: CountSyncEventsBySessionAndType :one
SELECT COUNT(*) FROM payment_sync_events 
WHERE session_id = $1 AND event_type = $2
`

type CountSyncEventsBySessionAndTypeParams struct {
	SessionID uuid.UUID `json:"session_id"`
	EventType string    `json:"event_type"`
}

func (q *Queries) CountSyncEventsBySessionAndType(ctx context.Context, arg CountSyncEventsBySessionAndTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSyncEventsBySessionAndType, arg.SessionID, arg.EventType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSyncSessions = `-- name: CountSyncSessions :one
SELECT COUNT(*) FROM payment_sync_sessions 
WHERE workspace_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountSyncSessions(ctx context.Context, workspaceID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSyncSessions, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSyncSessionsByProvider = `-- name: CountSyncSessionsByProvider :one
SELECT COUNT(*) FROM payment_sync_sessions 
WHERE workspace_id = $1 AND provider_name = $2 AND deleted_at IS NULL
`

type CountSyncSessionsByProviderParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
}

func (q *Queries) CountSyncSessionsByProvider(ctx context.Context, arg CountSyncSessionsByProviderParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSyncSessionsByProvider, arg.WorkspaceID, arg.ProviderName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSyncEvent = `-- name: CreateSyncEvent :one

INSERT INTO payment_sync_events (
    session_id, 
    workspace_id, 
    provider_name, 
    entity_type, 
    entity_id, 
    external_id, 
    event_type, 
    event_message, 
    event_details
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, occurred_at
`

type CreateSyncEventParams struct {
	SessionID    uuid.UUID   `json:"session_id"`
	WorkspaceID  uuid.UUID   `json:"workspace_id"`
	ProviderName string      `json:"provider_name"`
	EntityType   string      `json:"entity_type"`
	EntityID     pgtype.UUID `json:"entity_id"`
	ExternalID   pgtype.Text `json:"external_id"`
	EventType    string      `json:"event_type"`
	EventMessage pgtype.Text `json:"event_message"`
	EventDetails []byte      `json:"event_details"`
}

// Payment Sync Events Queries
func (q *Queries) CreateSyncEvent(ctx context.Context, arg CreateSyncEventParams) (PaymentSyncEvent, error) {
	row := q.db.QueryRow(ctx, createSyncEvent,
		arg.SessionID,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.EntityType,
		arg.EntityID,
		arg.ExternalID,
		arg.EventType,
		arg.EventMessage,
		arg.EventDetails,
	)
	var i PaymentSyncEvent
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.EntityType,
		&i.EntityID,
		&i.ExternalID,
		&i.EventType,
		&i.EventMessage,
		&i.EventDetails,
		&i.OccurredAt,
	)
	return i, err
}

const createSyncSession = `-- name: CreateSyncSession :one

INSERT INTO payment_sync_sessions (
    workspace_id, 
    provider_name, 
    session_type, 
    status, 
    entity_types, 
    config
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at
`

type CreateSyncSessionParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
	SessionType  string    `json:"session_type"`
	Status       string    `json:"status"`
	EntityTypes  []string  `json:"entity_types"`
	Config       []byte    `json:"config"`
}

// Payment Sync Sessions Queries
func (q *Queries) CreateSyncSession(ctx context.Context, arg CreateSyncSessionParams) (PaymentSyncSession, error) {
	row := q.db.QueryRow(ctx, createSyncSession,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.SessionType,
		arg.Status,
		arg.EntityTypes,
		arg.Config,
	)
	var i PaymentSyncSession
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.SessionType,
		&i.Status,
		&i.EntityTypes,
		&i.Config,
		&i.Progress,
		&i.ErrorSummary,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteSyncEventsBySession = `-- name: DeleteSyncEventsBySession :exec
DELETE FROM payment_sync_events
WHERE session_id = $1
`

func (q *Queries) DeleteSyncEventsBySession(ctx context.Context, sessionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSyncEventsBySession, sessionID)
	return err
}

const deleteSyncSession = `-- name: DeleteSyncSession :exec
UPDATE payment_sync_sessions
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
`

type DeleteSyncSessionParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) DeleteSyncSession(ctx context.Context, arg DeleteSyncSessionParams) error {
	_, err := q.db.Exec(ctx, deleteSyncSession, arg.ID, arg.WorkspaceID)
	return err
}

const getActiveSyncSessionsByProvider = `-- name: GetActiveSyncSessionsByProvider :many
SELECT id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at FROM payment_sync_sessions 
WHERE workspace_id = $1 AND provider_name = $2 AND status IN ('pending', 'running') AND deleted_at IS NULL
ORDER BY created_at DESC
`

type GetActiveSyncSessionsByProviderParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
}

func (q *Queries) GetActiveSyncSessionsByProvider(ctx context.Context, arg GetActiveSyncSessionsByProviderParams) ([]PaymentSyncSession, error) {
	rows, err := q.db.Query(ctx, getActiveSyncSessionsByProvider, arg.WorkspaceID, arg.ProviderName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncSession{}
	for rows.Next() {
		var i PaymentSyncSession
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.SessionType,
			&i.Status,
			&i.EntityTypes,
			&i.Config,
			&i.Progress,
			&i.ErrorSummary,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomersByPaymentProvider = `-- name: GetCustomersByPaymentProvider :many

SELECT id, workspace_id, external_id, email, name, phone, description, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at FROM customers 
WHERE workspace_id = $1 AND payment_provider = $2 AND deleted_at IS NULL
`

type GetCustomersByPaymentProviderParams struct {
	WorkspaceID     uuid.UUID   `json:"workspace_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
}

// Payment Sync Status Queries for Entities
func (q *Queries) GetCustomersByPaymentProvider(ctx context.Context, arg GetCustomersByPaymentProviderParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, getCustomersByPaymentProvider, arg.WorkspaceID, arg.PaymentProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ExternalID,
			&i.Email,
			&i.Name,
			&i.Phone,
			&i.Description,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomersByPaymentSyncStatus = `-- name: GetCustomersByPaymentSyncStatus :many
SELECT id, workspace_id, external_id, email, name, phone, description, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at FROM customers 
WHERE workspace_id = $1 AND payment_sync_status = $2 AND deleted_at IS NULL
`

type GetCustomersByPaymentSyncStatusParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
}

func (q *Queries) GetCustomersByPaymentSyncStatus(ctx context.Context, arg GetCustomersByPaymentSyncStatusParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, getCustomersByPaymentSyncStatus, arg.WorkspaceID, arg.PaymentSyncStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ExternalID,
			&i.Email,
			&i.Name,
			&i.Phone,
			&i.Description,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntitiesBySyncStatusAndProvider = `-- name: GetEntitiesBySyncStatusAndProvider :many
SELECT 
    'customer' as entity_type,
    c.id as entity_id,
    c.external_id,
    c.payment_sync_status,
    c.payment_synced_at,
    c.payment_provider
FROM customers c
WHERE c.workspace_id = $1 AND c.payment_provider = $2 AND c.payment_sync_status = $3 AND c.deleted_at IS NULL

UNION ALL

SELECT 
    'product' as entity_type,
    p.id as entity_id,
    NULL as external_id,
    p.payment_sync_status,
    p.payment_synced_at,
    p.payment_provider
FROM products p
WHERE p.workspace_id = $1 AND p.payment_provider = $2 AND p.payment_sync_status = $3 AND p.deleted_at IS NULL

UNION ALL

SELECT 
    'price' as entity_type,
    pr.id as entity_id,
    NULL as external_id,
    pr.payment_sync_status,
    pr.payment_synced_at,
    pr.payment_provider
FROM prices pr
JOIN products prod ON pr.product_id = prod.id
WHERE prod.workspace_id = $1 AND pr.payment_provider = $2 AND pr.payment_sync_status = $3 AND pr.deleted_at IS NULL AND prod.deleted_at IS NULL

UNION ALL

SELECT 
    'subscription' as entity_type,
    s.id as entity_id,
    NULL as external_id,
    s.payment_sync_status,
    s.payment_synced_at,
    s.payment_provider
FROM subscriptions s
WHERE s.workspace_id = $1 AND s.payment_provider = $2 AND s.payment_sync_status = $3 AND s.deleted_at IS NULL

ORDER BY payment_synced_at DESC
`

type GetEntitiesBySyncStatusAndProviderParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
}

type GetEntitiesBySyncStatusAndProviderRow struct {
	EntityType        string             `json:"entity_type"`
	EntityID          uuid.UUID          `json:"entity_id"`
	ExternalID        pgtype.Text        `json:"external_id"`
	PaymentSyncStatus pgtype.Text        `json:"payment_sync_status"`
	PaymentSyncedAt   pgtype.Timestamptz `json:"payment_synced_at"`
	PaymentProvider   pgtype.Text        `json:"payment_provider"`
}

func (q *Queries) GetEntitiesBySyncStatusAndProvider(ctx context.Context, arg GetEntitiesBySyncStatusAndProviderParams) ([]GetEntitiesBySyncStatusAndProviderRow, error) {
	rows, err := q.db.Query(ctx, getEntitiesBySyncStatusAndProvider, arg.WorkspaceID, arg.PaymentProvider, arg.PaymentSyncStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntitiesBySyncStatusAndProviderRow{}
	for rows.Next() {
		var i GetEntitiesBySyncStatusAndProviderRow
		if err := rows.Scan(
			&i.EntityType,
			&i.EntityID,
			&i.ExternalID,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentProvider,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestSyncEventsByEntityType = `-- name: GetLatestSyncEventsByEntityType :many
SELECT DISTINCT ON (entity_type, external_id) 
    id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, occurred_at
FROM payment_sync_events 
WHERE session_id = $1
ORDER BY entity_type, external_id, occurred_at DESC
`

func (q *Queries) GetLatestSyncEventsByEntityType(ctx context.Context, sessionID uuid.UUID) ([]PaymentSyncEvent, error) {
	rows, err := q.db.Query(ctx, getLatestSyncEventsByEntityType, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncEvent{}
	for rows.Next() {
		var i PaymentSyncEvent
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.EntityType,
			&i.EntityID,
			&i.ExternalID,
			&i.EventType,
			&i.EventMessage,
			&i.EventDetails,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestSyncSessionByProvider = `-- name: GetLatestSyncSessionByProvider :one
SELECT id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at FROM payment_sync_sessions 
WHERE workspace_id = $1 AND provider_name = $2 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT 1
`

type GetLatestSyncSessionByProviderParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
}

func (q *Queries) GetLatestSyncSessionByProvider(ctx context.Context, arg GetLatestSyncSessionByProviderParams) (PaymentSyncSession, error) {
	row := q.db.QueryRow(ctx, getLatestSyncSessionByProvider, arg.WorkspaceID, arg.ProviderName)
	var i PaymentSyncSession
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.SessionType,
		&i.Status,
		&i.EntityTypes,
		&i.Config,
		&i.Progress,
		&i.ErrorSummary,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPricesByPaymentProvider = `-- name: GetPricesByPaymentProvider :many
SELECT p.id, p.product_id, p.external_id, p.active, p.type, p.nickname, p.currency, p.unit_amount_in_pennies, p.interval_type, p.term_length, p.metadata, p.payment_sync_status, p.payment_synced_at, p.payment_sync_version, p.payment_provider, p.created_at, p.updated_at, p.deleted_at FROM prices p
JOIN products pr ON p.product_id = pr.id
WHERE pr.workspace_id = $1 AND p.payment_provider = $2 AND p.deleted_at IS NULL AND pr.deleted_at IS NULL
`

type GetPricesByPaymentProviderParams struct {
	WorkspaceID     uuid.UUID   `json:"workspace_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
}

func (q *Queries) GetPricesByPaymentProvider(ctx context.Context, arg GetPricesByPaymentProviderParams) ([]Price, error) {
	rows, err := q.db.Query(ctx, getPricesByPaymentProvider, arg.WorkspaceID, arg.PaymentProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Price{}
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ExternalID,
			&i.Active,
			&i.Type,
			&i.Nickname,
			&i.Currency,
			&i.UnitAmountInPennies,
			&i.IntervalType,
			&i.TermLength,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPricesByPaymentSyncStatus = `-- name: GetPricesByPaymentSyncStatus :many
SELECT p.id, p.product_id, p.external_id, p.active, p.type, p.nickname, p.currency, p.unit_amount_in_pennies, p.interval_type, p.term_length, p.metadata, p.payment_sync_status, p.payment_synced_at, p.payment_sync_version, p.payment_provider, p.created_at, p.updated_at, p.deleted_at FROM prices p
JOIN products pr ON p.product_id = pr.id
WHERE pr.workspace_id = $1 AND p.payment_sync_status = $2 AND p.deleted_at IS NULL AND pr.deleted_at IS NULL
`

type GetPricesByPaymentSyncStatusParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
}

func (q *Queries) GetPricesByPaymentSyncStatus(ctx context.Context, arg GetPricesByPaymentSyncStatusParams) ([]Price, error) {
	rows, err := q.db.Query(ctx, getPricesByPaymentSyncStatus, arg.WorkspaceID, arg.PaymentSyncStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Price{}
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ExternalID,
			&i.Active,
			&i.Type,
			&i.Nickname,
			&i.Currency,
			&i.UnitAmountInPennies,
			&i.IntervalType,
			&i.TermLength,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByPaymentProvider = `-- name: GetProductsByPaymentProvider :many
SELECT id, workspace_id, wallet_id, external_id, name, description, image_url, url, active, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at FROM products 
WHERE workspace_id = $1 AND payment_provider = $2 AND deleted_at IS NULL
`

type GetProductsByPaymentProviderParams struct {
	WorkspaceID     uuid.UUID   `json:"workspace_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
}

func (q *Queries) GetProductsByPaymentProvider(ctx context.Context, arg GetProductsByPaymentProviderParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsByPaymentProvider, arg.WorkspaceID, arg.PaymentProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletID,
			&i.ExternalID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Url,
			&i.Active,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByPaymentSyncStatus = `-- name: GetProductsByPaymentSyncStatus :many
SELECT id, workspace_id, wallet_id, external_id, name, description, image_url, url, active, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at FROM products 
WHERE workspace_id = $1 AND payment_sync_status = $2 AND deleted_at IS NULL
`

type GetProductsByPaymentSyncStatusParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
}

func (q *Queries) GetProductsByPaymentSyncStatus(ctx context.Context, arg GetProductsByPaymentSyncStatusParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsByPaymentSyncStatus, arg.WorkspaceID, arg.PaymentSyncStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletID,
			&i.ExternalID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Url,
			&i.Active,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionsByPaymentProvider = `-- name: GetSubscriptionsByPaymentProvider :many
SELECT id, customer_id, product_id, workspace_id, price_id, product_token_id, external_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at FROM subscriptions 
WHERE workspace_id = $1 AND payment_provider = $2 AND deleted_at IS NULL
`

type GetSubscriptionsByPaymentProviderParams struct {
	WorkspaceID     uuid.UUID   `json:"workspace_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
}

func (q *Queries) GetSubscriptionsByPaymentProvider(ctx context.Context, arg GetSubscriptionsByPaymentProviderParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsByPaymentProvider, arg.WorkspaceID, arg.PaymentProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.WorkspaceID,
			&i.PriceID,
			&i.ProductTokenID,
			&i.ExternalID,
			&i.TokenAmount,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionsByPaymentSyncStatus = `-- name: GetSubscriptionsByPaymentSyncStatus :many
SELECT id, customer_id, product_id, workspace_id, price_id, product_token_id, external_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at FROM subscriptions 
WHERE workspace_id = $1 AND payment_sync_status = $2 AND deleted_at IS NULL
`

type GetSubscriptionsByPaymentSyncStatusParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
}

func (q *Queries) GetSubscriptionsByPaymentSyncStatus(ctx context.Context, arg GetSubscriptionsByPaymentSyncStatusParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsByPaymentSyncStatus, arg.WorkspaceID, arg.PaymentSyncStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.WorkspaceID,
			&i.PriceID,
			&i.ProductTokenID,
			&i.ExternalID,
			&i.TokenAmount,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSyncEvent = `-- name: GetSyncEvent :one
SELECT id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, occurred_at FROM payment_sync_events 
WHERE id = $1
`

func (q *Queries) GetSyncEvent(ctx context.Context, id uuid.UUID) (PaymentSyncEvent, error) {
	row := q.db.QueryRow(ctx, getSyncEvent, id)
	var i PaymentSyncEvent
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.EntityType,
		&i.EntityID,
		&i.ExternalID,
		&i.EventType,
		&i.EventMessage,
		&i.EventDetails,
		&i.OccurredAt,
	)
	return i, err
}

const getSyncEventsByExternalID = `-- name: GetSyncEventsByExternalID :many
SELECT id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, occurred_at FROM payment_sync_events 
WHERE workspace_id = $1 AND provider_name = $2 AND external_id = $3
ORDER BY occurred_at DESC
`

type GetSyncEventsByExternalIDParams struct {
	WorkspaceID  uuid.UUID   `json:"workspace_id"`
	ProviderName string      `json:"provider_name"`
	ExternalID   pgtype.Text `json:"external_id"`
}

func (q *Queries) GetSyncEventsByExternalID(ctx context.Context, arg GetSyncEventsByExternalIDParams) ([]PaymentSyncEvent, error) {
	rows, err := q.db.Query(ctx, getSyncEventsByExternalID, arg.WorkspaceID, arg.ProviderName, arg.ExternalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncEvent{}
	for rows.Next() {
		var i PaymentSyncEvent
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.EntityType,
			&i.EntityID,
			&i.ExternalID,
			&i.EventType,
			&i.EventMessage,
			&i.EventDetails,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSyncEventsSummaryBySession = `-- name: GetSyncEventsSummaryBySession :one
SELECT 
    session_id,
    COUNT(*) as total_events,
    COUNT(CASE WHEN event_type = 'sync_completed' THEN 1 END) as completed_count,
    COUNT(CASE WHEN event_type = 'sync_failed' THEN 1 END) as failed_count,
    COUNT(CASE WHEN event_type = 'sync_skipped' THEN 1 END) as skipped_count
FROM payment_sync_events 
WHERE session_id = $1
GROUP BY session_id
`

type GetSyncEventsSummaryBySessionRow struct {
	SessionID      uuid.UUID `json:"session_id"`
	TotalEvents    int64     `json:"total_events"`
	CompletedCount int64     `json:"completed_count"`
	FailedCount    int64     `json:"failed_count"`
	SkippedCount   int64     `json:"skipped_count"`
}

func (q *Queries) GetSyncEventsSummaryBySession(ctx context.Context, sessionID uuid.UUID) (GetSyncEventsSummaryBySessionRow, error) {
	row := q.db.QueryRow(ctx, getSyncEventsSummaryBySession, sessionID)
	var i GetSyncEventsSummaryBySessionRow
	err := row.Scan(
		&i.SessionID,
		&i.TotalEvents,
		&i.CompletedCount,
		&i.FailedCount,
		&i.SkippedCount,
	)
	return i, err
}

const getSyncSession = `-- name: GetSyncSession :one
SELECT id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at FROM payment_sync_sessions 
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
`

type GetSyncSessionParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) GetSyncSession(ctx context.Context, arg GetSyncSessionParams) (PaymentSyncSession, error) {
	row := q.db.QueryRow(ctx, getSyncSession, arg.ID, arg.WorkspaceID)
	var i PaymentSyncSession
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.SessionType,
		&i.Status,
		&i.EntityTypes,
		&i.Config,
		&i.Progress,
		&i.ErrorSummary,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSyncSessionByProvider = `-- name: GetSyncSessionByProvider :one
SELECT id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at FROM payment_sync_sessions 
WHERE id = $1 AND workspace_id = $2 AND provider_name = $3 AND deleted_at IS NULL
`

type GetSyncSessionByProviderParams struct {
	ID           uuid.UUID `json:"id"`
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
}

func (q *Queries) GetSyncSessionByProvider(ctx context.Context, arg GetSyncSessionByProviderParams) (PaymentSyncSession, error) {
	row := q.db.QueryRow(ctx, getSyncSessionByProvider, arg.ID, arg.WorkspaceID, arg.ProviderName)
	var i PaymentSyncSession
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.SessionType,
		&i.Status,
		&i.EntityTypes,
		&i.Config,
		&i.Progress,
		&i.ErrorSummary,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listSyncEventsByEntityType = `-- name: ListSyncEventsByEntityType :many
SELECT id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, occurred_at FROM payment_sync_events 
WHERE session_id = $1 AND entity_type = $2
ORDER BY occurred_at DESC
LIMIT $3 OFFSET $4
`

type ListSyncEventsByEntityTypeParams struct {
	SessionID  uuid.UUID `json:"session_id"`
	EntityType string    `json:"entity_type"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

func (q *Queries) ListSyncEventsByEntityType(ctx context.Context, arg ListSyncEventsByEntityTypeParams) ([]PaymentSyncEvent, error) {
	rows, err := q.db.Query(ctx, listSyncEventsByEntityType,
		arg.SessionID,
		arg.EntityType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncEvent{}
	for rows.Next() {
		var i PaymentSyncEvent
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.EntityType,
			&i.EntityID,
			&i.ExternalID,
			&i.EventType,
			&i.EventMessage,
			&i.EventDetails,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncEventsByEventType = `-- name: ListSyncEventsByEventType :many
SELECT id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, occurred_at FROM payment_sync_events 
WHERE session_id = $1 AND event_type = $2
ORDER BY occurred_at DESC
LIMIT $3 OFFSET $4
`

type ListSyncEventsByEventTypeParams struct {
	SessionID uuid.UUID `json:"session_id"`
	EventType string    `json:"event_type"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) ListSyncEventsByEventType(ctx context.Context, arg ListSyncEventsByEventTypeParams) ([]PaymentSyncEvent, error) {
	rows, err := q.db.Query(ctx, listSyncEventsByEventType,
		arg.SessionID,
		arg.EventType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncEvent{}
	for rows.Next() {
		var i PaymentSyncEvent
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.EntityType,
			&i.EntityID,
			&i.ExternalID,
			&i.EventType,
			&i.EventMessage,
			&i.EventDetails,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncEventsByProvider = `-- name: ListSyncEventsByProvider :many
SELECT id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, occurred_at FROM payment_sync_events 
WHERE workspace_id = $1 AND provider_name = $2
ORDER BY occurred_at DESC
LIMIT $3 OFFSET $4
`

type ListSyncEventsByProviderParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

func (q *Queries) ListSyncEventsByProvider(ctx context.Context, arg ListSyncEventsByProviderParams) ([]PaymentSyncEvent, error) {
	rows, err := q.db.Query(ctx, listSyncEventsByProvider,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncEvent{}
	for rows.Next() {
		var i PaymentSyncEvent
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.EntityType,
			&i.EntityID,
			&i.ExternalID,
			&i.EventType,
			&i.EventMessage,
			&i.EventDetails,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncEventsBySession = `-- name: ListSyncEventsBySession :many
SELECT id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, occurred_at FROM payment_sync_events 
WHERE session_id = $1
ORDER BY occurred_at DESC
LIMIT $2 OFFSET $3
`

type ListSyncEventsBySessionParams struct {
	SessionID uuid.UUID `json:"session_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) ListSyncEventsBySession(ctx context.Context, arg ListSyncEventsBySessionParams) ([]PaymentSyncEvent, error) {
	rows, err := q.db.Query(ctx, listSyncEventsBySession, arg.SessionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncEvent{}
	for rows.Next() {
		var i PaymentSyncEvent
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.EntityType,
			&i.EntityID,
			&i.ExternalID,
			&i.EventType,
			&i.EventMessage,
			&i.EventDetails,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncSessions = `-- name: ListSyncSessions :many
SELECT id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at FROM payment_sync_sessions 
WHERE workspace_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListSyncSessionsParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListSyncSessions(ctx context.Context, arg ListSyncSessionsParams) ([]PaymentSyncSession, error) {
	rows, err := q.db.Query(ctx, listSyncSessions, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncSession{}
	for rows.Next() {
		var i PaymentSyncSession
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.SessionType,
			&i.Status,
			&i.EntityTypes,
			&i.Config,
			&i.Progress,
			&i.ErrorSummary,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncSessionsByProvider = `-- name: ListSyncSessionsByProvider :many
SELECT id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at FROM payment_sync_sessions 
WHERE workspace_id = $1 AND provider_name = $2 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListSyncSessionsByProviderParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

func (q *Queries) ListSyncSessionsByProvider(ctx context.Context, arg ListSyncSessionsByProviderParams) ([]PaymentSyncSession, error) {
	rows, err := q.db.Query(ctx, listSyncSessionsByProvider,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncSession{}
	for rows.Next() {
		var i PaymentSyncSession
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.SessionType,
			&i.Status,
			&i.EntityTypes,
			&i.Config,
			&i.Progress,
			&i.ErrorSummary,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncSessionsByStatus = `-- name: ListSyncSessionsByStatus :many
SELECT id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at FROM payment_sync_sessions 
WHERE workspace_id = $1 AND status = $2 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListSyncSessionsByStatusParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Status      string    `json:"status"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListSyncSessionsByStatus(ctx context.Context, arg ListSyncSessionsByStatusParams) ([]PaymentSyncSession, error) {
	rows, err := q.db.Query(ctx, listSyncSessionsByStatus,
		arg.WorkspaceID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentSyncSession{}
	for rows.Next() {
		var i PaymentSyncSession
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.SessionType,
			&i.Status,
			&i.EntityTypes,
			&i.Config,
			&i.Progress,
			&i.ErrorSummary,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomerSyncStatus = `-- name: UpdateCustomerSyncStatus :one
UPDATE customers 
SET payment_sync_status = $2, payment_synced_at = CURRENT_TIMESTAMP, 
    payment_sync_version = payment_sync_version + 1, payment_provider = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
RETURNING id, workspace_id, external_id, email, name, phone, description, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at
`

type UpdateCustomerSyncStatusParams struct {
	ID                uuid.UUID   `json:"id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
}

func (q *Queries) UpdateCustomerSyncStatus(ctx context.Context, arg UpdateCustomerSyncStatusParams) (Customer, error) {
	row := q.db.QueryRow(ctx, updateCustomerSyncStatus, arg.ID, arg.PaymentSyncStatus, arg.PaymentProvider)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ExternalID,
		&i.Email,
		&i.Name,
		&i.Phone,
		&i.Description,
		&i.Metadata,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.PaymentSyncVersion,
		&i.PaymentProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updatePriceSyncStatus = `-- name: UpdatePriceSyncStatus :one
UPDATE prices 
SET payment_sync_status = $2, payment_synced_at = CURRENT_TIMESTAMP, 
    payment_sync_version = payment_sync_version + 1, payment_provider = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
RETURNING id, product_id, external_id, active, type, nickname, currency, unit_amount_in_pennies, interval_type, term_length, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at
`

type UpdatePriceSyncStatusParams struct {
	ID                uuid.UUID   `json:"id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
}

func (q *Queries) UpdatePriceSyncStatus(ctx context.Context, arg UpdatePriceSyncStatusParams) (Price, error) {
	row := q.db.QueryRow(ctx, updatePriceSyncStatus, arg.ID, arg.PaymentSyncStatus, arg.PaymentProvider)
	var i Price
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ExternalID,
		&i.Active,
		&i.Type,
		&i.Nickname,
		&i.Currency,
		&i.UnitAmountInPennies,
		&i.IntervalType,
		&i.TermLength,
		&i.Metadata,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.PaymentSyncVersion,
		&i.PaymentProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateProductSyncStatus = `-- name: UpdateProductSyncStatus :one
UPDATE products 
SET payment_sync_status = $2, payment_synced_at = CURRENT_TIMESTAMP, 
    payment_sync_version = payment_sync_version + 1, payment_provider = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
RETURNING id, workspace_id, wallet_id, external_id, name, description, image_url, url, active, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at
`

type UpdateProductSyncStatusParams struct {
	ID                uuid.UUID   `json:"id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
}

func (q *Queries) UpdateProductSyncStatus(ctx context.Context, arg UpdateProductSyncStatusParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProductSyncStatus, arg.ID, arg.PaymentSyncStatus, arg.PaymentProvider)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.WalletID,
		&i.ExternalID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Url,
		&i.Active,
		&i.Metadata,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.PaymentSyncVersion,
		&i.PaymentProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSubscriptionSyncStatus = `-- name: UpdateSubscriptionSyncStatus :one
UPDATE subscriptions 
SET payment_sync_status = $2, payment_synced_at = CURRENT_TIMESTAMP, 
    payment_sync_version = payment_sync_version + 1, payment_provider = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
RETURNING id, customer_id, product_id, workspace_id, price_id, product_token_id, external_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at
`

type UpdateSubscriptionSyncStatusParams struct {
	ID                uuid.UUID   `json:"id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
}

func (q *Queries) UpdateSubscriptionSyncStatus(ctx context.Context, arg UpdateSubscriptionSyncStatusParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionSyncStatus, arg.ID, arg.PaymentSyncStatus, arg.PaymentProvider)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.WorkspaceID,
		&i.PriceID,
		&i.ProductTokenID,
		&i.ExternalID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.PaymentSyncVersion,
		&i.PaymentProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSyncSessionError = `-- name: UpdateSyncSessionError :one
UPDATE payment_sync_sessions
SET error_summary = $2, status = 'failed', updated_at = CURRENT_TIMESTAMP,
    completed_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at
`

type UpdateSyncSessionErrorParams struct {
	ID           uuid.UUID `json:"id"`
	ErrorSummary []byte    `json:"error_summary"`
}

func (q *Queries) UpdateSyncSessionError(ctx context.Context, arg UpdateSyncSessionErrorParams) (PaymentSyncSession, error) {
	row := q.db.QueryRow(ctx, updateSyncSessionError, arg.ID, arg.ErrorSummary)
	var i PaymentSyncSession
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.SessionType,
		&i.Status,
		&i.EntityTypes,
		&i.Config,
		&i.Progress,
		&i.ErrorSummary,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSyncSessionProgress = `-- name: UpdateSyncSessionProgress :one
UPDATE payment_sync_sessions
SET progress = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at
`

type UpdateSyncSessionProgressParams struct {
	ID       uuid.UUID `json:"id"`
	Progress []byte    `json:"progress"`
}

func (q *Queries) UpdateSyncSessionProgress(ctx context.Context, arg UpdateSyncSessionProgressParams) (PaymentSyncSession, error) {
	row := q.db.QueryRow(ctx, updateSyncSessionProgress, arg.ID, arg.Progress)
	var i PaymentSyncSession
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.SessionType,
		&i.Status,
		&i.EntityTypes,
		&i.Config,
		&i.Progress,
		&i.ErrorSummary,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSyncSessionStatus = `-- name: UpdateSyncSessionStatus :one
UPDATE payment_sync_sessions 
SET status = $2, updated_at = CURRENT_TIMESTAMP,
    started_at = CASE WHEN $2 = 'running' AND started_at IS NULL THEN CURRENT_TIMESTAMP ELSE started_at END,
    completed_at = CASE WHEN $2 IN ('completed', 'failed', 'cancelled') THEN CURRENT_TIMESTAMP ELSE completed_at END
WHERE id = $1 
RETURNING id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at
`

type UpdateSyncSessionStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateSyncSessionStatus(ctx context.Context, arg UpdateSyncSessionStatusParams) (PaymentSyncSession, error) {
	row := q.db.QueryRow(ctx, updateSyncSessionStatus, arg.ID, arg.Status)
	var i PaymentSyncSession
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.SessionType,
		&i.Status,
		&i.EntityTypes,
		&i.Config,
		&i.Progress,
		&i.ErrorSummary,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
