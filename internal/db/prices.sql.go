// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: prices.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const activatePrice = `-- name: ActivatePrice :one
UPDATE prices
SET 
    active = true,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, product_id, active, type, nickname, currency, unit_amount_in_pennies, interval_type, term_length, metadata, created_at, updated_at, deleted_at
`

func (q *Queries) ActivatePrice(ctx context.Context, id uuid.UUID) (Price, error) {
	row := q.db.QueryRow(ctx, activatePrice, id)
	var i Price
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Active,
		&i.Type,
		&i.Nickname,
		&i.Currency,
		&i.UnitAmountInPennies,
		&i.IntervalType,
		&i.TermLength,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const countPricesByProduct = `-- name: CountPricesByProduct :one
SELECT COUNT(*) FROM prices
WHERE product_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountPricesByProduct(ctx context.Context, productID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPricesByProduct, productID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPricesByWorkspace = `-- name: CountPricesByWorkspace :one
SELECT COUNT(pr.id)
FROM prices pr
JOIN products p ON pr.product_id = p.id
WHERE p.workspace_id = $1 AND pr.deleted_at IS NULL AND p.deleted_at IS NULL
`

func (q *Queries) CountPricesByWorkspace(ctx context.Context, workspaceID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPricesByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPrice = `-- name: CreatePrice :one
INSERT INTO prices (
    product_id,
    active,
    type, -- price_type enum
    nickname,
    currency, -- currency enum
    unit_amount_in_pennies,
    interval_type, -- interval_type enum (nullable)
    term_length, -- (nullable)
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, product_id, active, type, nickname, currency, unit_amount_in_pennies, interval_type, term_length, metadata, created_at, updated_at, deleted_at
`

type CreatePriceParams struct {
	ProductID           uuid.UUID    `json:"product_id"`
	Active              bool         `json:"active"`
	Type                PriceType    `json:"type"`
	Nickname            pgtype.Text  `json:"nickname"`
	Currency            Currency     `json:"currency"`
	UnitAmountInPennies int32        `json:"unit_amount_in_pennies"`
	IntervalType        IntervalType `json:"interval_type"`
	TermLength          int32        `json:"term_length"`
	Metadata            []byte       `json:"metadata"`
}

func (q *Queries) CreatePrice(ctx context.Context, arg CreatePriceParams) (Price, error) {
	row := q.db.QueryRow(ctx, createPrice,
		arg.ProductID,
		arg.Active,
		arg.Type,
		arg.Nickname,
		arg.Currency,
		arg.UnitAmountInPennies,
		arg.IntervalType,
		arg.TermLength,
		arg.Metadata,
	)
	var i Price
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Active,
		&i.Type,
		&i.Nickname,
		&i.Currency,
		&i.UnitAmountInPennies,
		&i.IntervalType,
		&i.TermLength,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deactivatePrice = `-- name: DeactivatePrice :one
UPDATE prices
SET 
    active = false,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, product_id, active, type, nickname, currency, unit_amount_in_pennies, interval_type, term_length, metadata, created_at, updated_at, deleted_at
`

func (q *Queries) DeactivatePrice(ctx context.Context, id uuid.UUID) (Price, error) {
	row := q.db.QueryRow(ctx, deactivatePrice, id)
	var i Price
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Active,
		&i.Type,
		&i.Nickname,
		&i.Currency,
		&i.UnitAmountInPennies,
		&i.IntervalType,
		&i.TermLength,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deletePrice = `-- name: DeletePrice :exec
UPDATE prices
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeletePrice(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePrice, id)
	return err
}

const getPrice = `-- name: GetPrice :one
SELECT id, product_id, active, type, nickname, currency, unit_amount_in_pennies, interval_type, term_length, metadata, created_at, updated_at, deleted_at FROM prices
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetPrice(ctx context.Context, id uuid.UUID) (Price, error) {
	row := q.db.QueryRow(ctx, getPrice, id)
	var i Price
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Active,
		&i.Type,
		&i.Nickname,
		&i.Currency,
		&i.UnitAmountInPennies,
		&i.IntervalType,
		&i.TermLength,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPriceWithProduct = `-- name: GetPriceWithProduct :one
SELECT pr.id, pr.product_id, pr.active, pr.type, pr.nickname, pr.currency, pr.unit_amount_in_pennies, pr.interval_type, pr.term_length, pr.metadata, pr.created_at, pr.updated_at, pr.deleted_at, p.name as product_name, p.workspace_id
FROM prices pr
JOIN products p ON pr.product_id = p.id
WHERE pr.id = $1 AND pr.deleted_at IS NULL AND p.deleted_at IS NULL
`

type GetPriceWithProductRow struct {
	ID                  uuid.UUID          `json:"id"`
	ProductID           uuid.UUID          `json:"product_id"`
	Active              bool               `json:"active"`
	Type                PriceType          `json:"type"`
	Nickname            pgtype.Text        `json:"nickname"`
	Currency            Currency           `json:"currency"`
	UnitAmountInPennies int32              `json:"unit_amount_in_pennies"`
	IntervalType        IntervalType       `json:"interval_type"`
	TermLength          int32              `json:"term_length"`
	Metadata            []byte             `json:"metadata"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	DeletedAt           pgtype.Timestamptz `json:"deleted_at"`
	ProductName         string             `json:"product_name"`
	WorkspaceID         uuid.UUID          `json:"workspace_id"`
}

func (q *Queries) GetPriceWithProduct(ctx context.Context, id uuid.UUID) (GetPriceWithProductRow, error) {
	row := q.db.QueryRow(ctx, getPriceWithProduct, id)
	var i GetPriceWithProductRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Active,
		&i.Type,
		&i.Nickname,
		&i.Currency,
		&i.UnitAmountInPennies,
		&i.IntervalType,
		&i.TermLength,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProductName,
		&i.WorkspaceID,
	)
	return i, err
}

const listActivePricesByProduct = `-- name: ListActivePricesByProduct :many
SELECT id, product_id, active, type, nickname, currency, unit_amount_in_pennies, interval_type, term_length, metadata, created_at, updated_at, deleted_at FROM prices
WHERE product_id = $1 AND active = true AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListActivePricesByProduct(ctx context.Context, productID uuid.UUID) ([]Price, error) {
	rows, err := q.db.Query(ctx, listActivePricesByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Price{}
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Active,
			&i.Type,
			&i.Nickname,
			&i.Currency,
			&i.UnitAmountInPennies,
			&i.IntervalType,
			&i.TermLength,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivePricesByWorkspace = `-- name: ListActivePricesByWorkspace :many
SELECT pr.id, pr.product_id, pr.active, pr.type, pr.nickname, pr.currency, pr.unit_amount_in_pennies, pr.interval_type, pr.term_length, pr.metadata, pr.created_at, pr.updated_at, pr.deleted_at
FROM prices pr
JOIN products p ON pr.product_id = p.id
WHERE p.workspace_id = $1 AND pr.active = true AND pr.deleted_at IS NULL AND p.deleted_at IS NULL
ORDER BY pr.created_at DESC
`

func (q *Queries) ListActivePricesByWorkspace(ctx context.Context, workspaceID uuid.UUID) ([]Price, error) {
	rows, err := q.db.Query(ctx, listActivePricesByWorkspace, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Price{}
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Active,
			&i.Type,
			&i.Nickname,
			&i.Currency,
			&i.UnitAmountInPennies,
			&i.IntervalType,
			&i.TermLength,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPricesByProduct = `-- name: ListPricesByProduct :many
SELECT id, product_id, active, type, nickname, currency, unit_amount_in_pennies, interval_type, term_length, metadata, created_at, updated_at, deleted_at FROM prices
WHERE product_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListPricesByProduct(ctx context.Context, productID uuid.UUID) ([]Price, error) {
	rows, err := q.db.Query(ctx, listPricesByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Price{}
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Active,
			&i.Type,
			&i.Nickname,
			&i.Currency,
			&i.UnitAmountInPennies,
			&i.IntervalType,
			&i.TermLength,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPricesByWorkspace = `-- name: ListPricesByWorkspace :many
SELECT pr.id, pr.product_id, pr.active, pr.type, pr.nickname, pr.currency, pr.unit_amount_in_pennies, pr.interval_type, pr.term_length, pr.metadata, pr.created_at, pr.updated_at, pr.deleted_at
FROM prices pr
JOIN products p ON pr.product_id = p.id
WHERE p.workspace_id = $1 AND pr.deleted_at IS NULL AND p.deleted_at IS NULL
ORDER BY pr.created_at DESC
`

func (q *Queries) ListPricesByWorkspace(ctx context.Context, workspaceID uuid.UUID) ([]Price, error) {
	rows, err := q.db.Query(ctx, listPricesByWorkspace, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Price{}
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Active,
			&i.Type,
			&i.Nickname,
			&i.Currency,
			&i.UnitAmountInPennies,
			&i.IntervalType,
			&i.TermLength,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePrice = `-- name: UpdatePrice :one
UPDATE prices
SET
    active = COALESCE($2, active),
    nickname = COALESCE($3, nickname),
    metadata = COALESCE($4, metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, product_id, active, type, nickname, currency, unit_amount_in_pennies, interval_type, term_length, metadata, created_at, updated_at, deleted_at
`

type UpdatePriceParams struct {
	ID       uuid.UUID   `json:"id"`
	Active   bool        `json:"active"`
	Nickname pgtype.Text `json:"nickname"`
	Metadata []byte      `json:"metadata"`
}

func (q *Queries) UpdatePrice(ctx context.Context, arg UpdatePriceParams) (Price, error) {
	row := q.db.QueryRow(ctx, updatePrice,
		arg.ID,
		arg.Active,
		arg.Nickname,
		arg.Metadata,
	)
	var i Price
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Active,
		&i.Type,
		&i.Nickname,
		&i.Currency,
		&i.UnitAmountInPennies,
		&i.IntervalType,
		&i.TermLength,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
