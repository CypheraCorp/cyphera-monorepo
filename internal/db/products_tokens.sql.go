// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: products_tokens.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const activateProductToken = `-- name: ActivateProductToken :one
UPDATE products_tokens
SET 
    active = true,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, product_id, network_id, token_id, active, created_at, updated_at, deleted_at
`

func (q *Queries) ActivateProductToken(ctx context.Context, id uuid.UUID) (ProductsToken, error) {
	row := q.db.QueryRow(ctx, activateProductToken, id)
	var i ProductsToken
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.NetworkID,
		&i.TokenID,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createProductToken = `-- name: CreateProductToken :one
INSERT INTO products_tokens (
    product_id,
    network_id,
    token_id,
    active
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, product_id, network_id, token_id, active, created_at, updated_at, deleted_at
`

type CreateProductTokenParams struct {
	ProductID uuid.UUID `json:"product_id"`
	NetworkID uuid.UUID `json:"network_id"`
	TokenID   uuid.UUID `json:"token_id"`
	Active    bool      `json:"active"`
}

func (q *Queries) CreateProductToken(ctx context.Context, arg CreateProductTokenParams) (ProductsToken, error) {
	row := q.db.QueryRow(ctx, createProductToken,
		arg.ProductID,
		arg.NetworkID,
		arg.TokenID,
		arg.Active,
	)
	var i ProductsToken
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.NetworkID,
		&i.TokenID,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deactivateAllProductTokens = `-- name: DeactivateAllProductTokens :exec
UPDATE products_tokens
SET 
    active = false,
    updated_at = CURRENT_TIMESTAMP
WHERE product_id = $1 
    AND deleted_at IS NULL
`

func (q *Queries) DeactivateAllProductTokens(ctx context.Context, productID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateAllProductTokens, productID)
	return err
}

const deactivateAllProductTokensForNetwork = `-- name: DeactivateAllProductTokensForNetwork :exec
UPDATE products_tokens
SET 
    active = false,
    updated_at = CURRENT_TIMESTAMP
WHERE product_id = $1 
    AND network_id = $2 
    AND deleted_at IS NULL
`

type DeactivateAllProductTokensForNetworkParams struct {
	ProductID uuid.UUID `json:"product_id"`
	NetworkID uuid.UUID `json:"network_id"`
}

func (q *Queries) DeactivateAllProductTokensForNetwork(ctx context.Context, arg DeactivateAllProductTokensForNetworkParams) error {
	_, err := q.db.Exec(ctx, deactivateAllProductTokensForNetwork, arg.ProductID, arg.NetworkID)
	return err
}

const deactivateProductToken = `-- name: DeactivateProductToken :one
UPDATE products_tokens
SET 
    active = false,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, product_id, network_id, token_id, active, created_at, updated_at, deleted_at
`

func (q *Queries) DeactivateProductToken(ctx context.Context, id uuid.UUID) (ProductsToken, error) {
	row := q.db.QueryRow(ctx, deactivateProductToken, id)
	var i ProductsToken
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.NetworkID,
		&i.TokenID,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteProductToken = `-- name: DeleteProductToken :exec
UPDATE products_tokens
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteProductToken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductToken, id)
	return err
}

const deleteProductTokenByIds = `-- name: DeleteProductTokenByIds :exec
UPDATE products_tokens
SET deleted_at = CURRENT_TIMESTAMP
WHERE product_id = $1 
    AND network_id = $2 
    AND token_id = $3 
    AND deleted_at IS NULL
`

type DeleteProductTokenByIdsParams struct {
	ProductID uuid.UUID `json:"product_id"`
	NetworkID uuid.UUID `json:"network_id"`
	TokenID   uuid.UUID `json:"token_id"`
}

func (q *Queries) DeleteProductTokenByIds(ctx context.Context, arg DeleteProductTokenByIdsParams) error {
	_, err := q.db.Exec(ctx, deleteProductTokenByIds, arg.ProductID, arg.NetworkID, arg.TokenID)
	return err
}

const deleteProductTokensByProduct = `-- name: DeleteProductTokensByProduct :exec
DELETE FROM products_tokens
WHERE product_id = $1 
    AND deleted_at IS NULL
`

func (q *Queries) DeleteProductTokensByProduct(ctx context.Context, productID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductTokensByProduct, productID)
	return err
}

const getActiveProductTokensByNetwork = `-- name: GetActiveProductTokensByNetwork :many
SELECT 
    pt.id, pt.product_id, pt.network_id, pt.token_id, pt.active, pt.created_at, pt.updated_at, pt.deleted_at,
    t.name as token_name,
    t.symbol as token_symbol,
    t.contract_address,
    t.gas_token
FROM products_tokens pt
JOIN tokens t ON t.id = pt.token_id
WHERE pt.product_id = $1 
    AND pt.network_id = $2
    AND pt.active = true
    AND pt.deleted_at IS NULL
    AND t.active = true
    AND t.deleted_at IS NULL
ORDER BY t.name ASC
`

type GetActiveProductTokensByNetworkParams struct {
	ProductID uuid.UUID `json:"product_id"`
	NetworkID uuid.UUID `json:"network_id"`
}

type GetActiveProductTokensByNetworkRow struct {
	ID              uuid.UUID          `json:"id"`
	ProductID       uuid.UUID          `json:"product_id"`
	NetworkID       uuid.UUID          `json:"network_id"`
	TokenID         uuid.UUID          `json:"token_id"`
	Active          bool               `json:"active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	TokenName       string             `json:"token_name"`
	TokenSymbol     string             `json:"token_symbol"`
	ContractAddress string             `json:"contract_address"`
	GasToken        bool               `json:"gas_token"`
}

func (q *Queries) GetActiveProductTokensByNetwork(ctx context.Context, arg GetActiveProductTokensByNetworkParams) ([]GetActiveProductTokensByNetworkRow, error) {
	rows, err := q.db.Query(ctx, getActiveProductTokensByNetwork, arg.ProductID, arg.NetworkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveProductTokensByNetworkRow{}
	for rows.Next() {
		var i GetActiveProductTokensByNetworkRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.NetworkID,
			&i.TokenID,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TokenName,
			&i.TokenSymbol,
			&i.ContractAddress,
			&i.GasToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveProductTokensByProduct = `-- name: GetActiveProductTokensByProduct :many
SELECT 
    pt.id, pt.product_id, pt.network_id, pt.token_id, pt.active, pt.created_at, pt.updated_at, pt.deleted_at,
    t.name as token_name,
    t.symbol as token_symbol,
    t.contract_address,
    t.gas_token,
    n.chain_id,
    n.name as network_name,
    n.type as network_type
FROM products_tokens pt
JOIN tokens t ON t.id = pt.token_id
JOIN networks n ON n.id = pt.network_id
WHERE pt.product_id = $1 
    AND pt.active = true 
    AND pt.deleted_at IS NULL
    AND t.active = true
    AND t.deleted_at IS NULL
    AND n.active = true
    AND n.deleted_at IS NULL
ORDER BY n.chain_id ASC, t.name ASC
`

type GetActiveProductTokensByProductRow struct {
	ID              uuid.UUID          `json:"id"`
	ProductID       uuid.UUID          `json:"product_id"`
	NetworkID       uuid.UUID          `json:"network_id"`
	TokenID         uuid.UUID          `json:"token_id"`
	Active          bool               `json:"active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	TokenName       string             `json:"token_name"`
	TokenSymbol     string             `json:"token_symbol"`
	ContractAddress string             `json:"contract_address"`
	GasToken        bool               `json:"gas_token"`
	ChainID         int32              `json:"chain_id"`
	NetworkName     string             `json:"network_name"`
	NetworkType     string             `json:"network_type"`
}

func (q *Queries) GetActiveProductTokensByProduct(ctx context.Context, productID uuid.UUID) ([]GetActiveProductTokensByProductRow, error) {
	rows, err := q.db.Query(ctx, getActiveProductTokensByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveProductTokensByProductRow{}
	for rows.Next() {
		var i GetActiveProductTokensByProductRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.NetworkID,
			&i.TokenID,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TokenName,
			&i.TokenSymbol,
			&i.ContractAddress,
			&i.GasToken,
			&i.ChainID,
			&i.NetworkName,
			&i.NetworkType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductNetworks = `-- name: GetProductNetworks :many
SELECT DISTINCT
    n.id, n.name, n.type, n.circle_network_type, n.chain_id, n.active, n.created_at, n.updated_at, n.deleted_at,
    (
        SELECT COUNT(*) 
        FROM products_tokens pt2 
        JOIN tokens t2 ON t2.id = pt2.token_id
        WHERE pt2.product_id = $1 
        AND pt2.network_id = n.id 
        AND pt2.active = true 
        AND pt2.deleted_at IS NULL
        AND t2.active = true
        AND t2.deleted_at IS NULL
    ) as active_tokens_count
FROM networks n
JOIN products_tokens pt ON pt.network_id = n.id
WHERE pt.product_id = $1 
    AND pt.deleted_at IS NULL
    AND n.deleted_at IS NULL
ORDER BY n.chain_id ASC
`

type GetProductNetworksRow struct {
	ID                uuid.UUID          `json:"id"`
	Name              string             `json:"name"`
	Type              string             `json:"type"`
	CircleNetworkType CircleNetworkType  `json:"circle_network_type"`
	ChainID           int32              `json:"chain_id"`
	Active            bool               `json:"active"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	ActiveTokensCount int64              `json:"active_tokens_count"`
}

func (q *Queries) GetProductNetworks(ctx context.Context, productID uuid.UUID) ([]GetProductNetworksRow, error) {
	rows, err := q.db.Query(ctx, getProductNetworks, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductNetworksRow{}
	for rows.Next() {
		var i GetProductNetworksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.CircleNetworkType,
			&i.ChainID,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ActiveTokensCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductToken = `-- name: GetProductToken :one
SELECT 
    pt.id, pt.product_id, pt.network_id, pt.token_id, pt.active, pt.created_at, pt.updated_at, pt.deleted_at,
    t.name as token_name,
    t.symbol as token_symbol,
    t.contract_address,
    t.gas_token,
    n.chain_id,
    n.name as network_name,
    n.type as network_type
FROM products_tokens pt
JOIN tokens t ON t.id = pt.token_id
JOIN networks n ON n.id = pt.network_id
WHERE pt.id = $1 AND pt.deleted_at IS NULL
`

type GetProductTokenRow struct {
	ID              uuid.UUID          `json:"id"`
	ProductID       uuid.UUID          `json:"product_id"`
	NetworkID       uuid.UUID          `json:"network_id"`
	TokenID         uuid.UUID          `json:"token_id"`
	Active          bool               `json:"active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	TokenName       string             `json:"token_name"`
	TokenSymbol     string             `json:"token_symbol"`
	ContractAddress string             `json:"contract_address"`
	GasToken        bool               `json:"gas_token"`
	ChainID         int32              `json:"chain_id"`
	NetworkName     string             `json:"network_name"`
	NetworkType     string             `json:"network_type"`
}

func (q *Queries) GetProductToken(ctx context.Context, id uuid.UUID) (GetProductTokenRow, error) {
	row := q.db.QueryRow(ctx, getProductToken, id)
	var i GetProductTokenRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.NetworkID,
		&i.TokenID,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TokenName,
		&i.TokenSymbol,
		&i.ContractAddress,
		&i.GasToken,
		&i.ChainID,
		&i.NetworkName,
		&i.NetworkType,
	)
	return i, err
}

const getProductTokenByIds = `-- name: GetProductTokenByIds :one
SELECT 
    pt.id, pt.product_id, pt.network_id, pt.token_id, pt.active, pt.created_at, pt.updated_at, pt.deleted_at,
    t.name as token_name,
    t.symbol as token_symbol,
    t.contract_address,
    t.gas_token
FROM products_tokens pt
JOIN tokens t ON t.id = pt.token_id
WHERE pt.product_id = $1 
    AND pt.network_id = $2 
    AND pt.token_id = $3 
    AND pt.deleted_at IS NULL
`

type GetProductTokenByIdsParams struct {
	ProductID uuid.UUID `json:"product_id"`
	NetworkID uuid.UUID `json:"network_id"`
	TokenID   uuid.UUID `json:"token_id"`
}

type GetProductTokenByIdsRow struct {
	ID              uuid.UUID          `json:"id"`
	ProductID       uuid.UUID          `json:"product_id"`
	NetworkID       uuid.UUID          `json:"network_id"`
	TokenID         uuid.UUID          `json:"token_id"`
	Active          bool               `json:"active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	TokenName       string             `json:"token_name"`
	TokenSymbol     string             `json:"token_symbol"`
	ContractAddress string             `json:"contract_address"`
	GasToken        bool               `json:"gas_token"`
}

func (q *Queries) GetProductTokenByIds(ctx context.Context, arg GetProductTokenByIdsParams) (GetProductTokenByIdsRow, error) {
	row := q.db.QueryRow(ctx, getProductTokenByIds, arg.ProductID, arg.NetworkID, arg.TokenID)
	var i GetProductTokenByIdsRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.NetworkID,
		&i.TokenID,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TokenName,
		&i.TokenSymbol,
		&i.ContractAddress,
		&i.GasToken,
	)
	return i, err
}

const getProductTokensByNetwork = `-- name: GetProductTokensByNetwork :many
SELECT 
    pt.id, pt.product_id, pt.network_id, pt.token_id, pt.active, pt.created_at, pt.updated_at, pt.deleted_at,
    t.name as token_name,
    t.symbol as token_symbol,
    t.contract_address,
    t.gas_token
FROM products_tokens pt
JOIN tokens t ON t.id = pt.token_id
WHERE pt.product_id = $1 
    AND pt.network_id = $2
    AND pt.deleted_at IS NULL
    AND t.active = true
    AND t.deleted_at IS NULL
ORDER BY t.name ASC
`

type GetProductTokensByNetworkParams struct {
	ProductID uuid.UUID `json:"product_id"`
	NetworkID uuid.UUID `json:"network_id"`
}

type GetProductTokensByNetworkRow struct {
	ID              uuid.UUID          `json:"id"`
	ProductID       uuid.UUID          `json:"product_id"`
	NetworkID       uuid.UUID          `json:"network_id"`
	TokenID         uuid.UUID          `json:"token_id"`
	Active          bool               `json:"active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	TokenName       string             `json:"token_name"`
	TokenSymbol     string             `json:"token_symbol"`
	ContractAddress string             `json:"contract_address"`
	GasToken        bool               `json:"gas_token"`
}

func (q *Queries) GetProductTokensByNetwork(ctx context.Context, arg GetProductTokensByNetworkParams) ([]GetProductTokensByNetworkRow, error) {
	rows, err := q.db.Query(ctx, getProductTokensByNetwork, arg.ProductID, arg.NetworkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductTokensByNetworkRow{}
	for rows.Next() {
		var i GetProductTokensByNetworkRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.NetworkID,
			&i.TokenID,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TokenName,
			&i.TokenSymbol,
			&i.ContractAddress,
			&i.GasToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductTokensByProduct = `-- name: GetProductTokensByProduct :many
SELECT 
    pt.id, pt.product_id, pt.network_id, pt.token_id, pt.active, pt.created_at, pt.updated_at, pt.deleted_at,
    t.name as token_name,
    t.symbol as token_symbol,
    t.contract_address,
    t.gas_token,
    n.chain_id,
    n.name as network_name,
    n.type as network_type
FROM products_tokens pt
JOIN tokens t ON t.id = pt.token_id
JOIN networks n ON n.id = pt.network_id
WHERE pt.product_id = $1 
    AND pt.deleted_at IS NULL
ORDER BY n.chain_id ASC, t.name ASC
`

type GetProductTokensByProductRow struct {
	ID              uuid.UUID          `json:"id"`
	ProductID       uuid.UUID          `json:"product_id"`
	NetworkID       uuid.UUID          `json:"network_id"`
	TokenID         uuid.UUID          `json:"token_id"`
	Active          bool               `json:"active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	TokenName       string             `json:"token_name"`
	TokenSymbol     string             `json:"token_symbol"`
	ContractAddress string             `json:"contract_address"`
	GasToken        bool               `json:"gas_token"`
	ChainID         int32              `json:"chain_id"`
	NetworkName     string             `json:"network_name"`
	NetworkType     string             `json:"network_type"`
}

func (q *Queries) GetProductTokensByProduct(ctx context.Context, productID uuid.UUID) ([]GetProductTokensByProductRow, error) {
	rows, err := q.db.Query(ctx, getProductTokensByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductTokensByProductRow{}
	for rows.Next() {
		var i GetProductTokensByProductRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.NetworkID,
			&i.TokenID,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TokenName,
			&i.TokenSymbol,
			&i.ContractAddress,
			&i.GasToken,
			&i.ChainID,
			&i.NetworkName,
			&i.NetworkType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductToken = `-- name: UpdateProductToken :one
UPDATE products_tokens
SET
    active = COALESCE($4, active),
    updated_at = CURRENT_TIMESTAMP
WHERE product_id = $1 
    AND network_id = $2 
    AND token_id = $3 
    AND deleted_at IS NULL
RETURNING id, product_id, network_id, token_id, active, created_at, updated_at, deleted_at
`

type UpdateProductTokenParams struct {
	ProductID uuid.UUID `json:"product_id"`
	NetworkID uuid.UUID `json:"network_id"`
	TokenID   uuid.UUID `json:"token_id"`
	Active    bool      `json:"active"`
}

func (q *Queries) UpdateProductToken(ctx context.Context, arg UpdateProductTokenParams) (ProductsToken, error) {
	row := q.db.QueryRow(ctx, updateProductToken,
		arg.ProductID,
		arg.NetworkID,
		arg.TokenID,
		arg.Active,
	)
	var i ProductsToken
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.NetworkID,
		&i.TokenID,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
