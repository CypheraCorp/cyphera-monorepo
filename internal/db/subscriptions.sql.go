// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: subscriptions.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelSubscription = `-- name: CancelSubscription :one
UPDATE subscriptions
SET 
    status = 'canceled',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, customer_id, product_id, product_token_id, token_amount, product_price_in_pennies, currency, interval_type, term_length, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_term_length, total_amount_in_cents, metadata, created_at, updated_at, deleted_at
`

func (q *Queries) CancelSubscription(ctx context.Context, id uuid.UUID) (Subscription, error) {
	row := q.db.QueryRow(ctx, cancelSubscription, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.ProductPriceInPennies,
		&i.Currency,
		&i.IntervalType,
		&i.TermLength,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalTermLength,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const completeSubscription = `-- name: CompleteSubscription :one
UPDATE subscriptions
SET 
    status = 'completed',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, customer_id, product_id, product_token_id, token_amount, product_price_in_pennies, currency, interval_type, term_length, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_term_length, total_amount_in_cents, metadata, created_at, updated_at, deleted_at
`

func (q *Queries) CompleteSubscription(ctx context.Context, id uuid.UUID) (Subscription, error) {
	row := q.db.QueryRow(ctx, completeSubscription, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.ProductPriceInPennies,
		&i.Currency,
		&i.IntervalType,
		&i.TermLength,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalTermLength,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const countActiveSubscriptions = `-- name: CountActiveSubscriptions :one
SELECT COUNT(*) FROM subscriptions
WHERE (status = 'active' OR status = 'overdue') AND deleted_at IS NULL
`

func (q *Queries) CountActiveSubscriptions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveSubscriptions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSubscriptions = `-- name: CountSubscriptions :one
SELECT COUNT(*) FROM subscriptions
WHERE deleted_at IS NULL
`

func (q *Queries) CountSubscriptions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSubscriptions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSubscriptionsByStatus = `-- name: CountSubscriptionsByStatus :one
SELECT COUNT(*) FROM subscriptions
WHERE status = $1 AND deleted_at IS NULL
`

func (q *Queries) CountSubscriptionsByStatus(ctx context.Context, status SubscriptionStatus) (int64, error) {
	row := q.db.QueryRow(ctx, countSubscriptionsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (
    customer_id,
    product_id,
    product_token_id,
    token_amount,
    product_price_in_pennies,
    currency,
    interval_type,
    term_length,
    delegation_id,
    customer_wallet_id,
    status,
    current_period_start,
    current_period_end,
    next_redemption_date,
    total_redemptions,
    total_term_length,
    total_amount_in_cents,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
)
RETURNING id, customer_id, product_id, product_token_id, token_amount, product_price_in_pennies, currency, interval_type, term_length, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_term_length, total_amount_in_cents, metadata, created_at, updated_at, deleted_at
`

type CreateSubscriptionParams struct {
	CustomerID            uuid.UUID          `json:"customer_id"`
	ProductID             uuid.UUID          `json:"product_id"`
	ProductTokenID        uuid.UUID          `json:"product_token_id"`
	TokenAmount           pgtype.Numeric     `json:"token_amount"`
	ProductPriceInPennies pgtype.Numeric     `json:"product_price_in_pennies"`
	Currency              Currency           `json:"currency"`
	IntervalType          IntervalType       `json:"interval_type"`
	TermLength            int32              `json:"term_length"`
	DelegationID          uuid.UUID          `json:"delegation_id"`
	CustomerWalletID      pgtype.UUID        `json:"customer_wallet_id"`
	Status                SubscriptionStatus `json:"status"`
	CurrentPeriodStart    pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd      pgtype.Timestamptz `json:"current_period_end"`
	NextRedemptionDate    pgtype.Timestamptz `json:"next_redemption_date"`
	TotalRedemptions      int32              `json:"total_redemptions"`
	TotalTermLength       int32              `json:"total_term_length"`
	TotalAmountInCents    int32              `json:"total_amount_in_cents"`
	Metadata              []byte             `json:"metadata"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.CustomerID,
		arg.ProductID,
		arg.ProductTokenID,
		arg.TokenAmount,
		arg.ProductPriceInPennies,
		arg.Currency,
		arg.IntervalType,
		arg.TermLength,
		arg.DelegationID,
		arg.CustomerWalletID,
		arg.Status,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.NextRedemptionDate,
		arg.TotalRedemptions,
		arg.TotalTermLength,
		arg.TotalAmountInCents,
		arg.Metadata,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.ProductPriceInPennies,
		&i.Currency,
		&i.IntervalType,
		&i.TermLength,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalTermLength,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteSubscription = `-- name: DeleteSubscription :exec
UPDATE subscriptions
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteSubscription(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSubscription, id)
	return err
}

const getOverdueSubscriptions = `-- name: GetOverdueSubscriptions :many
SELECT id, customer_id, product_id, product_token_id, token_amount, product_price_in_pennies, currency, interval_type, term_length, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_term_length, total_amount_in_cents, metadata, created_at, updated_at, deleted_at FROM subscriptions
WHERE 
    (current_period_end < CURRENT_TIMESTAMP OR status = 'overdue')
    AND deleted_at IS NULL
ORDER BY current_period_end ASC
`

func (q *Queries) GetOverdueSubscriptions(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getOverdueSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.ProductTokenID,
			&i.TokenAmount,
			&i.ProductPriceInPennies,
			&i.Currency,
			&i.IntervalType,
			&i.TermLength,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalTermLength,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscription = `-- name: GetSubscription :one
SELECT id, customer_id, product_id, product_token_id, token_amount, product_price_in_pennies, currency, interval_type, term_length, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_term_length, total_amount_in_cents, metadata, created_at, updated_at, deleted_at FROM subscriptions
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetSubscription(ctx context.Context, id uuid.UUID) (Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscription, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.ProductPriceInPennies,
		&i.Currency,
		&i.IntervalType,
		&i.TermLength,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalTermLength,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSubscriptionWithDetails = `-- name: GetSubscriptionWithDetails :one
SELECT 
    s.id, s.customer_id, s.product_id, s.product_token_id, s.token_amount, s.product_price_in_pennies, s.currency, s.interval_type, s.term_length, s.delegation_id, s.customer_wallet_id, s.status, s.current_period_start, s.current_period_end, s.next_redemption_date, s.total_redemptions, s.total_term_length, s.total_amount_in_cents, s.metadata, s.created_at, s.updated_at, s.deleted_at,
    p.name as product_name,
    p.product_type,
    p.interval_type,
    c.name as customer_name,
    c.email as customer_email,
    cw.wallet_address as subscriber_wallet_address,
    cw.network_type as subscriber_network_type,
    t.symbol as token_symbol,
    n.name as network_name,
    n.chain_id
FROM subscriptions s
JOIN products p ON p.id = s.product_id
JOIN customers c ON c.id = s.customer_id
LEFT JOIN customer_wallets cw ON cw.id = s.customer_wallet_id
JOIN products_tokens pt ON pt.id = s.product_token_id
JOIN tokens t ON t.id = pt.token_id
JOIN networks n ON n.id = pt.network_id
WHERE s.id = $1 AND s.deleted_at IS NULL
`

type GetSubscriptionWithDetailsRow struct {
	ID                      uuid.UUID          `json:"id"`
	CustomerID              uuid.UUID          `json:"customer_id"`
	ProductID               uuid.UUID          `json:"product_id"`
	ProductTokenID          uuid.UUID          `json:"product_token_id"`
	TokenAmount             pgtype.Numeric     `json:"token_amount"`
	ProductPriceInPennies   pgtype.Numeric     `json:"product_price_in_pennies"`
	Currency                Currency           `json:"currency"`
	IntervalType            IntervalType       `json:"interval_type"`
	TermLength              int32              `json:"term_length"`
	DelegationID            uuid.UUID          `json:"delegation_id"`
	CustomerWalletID        pgtype.UUID        `json:"customer_wallet_id"`
	Status                  SubscriptionStatus `json:"status"`
	CurrentPeriodStart      pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd        pgtype.Timestamptz `json:"current_period_end"`
	NextRedemptionDate      pgtype.Timestamptz `json:"next_redemption_date"`
	TotalRedemptions        int32              `json:"total_redemptions"`
	TotalTermLength         int32              `json:"total_term_length"`
	TotalAmountInCents      int32              `json:"total_amount_in_cents"`
	Metadata                []byte             `json:"metadata"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
	DeletedAt               pgtype.Timestamptz `json:"deleted_at"`
	ProductName             string             `json:"product_name"`
	ProductType             ProductType        `json:"product_type"`
	IntervalType_2          NullIntervalType   `json:"interval_type_2"`
	CustomerName            pgtype.Text        `json:"customer_name"`
	CustomerEmail           pgtype.Text        `json:"customer_email"`
	SubscriberWalletAddress pgtype.Text        `json:"subscriber_wallet_address"`
	SubscriberNetworkType   NullNetworkType    `json:"subscriber_network_type"`
	TokenSymbol             string             `json:"token_symbol"`
	NetworkName             string             `json:"network_name"`
	ChainID                 int32              `json:"chain_id"`
}

func (q *Queries) GetSubscriptionWithDetails(ctx context.Context, id uuid.UUID) (GetSubscriptionWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionWithDetails, id)
	var i GetSubscriptionWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.ProductPriceInPennies,
		&i.Currency,
		&i.IntervalType,
		&i.TermLength,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalTermLength,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProductName,
		&i.ProductType,
		&i.IntervalType_2,
		&i.CustomerName,
		&i.CustomerEmail,
		&i.SubscriberWalletAddress,
		&i.SubscriberNetworkType,
		&i.TokenSymbol,
		&i.NetworkName,
		&i.ChainID,
	)
	return i, err
}

const getSubscriptionsByDelegation = `-- name: GetSubscriptionsByDelegation :many
SELECT id, customer_id, product_id, product_token_id, token_amount, product_price_in_pennies, currency, interval_type, term_length, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_term_length, total_amount_in_cents, metadata, created_at, updated_at, deleted_at FROM subscriptions
WHERE delegation_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetSubscriptionsByDelegation(ctx context.Context, delegationID uuid.UUID) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsByDelegation, delegationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.ProductTokenID,
			&i.TokenAmount,
			&i.ProductPriceInPennies,
			&i.Currency,
			&i.IntervalType,
			&i.TermLength,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalTermLength,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementSubscriptionRedemption = `-- name: IncrementSubscriptionRedemption :one
UPDATE subscriptions
SET 
    total_redemptions = total_redemptions + 1,
    total_amount_in_cents = total_amount_in_cents + $2,
    next_redemption_date = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, customer_id, product_id, product_token_id, token_amount, product_price_in_pennies, currency, interval_type, term_length, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_term_length, total_amount_in_cents, metadata, created_at, updated_at, deleted_at
`

type IncrementSubscriptionRedemptionParams struct {
	ID                 uuid.UUID          `json:"id"`
	TotalAmountInCents int32              `json:"total_amount_in_cents"`
	NextRedemptionDate pgtype.Timestamptz `json:"next_redemption_date"`
}

func (q *Queries) IncrementSubscriptionRedemption(ctx context.Context, arg IncrementSubscriptionRedemptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, incrementSubscriptionRedemption, arg.ID, arg.TotalAmountInCents, arg.NextRedemptionDate)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.ProductPriceInPennies,
		&i.Currency,
		&i.IntervalType,
		&i.TermLength,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalTermLength,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listActiveSubscriptions = `-- name: ListActiveSubscriptions :many
SELECT id, customer_id, product_id, product_token_id, token_amount, product_price_in_pennies, currency, interval_type, term_length, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_term_length, total_amount_in_cents, metadata, created_at, updated_at, deleted_at FROM subscriptions
WHERE (status = 'active' OR status = 'overdue') AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListActiveSubscriptions(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listActiveSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.ProductTokenID,
			&i.TokenAmount,
			&i.ProductPriceInPennies,
			&i.Currency,
			&i.IntervalType,
			&i.TermLength,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalTermLength,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionDetailsWithPagination = `-- name: ListSubscriptionDetailsWithPagination :many
SELECT 
    s.id,
    s.status,
    s.current_period_start,
    s.current_period_end,
    s.next_redemption_date,
    s.total_redemptions,
    s.total_term_length,
    s.total_amount_in_cents,
    s.token_amount,
    s.product_price_in_pennies,
    s.interval_type,
    s.term_length,
    s.currency,
    -- Customer details
    c.id as customer_id,
    c.name as customer_name,
    c.email as customer_email,
    -- Product details
    p.id as product_id,
    p.name as product_name,
    p.product_type,
    p.interval_type,
    p.price_in_pennies,
    -- Token details
    t.symbol as token_symbol,
    t.contract_address as token_address,
    -- Network details
    n.name as network_name,
    n.type as network_type,
    n.chain_id,
    -- Customer wallet details
    cw.wallet_address as customer_wallet_address
FROM subscriptions s
JOIN customers c ON s.customer_id = c.id
JOIN products p ON s.product_id = p.id
JOIN products_tokens pt ON s.product_token_id = pt.id
JOIN tokens t ON pt.token_id = t.id
JOIN networks n ON pt.network_id = n.id
LEFT JOIN customer_wallets cw ON s.customer_wallet_id = cw.id
WHERE s.deleted_at IS NULL
    AND c.deleted_at IS NULL
    AND p.deleted_at IS NULL
    AND pt.deleted_at IS NULL
    AND t.deleted_at IS NULL
    AND n.deleted_at IS NULL
    AND cw.deleted_at IS NULL
    AND p.workspace_id = $3
ORDER BY s.created_at DESC
LIMIT $1 OFFSET $2
`

type ListSubscriptionDetailsWithPaginationParams struct {
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

type ListSubscriptionDetailsWithPaginationRow struct {
	ID                    uuid.UUID          `json:"id"`
	Status                SubscriptionStatus `json:"status"`
	CurrentPeriodStart    pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd      pgtype.Timestamptz `json:"current_period_end"`
	NextRedemptionDate    pgtype.Timestamptz `json:"next_redemption_date"`
	TotalRedemptions      int32              `json:"total_redemptions"`
	TotalTermLength       int32              `json:"total_term_length"`
	TotalAmountInCents    int32              `json:"total_amount_in_cents"`
	TokenAmount           pgtype.Numeric     `json:"token_amount"`
	ProductPriceInPennies pgtype.Numeric     `json:"product_price_in_pennies"`
	IntervalType          IntervalType       `json:"interval_type"`
	TermLength            int32              `json:"term_length"`
	Currency              Currency           `json:"currency"`
	CustomerID            uuid.UUID          `json:"customer_id"`
	CustomerName          pgtype.Text        `json:"customer_name"`
	CustomerEmail         pgtype.Text        `json:"customer_email"`
	ProductID             uuid.UUID          `json:"product_id"`
	ProductName           string             `json:"product_name"`
	ProductType           ProductType        `json:"product_type"`
	IntervalType_2        NullIntervalType   `json:"interval_type_2"`
	PriceInPennies        int32              `json:"price_in_pennies"`
	TokenSymbol           string             `json:"token_symbol"`
	TokenAddress          string             `json:"token_address"`
	NetworkName           string             `json:"network_name"`
	NetworkType           string             `json:"network_type"`
	ChainID               int32              `json:"chain_id"`
	CustomerWalletAddress pgtype.Text        `json:"customer_wallet_address"`
}

func (q *Queries) ListSubscriptionDetailsWithPagination(ctx context.Context, arg ListSubscriptionDetailsWithPaginationParams) ([]ListSubscriptionDetailsWithPaginationRow, error) {
	rows, err := q.db.Query(ctx, listSubscriptionDetailsWithPagination, arg.Limit, arg.Offset, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionDetailsWithPaginationRow{}
	for rows.Next() {
		var i ListSubscriptionDetailsWithPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalTermLength,
			&i.TotalAmountInCents,
			&i.TokenAmount,
			&i.ProductPriceInPennies,
			&i.IntervalType,
			&i.TermLength,
			&i.Currency,
			&i.CustomerID,
			&i.CustomerName,
			&i.CustomerEmail,
			&i.ProductID,
			&i.ProductName,
			&i.ProductType,
			&i.IntervalType_2,
			&i.PriceInPennies,
			&i.TokenSymbol,
			&i.TokenAddress,
			&i.NetworkName,
			&i.NetworkType,
			&i.ChainID,
			&i.CustomerWalletAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptions = `-- name: ListSubscriptions :many
SELECT id, customer_id, product_id, product_token_id, token_amount, product_price_in_pennies, currency, interval_type, term_length, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_term_length, total_amount_in_cents, metadata, created_at, updated_at, deleted_at FROM subscriptions
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListSubscriptions(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.ProductTokenID,
			&i.TokenAmount,
			&i.ProductPriceInPennies,
			&i.Currency,
			&i.IntervalType,
			&i.TermLength,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalTermLength,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsByCustomer = `-- name: ListSubscriptionsByCustomer :many
SELECT id, customer_id, product_id, product_token_id, token_amount, product_price_in_pennies, currency, interval_type, term_length, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_term_length, total_amount_in_cents, metadata, created_at, updated_at, deleted_at FROM subscriptions
WHERE customer_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListSubscriptionsByCustomer(ctx context.Context, customerID uuid.UUID) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.ProductTokenID,
			&i.TokenAmount,
			&i.ProductPriceInPennies,
			&i.Currency,
			&i.IntervalType,
			&i.TermLength,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalTermLength,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsByProduct = `-- name: ListSubscriptionsByProduct :many
SELECT s.id, s.customer_id, s.product_id, s.product_token_id, s.token_amount, s.product_price_in_pennies, s.currency, s.interval_type, s.term_length, s.delegation_id, s.customer_wallet_id, s.status, s.current_period_start, s.current_period_end, s.next_redemption_date, s.total_redemptions, s.total_term_length, s.total_amount_in_cents, s.metadata, s.created_at, s.updated_at, s.deleted_at FROM subscriptions s
JOIN products p ON s.product_id = p.id
WHERE s.product_id = $1 AND p.workspace_id = $2 AND s.deleted_at IS NULL
ORDER BY s.created_at DESC
`

type ListSubscriptionsByProductParams struct {
	ProductID   uuid.UUID `json:"product_id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) ListSubscriptionsByProduct(ctx context.Context, arg ListSubscriptionsByProductParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsByProduct, arg.ProductID, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.ProductTokenID,
			&i.TokenAmount,
			&i.ProductPriceInPennies,
			&i.Currency,
			&i.IntervalType,
			&i.TermLength,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalTermLength,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsDueForRedemption = `-- name: ListSubscriptionsDueForRedemption :many
SELECT id, customer_id, product_id, product_token_id, token_amount, product_price_in_pennies, currency, interval_type, term_length, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_term_length, total_amount_in_cents, metadata, created_at, updated_at, deleted_at FROM subscriptions
WHERE 
    (status = 'active' OR status = 'overdue')
    AND next_redemption_date <= $1
    AND deleted_at IS NULL
ORDER BY next_redemption_date ASC
`

func (q *Queries) ListSubscriptionsDueForRedemption(ctx context.Context, nextRedemptionDate pgtype.Timestamptz) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsDueForRedemption, nextRedemptionDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.ProductTokenID,
			&i.TokenAmount,
			&i.ProductPriceInPennies,
			&i.Currency,
			&i.IntervalType,
			&i.TermLength,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalTermLength,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsWithPagination = `-- name: ListSubscriptionsWithPagination :many
SELECT id, customer_id, product_id, product_token_id, token_amount, product_price_in_pennies, currency, interval_type, term_length, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_term_length, total_amount_in_cents, metadata, created_at, updated_at, deleted_at FROM subscriptions
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListSubscriptionsWithPaginationParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSubscriptionsWithPagination(ctx context.Context, arg ListSubscriptionsWithPaginationParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsWithPagination, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.ProductTokenID,
			&i.TokenAmount,
			&i.ProductPriceInPennies,
			&i.Currency,
			&i.IntervalType,
			&i.TermLength,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalTermLength,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockSubscriptionForProcessing = `-- name: LockSubscriptionForProcessing :one
SELECT id, customer_id, product_id, product_token_id, token_amount, product_price_in_pennies, currency, interval_type, term_length, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_term_length, total_amount_in_cents, metadata, created_at, updated_at, deleted_at
FROM subscriptions
WHERE id = $1 AND (status = 'active' OR status = 'overdue') AND deleted_at IS NULL
FOR UPDATE NOWAIT
LIMIT 1
`

func (q *Queries) LockSubscriptionForProcessing(ctx context.Context, id uuid.UUID) (Subscription, error) {
	row := q.db.QueryRow(ctx, lockSubscriptionForProcessing, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.ProductPriceInPennies,
		&i.Currency,
		&i.IntervalType,
		&i.TermLength,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalTermLength,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSubscription = `-- name: UpdateSubscription :one
UPDATE subscriptions
SET
    customer_id = COALESCE($2, customer_id),
    product_id = COALESCE($3, product_id),
    product_token_id = COALESCE($4, product_token_id),
    token_amount = COALESCE($5, token_amount),
    product_price_in_pennies = COALESCE($6, product_price_in_pennies),
    currency = COALESCE($7, currency),
    interval_type = COALESCE($8, interval_type),
    term_length = COALESCE($9, term_length),
    delegation_id = COALESCE($10, delegation_id),
    customer_wallet_id = COALESCE($11, customer_wallet_id),
    status = COALESCE($12, status),
    current_period_start = COALESCE($13, current_period_start),
    current_period_end = COALESCE($14, current_period_end),
    next_redemption_date = COALESCE($15, next_redemption_date),
    total_redemptions = COALESCE($16, total_redemptions),
    total_term_length = COALESCE($17, total_term_length),
    total_amount_in_cents = COALESCE($18, total_amount_in_cents),
    metadata = COALESCE($19, metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, customer_id, product_id, product_token_id, token_amount, product_price_in_pennies, currency, interval_type, term_length, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_term_length, total_amount_in_cents, metadata, created_at, updated_at, deleted_at
`

type UpdateSubscriptionParams struct {
	ID                    uuid.UUID          `json:"id"`
	CustomerID            uuid.UUID          `json:"customer_id"`
	ProductID             uuid.UUID          `json:"product_id"`
	ProductTokenID        uuid.UUID          `json:"product_token_id"`
	TokenAmount           pgtype.Numeric     `json:"token_amount"`
	ProductPriceInPennies pgtype.Numeric     `json:"product_price_in_pennies"`
	Currency              Currency           `json:"currency"`
	IntervalType          IntervalType       `json:"interval_type"`
	TermLength            int32              `json:"term_length"`
	DelegationID          uuid.UUID          `json:"delegation_id"`
	CustomerWalletID      pgtype.UUID        `json:"customer_wallet_id"`
	Status                SubscriptionStatus `json:"status"`
	CurrentPeriodStart    pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd      pgtype.Timestamptz `json:"current_period_end"`
	NextRedemptionDate    pgtype.Timestamptz `json:"next_redemption_date"`
	TotalRedemptions      int32              `json:"total_redemptions"`
	TotalTermLength       int32              `json:"total_term_length"`
	TotalAmountInCents    int32              `json:"total_amount_in_cents"`
	Metadata              []byte             `json:"metadata"`
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscription,
		arg.ID,
		arg.CustomerID,
		arg.ProductID,
		arg.ProductTokenID,
		arg.TokenAmount,
		arg.ProductPriceInPennies,
		arg.Currency,
		arg.IntervalType,
		arg.TermLength,
		arg.DelegationID,
		arg.CustomerWalletID,
		arg.Status,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.NextRedemptionDate,
		arg.TotalRedemptions,
		arg.TotalTermLength,
		arg.TotalAmountInCents,
		arg.Metadata,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.ProductPriceInPennies,
		&i.Currency,
		&i.IntervalType,
		&i.TermLength,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalTermLength,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSubscriptionStatus = `-- name: UpdateSubscriptionStatus :one
UPDATE subscriptions
SET 
    status = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, customer_id, product_id, product_token_id, token_amount, product_price_in_pennies, currency, interval_type, term_length, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_term_length, total_amount_in_cents, metadata, created_at, updated_at, deleted_at
`

type UpdateSubscriptionStatusParams struct {
	ID     uuid.UUID          `json:"id"`
	Status SubscriptionStatus `json:"status"`
}

func (q *Queries) UpdateSubscriptionStatus(ctx context.Context, arg UpdateSubscriptionStatusParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionStatus, arg.ID, arg.Status)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.ProductPriceInPennies,
		&i.Currency,
		&i.IntervalType,
		&i.TermLength,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalTermLength,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
