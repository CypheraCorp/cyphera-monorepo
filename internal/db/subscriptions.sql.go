// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: subscriptions.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelSubscription = `-- name: CancelSubscription :one
UPDATE subscriptions
SET 
    status = 'canceled',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, customer_id, product_id, price_id, product_token_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, created_at, updated_at, deleted_at
`

func (q *Queries) CancelSubscription(ctx context.Context, id uuid.UUID) (Subscription, error) {
	row := q.db.QueryRow(ctx, cancelSubscription, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.PriceID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const completeSubscription = `-- name: CompleteSubscription :one
UPDATE subscriptions
SET 
    status = 'completed',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, customer_id, product_id, price_id, product_token_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, created_at, updated_at, deleted_at
`

func (q *Queries) CompleteSubscription(ctx context.Context, id uuid.UUID) (Subscription, error) {
	row := q.db.QueryRow(ctx, completeSubscription, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.PriceID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const countActiveSubscriptions = `-- name: CountActiveSubscriptions :one
SELECT COUNT(*) FROM subscriptions
WHERE (status = 'active' OR status = 'overdue') AND deleted_at IS NULL
`

func (q *Queries) CountActiveSubscriptions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveSubscriptions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSubscriptions = `-- name: CountSubscriptions :one
SELECT COUNT(*) FROM subscriptions
WHERE deleted_at IS NULL
`

func (q *Queries) CountSubscriptions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSubscriptions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSubscriptionsByStatus = `-- name: CountSubscriptionsByStatus :one
SELECT COUNT(*) FROM subscriptions
WHERE status = $1 AND deleted_at IS NULL
`

func (q *Queries) CountSubscriptionsByStatus(ctx context.Context, status SubscriptionStatus) (int64, error) {
	row := q.db.QueryRow(ctx, countSubscriptionsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (
    customer_id,
    product_id,
    price_id,
    product_token_id,
    token_amount,
    delegation_id,
    customer_wallet_id,
    status,
    current_period_start,
    current_period_end,
    next_redemption_date,
    total_redemptions,
    total_amount_in_cents,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
RETURNING id, customer_id, product_id, price_id, product_token_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, created_at, updated_at, deleted_at
`

type CreateSubscriptionParams struct {
	CustomerID         uuid.UUID          `json:"customer_id"`
	ProductID          uuid.UUID          `json:"product_id"`
	PriceID            uuid.UUID          `json:"price_id"`
	ProductTokenID     uuid.UUID          `json:"product_token_id"`
	TokenAmount        pgtype.Numeric     `json:"token_amount"`
	DelegationID       uuid.UUID          `json:"delegation_id"`
	CustomerWalletID   pgtype.UUID        `json:"customer_wallet_id"`
	Status             SubscriptionStatus `json:"status"`
	CurrentPeriodStart pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamptz `json:"current_period_end"`
	NextRedemptionDate pgtype.Timestamptz `json:"next_redemption_date"`
	TotalRedemptions   int32              `json:"total_redemptions"`
	TotalAmountInCents int32              `json:"total_amount_in_cents"`
	Metadata           []byte             `json:"metadata"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.CustomerID,
		arg.ProductID,
		arg.PriceID,
		arg.ProductTokenID,
		arg.TokenAmount,
		arg.DelegationID,
		arg.CustomerWalletID,
		arg.Status,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.NextRedemptionDate,
		arg.TotalRedemptions,
		arg.TotalAmountInCents,
		arg.Metadata,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.PriceID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteSubscription = `-- name: DeleteSubscription :exec
UPDATE subscriptions
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteSubscription(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSubscription, id)
	return err
}

const getOverdueSubscriptions = `-- name: GetOverdueSubscriptions :many
SELECT id, customer_id, product_id, price_id, product_token_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, created_at, updated_at, deleted_at FROM subscriptions
WHERE 
    (current_period_end < CURRENT_TIMESTAMP OR status = 'overdue')
    AND deleted_at IS NULL
ORDER BY current_period_end ASC
`

func (q *Queries) GetOverdueSubscriptions(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getOverdueSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.PriceID,
			&i.ProductTokenID,
			&i.TokenAmount,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscription = `-- name: GetSubscription :one
SELECT id, customer_id, product_id, price_id, product_token_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, created_at, updated_at, deleted_at FROM subscriptions
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetSubscription(ctx context.Context, id uuid.UUID) (Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscription, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.PriceID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSubscriptionWithDetails = `-- name: GetSubscriptionWithDetails :one
SELECT 
    s.id, s.customer_id, s.product_id, s.price_id, s.product_token_id, s.token_amount, s.delegation_id, s.customer_wallet_id, s.status, s.current_period_start, s.current_period_end, s.next_redemption_date, s.total_redemptions, s.total_amount_in_cents, s.metadata, s.created_at, s.updated_at, s.deleted_at,
    p.name as product_name,
    c.name as customer_name,
    c.email as customer_email,
    cw.wallet_address as subscriber_wallet_address,
    cw.network_type as subscriber_network_type,
    t.symbol as token_symbol,
    n.name as network_name,
    n.chain_id,
    pr.type AS price_type,
    pr.currency AS price_currency,
    pr.unit_amount_in_pennies AS price_unit_amount_in_pennies,
    pr.interval_type AS price_interval_type,
    pr.interval_count AS price_interval_count,
    pr.term_length AS price_term_length
FROM subscriptions s
JOIN products p ON p.id = s.product_id
JOIN prices pr ON pr.id = s.price_id
JOIN customers c ON c.id = s.customer_id
LEFT JOIN customer_wallets cw ON cw.id = s.customer_wallet_id
JOIN products_tokens pt ON pt.id = s.product_token_id
JOIN tokens t ON t.id = pt.token_id
JOIN networks n ON n.id = pt.network_id
WHERE s.id = $1 AND s.deleted_at IS NULL
`

type GetSubscriptionWithDetailsRow struct {
	ID                       uuid.UUID          `json:"id"`
	CustomerID               uuid.UUID          `json:"customer_id"`
	ProductID                uuid.UUID          `json:"product_id"`
	PriceID                  uuid.UUID          `json:"price_id"`
	ProductTokenID           uuid.UUID          `json:"product_token_id"`
	TokenAmount              pgtype.Numeric     `json:"token_amount"`
	DelegationID             uuid.UUID          `json:"delegation_id"`
	CustomerWalletID         pgtype.UUID        `json:"customer_wallet_id"`
	Status                   SubscriptionStatus `json:"status"`
	CurrentPeriodStart       pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd         pgtype.Timestamptz `json:"current_period_end"`
	NextRedemptionDate       pgtype.Timestamptz `json:"next_redemption_date"`
	TotalRedemptions         int32              `json:"total_redemptions"`
	TotalAmountInCents       int32              `json:"total_amount_in_cents"`
	Metadata                 []byte             `json:"metadata"`
	CreatedAt                pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                pgtype.Timestamptz `json:"updated_at"`
	DeletedAt                pgtype.Timestamptz `json:"deleted_at"`
	ProductName              string             `json:"product_name"`
	CustomerName             pgtype.Text        `json:"customer_name"`
	CustomerEmail            pgtype.Text        `json:"customer_email"`
	SubscriberWalletAddress  pgtype.Text        `json:"subscriber_wallet_address"`
	SubscriberNetworkType    NullNetworkType    `json:"subscriber_network_type"`
	TokenSymbol              string             `json:"token_symbol"`
	NetworkName              string             `json:"network_name"`
	ChainID                  int32              `json:"chain_id"`
	PriceType                PriceType          `json:"price_type"`
	PriceCurrency            Currency           `json:"price_currency"`
	PriceUnitAmountInPennies int32              `json:"price_unit_amount_in_pennies"`
	PriceIntervalType        NullIntervalType   `json:"price_interval_type"`
	PriceIntervalCount       pgtype.Int4        `json:"price_interval_count"`
	PriceTermLength          pgtype.Int4        `json:"price_term_length"`
}

func (q *Queries) GetSubscriptionWithDetails(ctx context.Context, id uuid.UUID) (GetSubscriptionWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionWithDetails, id)
	var i GetSubscriptionWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.PriceID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProductName,
		&i.CustomerName,
		&i.CustomerEmail,
		&i.SubscriberWalletAddress,
		&i.SubscriberNetworkType,
		&i.TokenSymbol,
		&i.NetworkName,
		&i.ChainID,
		&i.PriceType,
		&i.PriceCurrency,
		&i.PriceUnitAmountInPennies,
		&i.PriceIntervalType,
		&i.PriceIntervalCount,
		&i.PriceTermLength,
	)
	return i, err
}

const getSubscriptionsByDelegation = `-- name: GetSubscriptionsByDelegation :many
SELECT id, customer_id, product_id, price_id, product_token_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, created_at, updated_at, deleted_at FROM subscriptions
WHERE delegation_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetSubscriptionsByDelegation(ctx context.Context, delegationID uuid.UUID) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsByDelegation, delegationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.PriceID,
			&i.ProductTokenID,
			&i.TokenAmount,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementSubscriptionRedemption = `-- name: IncrementSubscriptionRedemption :one
UPDATE subscriptions
SET 
    total_redemptions = total_redemptions + 1,
    total_amount_in_cents = total_amount_in_cents + $2,
    next_redemption_date = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, customer_id, product_id, price_id, product_token_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, created_at, updated_at, deleted_at
`

type IncrementSubscriptionRedemptionParams struct {
	ID                 uuid.UUID          `json:"id"`
	TotalAmountInCents int32              `json:"total_amount_in_cents"`
	NextRedemptionDate pgtype.Timestamptz `json:"next_redemption_date"`
}

func (q *Queries) IncrementSubscriptionRedemption(ctx context.Context, arg IncrementSubscriptionRedemptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, incrementSubscriptionRedemption, arg.ID, arg.TotalAmountInCents, arg.NextRedemptionDate)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.PriceID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listActiveSubscriptions = `-- name: ListActiveSubscriptions :many
SELECT id, customer_id, product_id, price_id, product_token_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, created_at, updated_at, deleted_at FROM subscriptions
WHERE (status = 'active' OR status = 'overdue') AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListActiveSubscriptions(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listActiveSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.PriceID,
			&i.ProductTokenID,
			&i.TokenAmount,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionDetailsWithPagination = `-- name: ListSubscriptionDetailsWithPagination :many
SELECT 
    s.id AS subscription_id,
    s.status AS subscription_status,
    s.current_period_start AS subscription_current_period_start,
    s.current_period_end AS subscription_current_period_end,
    s.created_at AS subscription_created_at,
    s.updated_at AS subscription_updated_at,
    s.token_amount AS subscription_token_amount,
    s.next_redemption_date AS subscription_next_redemption_date,
    s.total_redemptions AS subscription_total_redemptions,
    s.total_amount_in_cents AS subscription_total_amount_in_cents,

    -- Customer details
    c.id AS customer_id,
    c.name AS customer_name,
    c.email AS customer_email,

    -- Product details
    p.id AS product_id,
    p.name AS product_name,
    p.description AS product_description,
    p.image_url AS product_image_url,
    p.active AS product_active,
    p.metadata AS product_metadata,
    p.workspace_id AS product_workspace_id,

    -- Price details (from prices table)
    pr.id AS price_id,
    pr.product_id AS price_product_id, -- The product_id FK in the prices table
    pr.active AS price_active,
    pr.type AS price_type,
    pr.nickname AS price_nickname,
    pr.currency AS price_currency,
    pr.unit_amount_in_pennies AS price_unit_amount_in_pennies,
    pr.interval_type AS price_interval_type,
    pr.interval_count AS price_interval_count,
    pr.term_length AS price_term_length,
    pr.metadata AS price_metadata,
    pr.created_at AS price_created_at,
    pr.updated_at AS price_updated_at,

    -- Product token details
    pt.id AS product_token_id,
    pt.token_id AS product_token_token_id,
    pt.network_id AS product_token_network_id,
    pt.created_at AS product_token_created_at,
    pt.updated_at AS product_token_updated_at,
    

    -- Token details
    t.symbol AS token_symbol,
    t.contract_address AS token_address,

    -- Network details
    n.name AS network_name,
    n.type AS network_type,
    n.chain_id AS network_chain_id,

    -- Customer wallet details
    cw.wallet_address AS customer_wallet_address
FROM subscriptions s
JOIN customers c ON s.customer_id = c.id
JOIN products p ON s.product_id = p.id
JOIN prices pr ON s.price_id = pr.id
JOIN products_tokens pt ON s.product_token_id = pt.id
JOIN tokens t ON pt.token_id = t.id
JOIN networks n ON pt.network_id = n.id
LEFT JOIN customer_wallets cw ON s.customer_wallet_id = cw.id
WHERE s.deleted_at IS NULL
    AND c.deleted_at IS NULL
    AND p.deleted_at IS NULL
    AND pr.deleted_at IS NULL
    AND pt.deleted_at IS NULL
    AND t.deleted_at IS NULL
    AND n.deleted_at IS NULL
    AND (cw.id IS NULL OR cw.deleted_at IS NULL) -- Correct handling for LEFT JOIN on deletable table
    AND p.workspace_id = $3
ORDER BY s.created_at DESC
LIMIT $1 OFFSET $2
`

type ListSubscriptionDetailsWithPaginationParams struct {
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

type ListSubscriptionDetailsWithPaginationRow struct {
	SubscriptionID                 uuid.UUID          `json:"subscription_id"`
	SubscriptionStatus             SubscriptionStatus `json:"subscription_status"`
	SubscriptionCurrentPeriodStart pgtype.Timestamptz `json:"subscription_current_period_start"`
	SubscriptionCurrentPeriodEnd   pgtype.Timestamptz `json:"subscription_current_period_end"`
	SubscriptionCreatedAt          pgtype.Timestamptz `json:"subscription_created_at"`
	SubscriptionUpdatedAt          pgtype.Timestamptz `json:"subscription_updated_at"`
	SubscriptionTokenAmount        pgtype.Numeric     `json:"subscription_token_amount"`
	SubscriptionNextRedemptionDate pgtype.Timestamptz `json:"subscription_next_redemption_date"`
	SubscriptionTotalRedemptions   int32              `json:"subscription_total_redemptions"`
	SubscriptionTotalAmountInCents int32              `json:"subscription_total_amount_in_cents"`
	CustomerID                     uuid.UUID          `json:"customer_id"`
	CustomerName                   pgtype.Text        `json:"customer_name"`
	CustomerEmail                  pgtype.Text        `json:"customer_email"`
	ProductID                      uuid.UUID          `json:"product_id"`
	ProductName                    string             `json:"product_name"`
	ProductDescription             pgtype.Text        `json:"product_description"`
	ProductImageUrl                pgtype.Text        `json:"product_image_url"`
	ProductActive                  bool               `json:"product_active"`
	ProductMetadata                []byte             `json:"product_metadata"`
	ProductWorkspaceID             uuid.UUID          `json:"product_workspace_id"`
	PriceID                        uuid.UUID          `json:"price_id"`
	PriceProductID                 uuid.UUID          `json:"price_product_id"`
	PriceActive                    bool               `json:"price_active"`
	PriceType                      PriceType          `json:"price_type"`
	PriceNickname                  pgtype.Text        `json:"price_nickname"`
	PriceCurrency                  Currency           `json:"price_currency"`
	PriceUnitAmountInPennies       int32              `json:"price_unit_amount_in_pennies"`
	PriceIntervalType              NullIntervalType   `json:"price_interval_type"`
	PriceIntervalCount             pgtype.Int4        `json:"price_interval_count"`
	PriceTermLength                pgtype.Int4        `json:"price_term_length"`
	PriceMetadata                  []byte             `json:"price_metadata"`
	PriceCreatedAt                 pgtype.Timestamptz `json:"price_created_at"`
	PriceUpdatedAt                 pgtype.Timestamptz `json:"price_updated_at"`
	ProductTokenID                 uuid.UUID          `json:"product_token_id"`
	ProductTokenTokenID            uuid.UUID          `json:"product_token_token_id"`
	ProductTokenNetworkID          uuid.UUID          `json:"product_token_network_id"`
	ProductTokenCreatedAt          pgtype.Timestamptz `json:"product_token_created_at"`
	ProductTokenUpdatedAt          pgtype.Timestamptz `json:"product_token_updated_at"`
	TokenSymbol                    string             `json:"token_symbol"`
	TokenAddress                   string             `json:"token_address"`
	NetworkName                    string             `json:"network_name"`
	NetworkType                    string             `json:"network_type"`
	NetworkChainID                 int32              `json:"network_chain_id"`
	CustomerWalletAddress          pgtype.Text        `json:"customer_wallet_address"`
}

func (q *Queries) ListSubscriptionDetailsWithPagination(ctx context.Context, arg ListSubscriptionDetailsWithPaginationParams) ([]ListSubscriptionDetailsWithPaginationRow, error) {
	rows, err := q.db.Query(ctx, listSubscriptionDetailsWithPagination, arg.Limit, arg.Offset, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionDetailsWithPaginationRow{}
	for rows.Next() {
		var i ListSubscriptionDetailsWithPaginationRow
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.SubscriptionStatus,
			&i.SubscriptionCurrentPeriodStart,
			&i.SubscriptionCurrentPeriodEnd,
			&i.SubscriptionCreatedAt,
			&i.SubscriptionUpdatedAt,
			&i.SubscriptionTokenAmount,
			&i.SubscriptionNextRedemptionDate,
			&i.SubscriptionTotalRedemptions,
			&i.SubscriptionTotalAmountInCents,
			&i.CustomerID,
			&i.CustomerName,
			&i.CustomerEmail,
			&i.ProductID,
			&i.ProductName,
			&i.ProductDescription,
			&i.ProductImageUrl,
			&i.ProductActive,
			&i.ProductMetadata,
			&i.ProductWorkspaceID,
			&i.PriceID,
			&i.PriceProductID,
			&i.PriceActive,
			&i.PriceType,
			&i.PriceNickname,
			&i.PriceCurrency,
			&i.PriceUnitAmountInPennies,
			&i.PriceIntervalType,
			&i.PriceIntervalCount,
			&i.PriceTermLength,
			&i.PriceMetadata,
			&i.PriceCreatedAt,
			&i.PriceUpdatedAt,
			&i.ProductTokenID,
			&i.ProductTokenTokenID,
			&i.ProductTokenNetworkID,
			&i.ProductTokenCreatedAt,
			&i.ProductTokenUpdatedAt,
			&i.TokenSymbol,
			&i.TokenAddress,
			&i.NetworkName,
			&i.NetworkType,
			&i.NetworkChainID,
			&i.CustomerWalletAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptions = `-- name: ListSubscriptions :many
SELECT id, customer_id, product_id, price_id, product_token_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, created_at, updated_at, deleted_at FROM subscriptions
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListSubscriptions(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.PriceID,
			&i.ProductTokenID,
			&i.TokenAmount,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsByCustomer = `-- name: ListSubscriptionsByCustomer :many
SELECT id, customer_id, product_id, price_id, product_token_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, created_at, updated_at, deleted_at FROM subscriptions
WHERE customer_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListSubscriptionsByCustomer(ctx context.Context, customerID uuid.UUID) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.PriceID,
			&i.ProductTokenID,
			&i.TokenAmount,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsByProduct = `-- name: ListSubscriptionsByProduct :many
SELECT s.id, s.customer_id, s.product_id, s.price_id, s.product_token_id, s.token_amount, s.delegation_id, s.customer_wallet_id, s.status, s.current_period_start, s.current_period_end, s.next_redemption_date, s.total_redemptions, s.total_amount_in_cents, s.metadata, s.created_at, s.updated_at, s.deleted_at FROM subscriptions s
JOIN products p ON s.product_id = p.id
WHERE s.product_id = $1 AND p.workspace_id = $2 AND s.deleted_at IS NULL
ORDER BY s.created_at DESC
`

type ListSubscriptionsByProductParams struct {
	ProductID   uuid.UUID `json:"product_id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) ListSubscriptionsByProduct(ctx context.Context, arg ListSubscriptionsByProductParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsByProduct, arg.ProductID, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.PriceID,
			&i.ProductTokenID,
			&i.TokenAmount,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsDueForRedemption = `-- name: ListSubscriptionsDueForRedemption :many
SELECT id, customer_id, product_id, price_id, product_token_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, created_at, updated_at, deleted_at FROM subscriptions
WHERE 
    (status = 'active' OR status = 'overdue')
    AND next_redemption_date <= $1
    AND deleted_at IS NULL
ORDER BY next_redemption_date ASC
`

func (q *Queries) ListSubscriptionsDueForRedemption(ctx context.Context, nextRedemptionDate pgtype.Timestamptz) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsDueForRedemption, nextRedemptionDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.PriceID,
			&i.ProductTokenID,
			&i.TokenAmount,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsWithPagination = `-- name: ListSubscriptionsWithPagination :many
SELECT id, customer_id, product_id, price_id, product_token_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, created_at, updated_at, deleted_at FROM subscriptions
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListSubscriptionsWithPaginationParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSubscriptionsWithPagination(ctx context.Context, arg ListSubscriptionsWithPaginationParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsWithPagination, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.PriceID,
			&i.ProductTokenID,
			&i.TokenAmount,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockSubscriptionForProcessing = `-- name: LockSubscriptionForProcessing :one
SELECT id, customer_id, product_id, price_id, product_token_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, created_at, updated_at, deleted_at
FROM subscriptions
WHERE id = $1 AND (status = 'active' OR status = 'overdue') AND deleted_at IS NULL
FOR UPDATE NOWAIT
LIMIT 1
`

func (q *Queries) LockSubscriptionForProcessing(ctx context.Context, id uuid.UUID) (Subscription, error) {
	row := q.db.QueryRow(ctx, lockSubscriptionForProcessing, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.PriceID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSubscription = `-- name: UpdateSubscription :one
UPDATE subscriptions
SET
    customer_id = COALESCE($2, customer_id),
    product_id = COALESCE($3, product_id),
    price_id = COALESCE($4, price_id),
    product_token_id = COALESCE($5, product_token_id),
    token_amount = COALESCE($6, token_amount),
    delegation_id = COALESCE($7, delegation_id),
    customer_wallet_id = COALESCE($8, customer_wallet_id),
    status = COALESCE($9, status),
    current_period_start = COALESCE($10, current_period_start),
    current_period_end = COALESCE($11, current_period_end),
    next_redemption_date = COALESCE($12, next_redemption_date),
    total_redemptions = COALESCE($13, total_redemptions),
    total_amount_in_cents = COALESCE($14, total_amount_in_cents),
    metadata = COALESCE($15, metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, customer_id, product_id, price_id, product_token_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, created_at, updated_at, deleted_at
`

type UpdateSubscriptionParams struct {
	ID                 uuid.UUID          `json:"id"`
	CustomerID         uuid.UUID          `json:"customer_id"`
	ProductID          uuid.UUID          `json:"product_id"`
	PriceID            uuid.UUID          `json:"price_id"`
	ProductTokenID     uuid.UUID          `json:"product_token_id"`
	TokenAmount        pgtype.Numeric     `json:"token_amount"`
	DelegationID       uuid.UUID          `json:"delegation_id"`
	CustomerWalletID   pgtype.UUID        `json:"customer_wallet_id"`
	Status             SubscriptionStatus `json:"status"`
	CurrentPeriodStart pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamptz `json:"current_period_end"`
	NextRedemptionDate pgtype.Timestamptz `json:"next_redemption_date"`
	TotalRedemptions   int32              `json:"total_redemptions"`
	TotalAmountInCents int32              `json:"total_amount_in_cents"`
	Metadata           []byte             `json:"metadata"`
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscription,
		arg.ID,
		arg.CustomerID,
		arg.ProductID,
		arg.PriceID,
		arg.ProductTokenID,
		arg.TokenAmount,
		arg.DelegationID,
		arg.CustomerWalletID,
		arg.Status,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.NextRedemptionDate,
		arg.TotalRedemptions,
		arg.TotalAmountInCents,
		arg.Metadata,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.PriceID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSubscriptionStatus = `-- name: UpdateSubscriptionStatus :one
UPDATE subscriptions
SET 
    status = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, customer_id, product_id, price_id, product_token_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, created_at, updated_at, deleted_at
`

type UpdateSubscriptionStatusParams struct {
	ID     uuid.UUID          `json:"id"`
	Status SubscriptionStatus `json:"status"`
}

func (q *Queries) UpdateSubscriptionStatus(ctx context.Context, arg UpdateSubscriptionStatusParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionStatus, arg.ID, arg.Status)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.PriceID,
		&i.ProductTokenID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
