// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: tokens.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const activateToken = `-- name: ActivateToken :one
UPDATE tokens
SET 
    active = true,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, network_id, gas_token, name, symbol, contract_address, active, decimals, created_at, updated_at, deleted_at
`

func (q *Queries) ActivateToken(ctx context.Context, id uuid.UUID) (Token, error) {
	row := q.db.QueryRow(ctx, activateToken, id)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.GasToken,
		&i.Name,
		&i.Symbol,
		&i.ContractAddress,
		&i.Active,
		&i.Decimals,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createToken = `-- name: CreateToken :one
INSERT INTO tokens (
    network_id,
    gas_token,
    name,
    symbol,
    contract_address,
    decimals,
    active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, network_id, gas_token, name, symbol, contract_address, active, decimals, created_at, updated_at, deleted_at
`

type CreateTokenParams struct {
	NetworkID       uuid.UUID `json:"network_id"`
	GasToken        bool      `json:"gas_token"`
	Name            string    `json:"name"`
	Symbol          string    `json:"symbol"`
	ContractAddress string    `json:"contract_address"`
	Decimals        int32     `json:"decimals"`
	Active          bool      `json:"active"`
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) (Token, error) {
	row := q.db.QueryRow(ctx, createToken,
		arg.NetworkID,
		arg.GasToken,
		arg.Name,
		arg.Symbol,
		arg.ContractAddress,
		arg.Decimals,
		arg.Active,
	)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.GasToken,
		&i.Name,
		&i.Symbol,
		&i.ContractAddress,
		&i.Active,
		&i.Decimals,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deactivateToken = `-- name: DeactivateToken :one
UPDATE tokens
SET 
    active = false,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, network_id, gas_token, name, symbol, contract_address, active, decimals, created_at, updated_at, deleted_at
`

func (q *Queries) DeactivateToken(ctx context.Context, id uuid.UUID) (Token, error) {
	row := q.db.QueryRow(ctx, deactivateToken, id)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.GasToken,
		&i.Name,
		&i.Symbol,
		&i.ContractAddress,
		&i.Active,
		&i.Decimals,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteToken = `-- name: DeleteToken :exec
UPDATE tokens
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteToken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteToken, id)
	return err
}

const getGasToken = `-- name: GetGasToken :one
SELECT id, network_id, gas_token, name, symbol, contract_address, active, decimals, created_at, updated_at, deleted_at FROM tokens
WHERE network_id = $1 AND gas_token = true AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetGasToken(ctx context.Context, networkID uuid.UUID) (Token, error) {
	row := q.db.QueryRow(ctx, getGasToken, networkID)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.GasToken,
		&i.Name,
		&i.Symbol,
		&i.ContractAddress,
		&i.Active,
		&i.Decimals,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getToken = `-- name: GetToken :one
SELECT id, network_id, gas_token, name, symbol, contract_address, active, decimals, created_at, updated_at, deleted_at FROM tokens
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetToken(ctx context.Context, id uuid.UUID) (Token, error) {
	row := q.db.QueryRow(ctx, getToken, id)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.GasToken,
		&i.Name,
		&i.Symbol,
		&i.ContractAddress,
		&i.Active,
		&i.Decimals,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getTokenByAddress = `-- name: GetTokenByAddress :one
SELECT id, network_id, gas_token, name, symbol, contract_address, active, decimals, created_at, updated_at, deleted_at FROM tokens
WHERE network_id = $1 AND contract_address = $2 AND deleted_at IS NULL
`

type GetTokenByAddressParams struct {
	NetworkID       uuid.UUID `json:"network_id"`
	ContractAddress string    `json:"contract_address"`
}

func (q *Queries) GetTokenByAddress(ctx context.Context, arg GetTokenByAddressParams) (Token, error) {
	row := q.db.QueryRow(ctx, getTokenByAddress, arg.NetworkID, arg.ContractAddress)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.GasToken,
		&i.Name,
		&i.Symbol,
		&i.ContractAddress,
		&i.Active,
		&i.Decimals,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listActiveTokensByNetwork = `-- name: ListActiveTokensByNetwork :many
SELECT id, network_id, gas_token, name, symbol, contract_address, active, decimals, created_at, updated_at, deleted_at FROM tokens
WHERE network_id = $1 AND active = true AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListActiveTokensByNetwork(ctx context.Context, networkID uuid.UUID) ([]Token, error) {
	rows, err := q.db.Query(ctx, listActiveTokensByNetwork, networkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Token{}
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.NetworkID,
			&i.GasToken,
			&i.Name,
			&i.Symbol,
			&i.ContractAddress,
			&i.Active,
			&i.Decimals,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTokens = `-- name: ListTokens :many
SELECT id, network_id, gas_token, name, symbol, contract_address, active, decimals, created_at, updated_at, deleted_at FROM tokens
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListTokens(ctx context.Context) ([]Token, error) {
	rows, err := q.db.Query(ctx, listTokens)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Token{}
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.NetworkID,
			&i.GasToken,
			&i.Name,
			&i.Symbol,
			&i.ContractAddress,
			&i.Active,
			&i.Decimals,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTokensByNetwork = `-- name: ListTokensByNetwork :many
SELECT id, network_id, gas_token, name, symbol, contract_address, active, decimals, created_at, updated_at, deleted_at FROM tokens
WHERE network_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListTokensByNetwork(ctx context.Context, networkID uuid.UUID) ([]Token, error) {
	rows, err := q.db.Query(ctx, listTokensByNetwork, networkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Token{}
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.NetworkID,
			&i.GasToken,
			&i.Name,
			&i.Symbol,
			&i.ContractAddress,
			&i.Active,
			&i.Decimals,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateToken = `-- name: UpdateToken :one
UPDATE tokens
SET
    name = COALESCE($2, name),
    symbol = COALESCE($3, symbol),
    contract_address = COALESCE($4, contract_address),
    gas_token = COALESCE($5, gas_token),
    decimals = COALESCE($6, decimals),
    active = COALESCE($7, active),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, network_id, gas_token, name, symbol, contract_address, active, decimals, created_at, updated_at, deleted_at
`

type UpdateTokenParams struct {
	ID              uuid.UUID `json:"id"`
	Name            string    `json:"name"`
	Symbol          string    `json:"symbol"`
	ContractAddress string    `json:"contract_address"`
	GasToken        bool      `json:"gas_token"`
	Decimals        int32     `json:"decimals"`
	Active          bool      `json:"active"`
}

func (q *Queries) UpdateToken(ctx context.Context, arg UpdateTokenParams) (Token, error) {
	row := q.db.QueryRow(ctx, updateToken,
		arg.ID,
		arg.Name,
		arg.Symbol,
		arg.ContractAddress,
		arg.GasToken,
		arg.Decimals,
		arg.Active,
	)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.GasToken,
		&i.Name,
		&i.Symbol,
		&i.ContractAddress,
		&i.Active,
		&i.Decimals,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
