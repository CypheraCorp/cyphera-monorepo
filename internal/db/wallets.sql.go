// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: wallets.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createWallet = `-- name: CreateWallet :one
INSERT INTO wallets (
    account_id,
    wallet_address,
    network_type,
    nickname,
    ens,
    is_primary,
    verified,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, account_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at
`

type CreateWalletParams struct {
	AccountID     uuid.UUID   `json:"account_id"`
	WalletAddress string      `json:"wallet_address"`
	NetworkType   NetworkType `json:"network_type"`
	Nickname      pgtype.Text `json:"nickname"`
	Ens           pgtype.Text `json:"ens"`
	IsPrimary     pgtype.Bool `json:"is_primary"`
	Verified      pgtype.Bool `json:"verified"`
	Metadata      []byte      `json:"metadata"`
}

func (q *Queries) CreateWallet(ctx context.Context, arg CreateWalletParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, createWallet,
		arg.AccountID,
		arg.WalletAddress,
		arg.NetworkType,
		arg.Nickname,
		arg.Ens,
		arg.IsPrimary,
		arg.Verified,
		arg.Metadata,
	)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.WalletAddress,
		&i.NetworkType,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getRecentlyUsedWallets = `-- name: GetRecentlyUsedWallets :many
SELECT id, account_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE account_id = $1 
AND last_used_at IS NOT NULL 
AND deleted_at IS NULL
ORDER BY last_used_at DESC
LIMIT $2
`

type GetRecentlyUsedWalletsParams struct {
	AccountID uuid.UUID `json:"account_id"`
	Limit     int32     `json:"limit"`
}

func (q *Queries) GetRecentlyUsedWallets(ctx context.Context, arg GetRecentlyUsedWalletsParams) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, getRecentlyUsedWallets, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.WalletAddress,
			&i.NetworkType,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletByAddress = `-- name: GetWalletByAddress :one
SELECT id, account_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE wallet_address = $1 AND network_type = $2 AND deleted_at IS NULL
`

type GetWalletByAddressParams struct {
	WalletAddress string      `json:"wallet_address"`
	NetworkType   NetworkType `json:"network_type"`
}

func (q *Queries) GetWalletByAddress(ctx context.Context, arg GetWalletByAddressParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByAddress, arg.WalletAddress, arg.NetworkType)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.WalletAddress,
		&i.NetworkType,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getWalletByID = `-- name: GetWalletByID :one
SELECT id, account_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetWalletByID(ctx context.Context, id uuid.UUID) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByID, id)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.WalletAddress,
		&i.NetworkType,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getWalletStats = `-- name: GetWalletStats :one
SELECT 
    COUNT(*) as total_wallets,
    COUNT(*) FILTER (WHERE verified = true) as verified_wallets,
    COUNT(*) FILTER (WHERE is_primary = true) as primary_wallets,
    COUNT(DISTINCT network_type) as network_types_count
FROM wallets
WHERE account_id = $1 AND deleted_at IS NULL
`

type GetWalletStatsRow struct {
	TotalWallets      int64 `json:"total_wallets"`
	VerifiedWallets   int64 `json:"verified_wallets"`
	PrimaryWallets    int64 `json:"primary_wallets"`
	NetworkTypesCount int64 `json:"network_types_count"`
}

func (q *Queries) GetWalletStats(ctx context.Context, accountID uuid.UUID) (GetWalletStatsRow, error) {
	row := q.db.QueryRow(ctx, getWalletStats, accountID)
	var i GetWalletStatsRow
	err := row.Scan(
		&i.TotalWallets,
		&i.VerifiedWallets,
		&i.PrimaryWallets,
		&i.NetworkTypesCount,
	)
	return i, err
}

const getWalletsByENS = `-- name: GetWalletsByENS :many
SELECT id, account_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE account_id = $1 
AND ens IS NOT NULL 
AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetWalletsByENS(ctx context.Context, accountID uuid.UUID) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, getWalletsByENS, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.WalletAddress,
			&i.NetworkType,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPrimaryWalletsByAccountID = `-- name: ListPrimaryWalletsByAccountID :many
SELECT id, account_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE account_id = $1 AND is_primary = true AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListPrimaryWalletsByAccountID(ctx context.Context, accountID uuid.UUID) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, listPrimaryWalletsByAccountID, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.WalletAddress,
			&i.NetworkType,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWalletsByAccountID = `-- name: ListWalletsByAccountID :many
SELECT id, account_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE account_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListWalletsByAccountID(ctx context.Context, accountID uuid.UUID) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, listWalletsByAccountID, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.WalletAddress,
			&i.NetworkType,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWalletsByNetworkType = `-- name: ListWalletsByNetworkType :many
SELECT id, account_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE account_id = $1 AND network_type = $2 AND deleted_at IS NULL
ORDER BY created_at DESC
`

type ListWalletsByNetworkTypeParams struct {
	AccountID   uuid.UUID   `json:"account_id"`
	NetworkType NetworkType `json:"network_type"`
}

func (q *Queries) ListWalletsByNetworkType(ctx context.Context, arg ListWalletsByNetworkTypeParams) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, listWalletsByNetworkType, arg.AccountID, arg.NetworkType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.WalletAddress,
			&i.NetworkType,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchWallets = `-- name: SearchWallets :many
SELECT id, account_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE account_id = $1 
AND deleted_at IS NULL
AND (
    wallet_address ILIKE $2 
    OR nickname ILIKE $2 
    OR ens ILIKE $2
)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type SearchWalletsParams struct {
	AccountID     uuid.UUID `json:"account_id"`
	WalletAddress string    `json:"wallet_address"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
}

func (q *Queries) SearchWallets(ctx context.Context, arg SearchWalletsParams) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, searchWallets,
		arg.AccountID,
		arg.WalletAddress,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.WalletAddress,
			&i.NetworkType,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setWalletAsPrimary = `-- name: SetWalletAsPrimary :execrows
WITH updated_wallets AS (
    UPDATE wallets w
    SET is_primary = false
    WHERE w.account_id = $1 
    AND w.network_type = $2 
    AND w.is_primary = true 
    AND w.deleted_at IS NULL
)
UPDATE wallets w
SET 
    is_primary = true,
    updated_at = CURRENT_TIMESTAMP
WHERE w.id = $3 AND w.deleted_at IS NULL
`

type SetWalletAsPrimaryParams struct {
	AccountID   uuid.UUID   `json:"account_id"`
	NetworkType NetworkType `json:"network_type"`
	ID          uuid.UUID   `json:"id"`
}

func (q *Queries) SetWalletAsPrimary(ctx context.Context, arg SetWalletAsPrimaryParams) (int64, error) {
	result, err := q.db.Exec(ctx, setWalletAsPrimary, arg.AccountID, arg.NetworkType, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const softDeleteWallet = `-- name: SoftDeleteWallet :exec
UPDATE wallets
SET 
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteWallet(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteWallet, id)
	return err
}

const updateWallet = `-- name: UpdateWallet :one
UPDATE wallets
SET 
    nickname = COALESCE($1, nickname),
    ens = COALESCE($2, ens),
    is_primary = COALESCE($3, is_primary),
    verified = COALESCE($4, verified),
    metadata = COALESCE($5, metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $6 AND deleted_at IS NULL
RETURNING id, account_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at
`

type UpdateWalletParams struct {
	Nickname  pgtype.Text `json:"nickname"`
	Ens       pgtype.Text `json:"ens"`
	IsPrimary pgtype.Bool `json:"is_primary"`
	Verified  pgtype.Bool `json:"verified"`
	Metadata  []byte      `json:"metadata"`
	ID        uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateWallet(ctx context.Context, arg UpdateWalletParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, updateWallet,
		arg.Nickname,
		arg.Ens,
		arg.IsPrimary,
		arg.Verified,
		arg.Metadata,
		arg.ID,
	)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.WalletAddress,
		&i.NetworkType,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateWalletLastUsed = `-- name: UpdateWalletLastUsed :exec
UPDATE wallets
SET 
    last_used_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) UpdateWalletLastUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateWalletLastUsed, id)
	return err
}

const updateWalletVerificationStatus = `-- name: UpdateWalletVerificationStatus :one
UPDATE wallets
SET 
    verified = $1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $2 AND deleted_at IS NULL
RETURNING id, account_id, wallet_address, network_type, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at
`

type UpdateWalletVerificationStatusParams struct {
	Verified pgtype.Bool `json:"verified"`
	ID       uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateWalletVerificationStatus(ctx context.Context, arg UpdateWalletVerificationStatusParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, updateWalletVerificationStatus, arg.Verified, arg.ID)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.WalletAddress,
		&i.NetworkType,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
