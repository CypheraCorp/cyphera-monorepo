// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: wallets.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCircleWalletEntry = `-- name: CreateCircleWalletEntry :one
INSERT INTO circle_wallets (
    wallet_id,
    circle_user_id,
    circle_wallet_id,
    chain_id,
    state
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, wallet_id, circle_user_id, circle_wallet_id, chain_id, state, created_at, updated_at, deleted_at
`

type CreateCircleWalletEntryParams struct {
	WalletID       uuid.UUID `json:"wallet_id"`
	CircleUserID   uuid.UUID `json:"circle_user_id"`
	CircleWalletID string    `json:"circle_wallet_id"`
	ChainID        int32     `json:"chain_id"`
	State          string    `json:"state"`
}

func (q *Queries) CreateCircleWalletEntry(ctx context.Context, arg CreateCircleWalletEntryParams) (CircleWallet, error) {
	row := q.db.QueryRow(ctx, createCircleWalletEntry,
		arg.WalletID,
		arg.CircleUserID,
		arg.CircleWalletID,
		arg.ChainID,
		arg.State,
	)
	var i CircleWallet
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.CircleUserID,
		&i.CircleWalletID,
		&i.ChainID,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createWallet = `-- name: CreateWallet :one
INSERT INTO wallets (
    workspace_id,
    wallet_type,
    wallet_address,
    network_type,
    network_id,
    nickname,
    ens,
    is_primary,
    verified,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, workspace_id, wallet_type, wallet_address, network_type, network_id, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at
`

type CreateWalletParams struct {
	WorkspaceID   uuid.UUID   `json:"workspace_id"`
	WalletType    string      `json:"wallet_type"`
	WalletAddress string      `json:"wallet_address"`
	NetworkType   NetworkType `json:"network_type"`
	NetworkID     pgtype.UUID `json:"network_id"`
	Nickname      pgtype.Text `json:"nickname"`
	Ens           pgtype.Text `json:"ens"`
	IsPrimary     pgtype.Bool `json:"is_primary"`
	Verified      pgtype.Bool `json:"verified"`
	Metadata      []byte      `json:"metadata"`
}

func (q *Queries) CreateWallet(ctx context.Context, arg CreateWalletParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, createWallet,
		arg.WorkspaceID,
		arg.WalletType,
		arg.WalletAddress,
		arg.NetworkType,
		arg.NetworkID,
		arg.Nickname,
		arg.Ens,
		arg.IsPrimary,
		arg.Verified,
		arg.Metadata,
	)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.WalletType,
		&i.WalletAddress,
		&i.NetworkType,
		&i.NetworkID,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCircleWalletByCircleWalletID = `-- name: GetCircleWalletByCircleWalletID :one
SELECT 
    w.id, w.workspace_id, w.wallet_type, w.wallet_address, w.network_type, w.network_id, w.nickname, w.ens, w.is_primary, w.verified, w.last_used_at, w.metadata, w.created_at, w.updated_at, w.deleted_at,
    cw.id as circle_wallet_id,
    cw.circle_user_id,
    cw.circle_wallet_id as circle_id,
    cw.chain_id,
    cw.state as circle_state
FROM wallets w
JOIN circle_wallets cw ON w.id = cw.wallet_id
WHERE cw.circle_wallet_id = $1 AND w.deleted_at IS NULL
`

type GetCircleWalletByCircleWalletIDRow struct {
	ID             uuid.UUID          `json:"id"`
	WorkspaceID    uuid.UUID          `json:"workspace_id"`
	WalletType     string             `json:"wallet_type"`
	WalletAddress  string             `json:"wallet_address"`
	NetworkType    NetworkType        `json:"network_type"`
	NetworkID      pgtype.UUID        `json:"network_id"`
	Nickname       pgtype.Text        `json:"nickname"`
	Ens            pgtype.Text        `json:"ens"`
	IsPrimary      pgtype.Bool        `json:"is_primary"`
	Verified       pgtype.Bool        `json:"verified"`
	LastUsedAt     pgtype.Timestamptz `json:"last_used_at"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	CircleWalletID uuid.UUID          `json:"circle_wallet_id"`
	CircleUserID   uuid.UUID          `json:"circle_user_id"`
	CircleID       string             `json:"circle_id"`
	ChainID        int32              `json:"chain_id"`
	CircleState    string             `json:"circle_state"`
}

func (q *Queries) GetCircleWalletByCircleWalletID(ctx context.Context, circleWalletID string) (GetCircleWalletByCircleWalletIDRow, error) {
	row := q.db.QueryRow(ctx, getCircleWalletByCircleWalletID, circleWalletID)
	var i GetCircleWalletByCircleWalletIDRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.WalletType,
		&i.WalletAddress,
		&i.NetworkType,
		&i.NetworkID,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CircleWalletID,
		&i.CircleUserID,
		&i.CircleID,
		&i.ChainID,
		&i.CircleState,
	)
	return i, err
}

const getRecentlyUsedWallets = `-- name: GetRecentlyUsedWallets :many
SELECT id, workspace_id, wallet_type, wallet_address, network_type, network_id, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE workspace_id = $1
AND last_used_at IS NOT NULL 
AND deleted_at IS NULL
ORDER BY last_used_at DESC
LIMIT $2
`

type GetRecentlyUsedWalletsParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
}

func (q *Queries) GetRecentlyUsedWallets(ctx context.Context, arg GetRecentlyUsedWalletsParams) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, getRecentlyUsedWallets, arg.WorkspaceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletType,
			&i.WalletAddress,
			&i.NetworkType,
			&i.NetworkID,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentlyUsedWalletsWithCircleData = `-- name: GetRecentlyUsedWalletsWithCircleData :many
SELECT 
    w.id, w.workspace_id, w.wallet_type, w.wallet_address, w.network_type, w.network_id, w.nickname, w.ens, w.is_primary, w.verified, w.last_used_at, w.metadata, w.created_at, w.updated_at, w.deleted_at,
    cw.id as circle_wallet_id,
    cw.circle_user_id,
    cw.circle_wallet_id as circle_id,
    cw.chain_id,
    cw.state as circle_state
FROM wallets w
LEFT JOIN circle_wallets cw ON w.id = cw.wallet_id AND w.wallet_type = 'circle_wallet'
WHERE w.workspace_id = $1
AND w.last_used_at IS NOT NULL 
AND w.deleted_at IS NULL
ORDER BY w.last_used_at DESC
LIMIT $2
`

type GetRecentlyUsedWalletsWithCircleDataParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
}

type GetRecentlyUsedWalletsWithCircleDataRow struct {
	ID             uuid.UUID          `json:"id"`
	WorkspaceID    uuid.UUID          `json:"workspace_id"`
	WalletType     string             `json:"wallet_type"`
	WalletAddress  string             `json:"wallet_address"`
	NetworkType    NetworkType        `json:"network_type"`
	NetworkID      pgtype.UUID        `json:"network_id"`
	Nickname       pgtype.Text        `json:"nickname"`
	Ens            pgtype.Text        `json:"ens"`
	IsPrimary      pgtype.Bool        `json:"is_primary"`
	Verified       pgtype.Bool        `json:"verified"`
	LastUsedAt     pgtype.Timestamptz `json:"last_used_at"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	CircleWalletID pgtype.UUID        `json:"circle_wallet_id"`
	CircleUserID   pgtype.UUID        `json:"circle_user_id"`
	CircleID       pgtype.Text        `json:"circle_id"`
	ChainID        pgtype.Int4        `json:"chain_id"`
	CircleState    pgtype.Text        `json:"circle_state"`
}

func (q *Queries) GetRecentlyUsedWalletsWithCircleData(ctx context.Context, arg GetRecentlyUsedWalletsWithCircleDataParams) ([]GetRecentlyUsedWalletsWithCircleDataRow, error) {
	rows, err := q.db.Query(ctx, getRecentlyUsedWalletsWithCircleData, arg.WorkspaceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentlyUsedWalletsWithCircleDataRow{}
	for rows.Next() {
		var i GetRecentlyUsedWalletsWithCircleDataRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletType,
			&i.WalletAddress,
			&i.NetworkType,
			&i.NetworkID,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CircleWalletID,
			&i.CircleUserID,
			&i.CircleID,
			&i.ChainID,
			&i.CircleState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletByAddress = `-- name: GetWalletByAddress :one
SELECT id, workspace_id, wallet_type, wallet_address, network_type, network_id, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE wallet_address = $1 AND network_type = $2 AND deleted_at IS NULL
`

type GetWalletByAddressParams struct {
	WalletAddress string      `json:"wallet_address"`
	NetworkType   NetworkType `json:"network_type"`
}

func (q *Queries) GetWalletByAddress(ctx context.Context, arg GetWalletByAddressParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByAddress, arg.WalletAddress, arg.NetworkType)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.WalletType,
		&i.WalletAddress,
		&i.NetworkType,
		&i.NetworkID,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getWalletByID = `-- name: GetWalletByID :one
SELECT id, workspace_id, wallet_type, wallet_address, network_type, network_id, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
`

type GetWalletByIDParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) GetWalletByID(ctx context.Context, arg GetWalletByIDParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByID, arg.ID, arg.WorkspaceID)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.WalletType,
		&i.WalletAddress,
		&i.NetworkType,
		&i.NetworkID,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getWalletStats = `-- name: GetWalletStats :one
SELECT 
    COUNT(*) as total_wallets,
    COUNT(*) FILTER (WHERE verified = true) as verified_wallets,
    COUNT(*) FILTER (WHERE is_primary = true) as primary_wallets,
    COUNT(DISTINCT network_type) as network_types_count,
    COUNT(*) FILTER (WHERE wallet_type = 'wallet') as standard_wallets_count,
    COUNT(*) FILTER (WHERE wallet_type = 'circle_wallet') as circle_wallets_count
FROM wallets
WHERE workspace_id = $1 AND deleted_at IS NULL
`

type GetWalletStatsRow struct {
	TotalWallets         int64 `json:"total_wallets"`
	VerifiedWallets      int64 `json:"verified_wallets"`
	PrimaryWallets       int64 `json:"primary_wallets"`
	NetworkTypesCount    int64 `json:"network_types_count"`
	StandardWalletsCount int64 `json:"standard_wallets_count"`
	CircleWalletsCount   int64 `json:"circle_wallets_count"`
}

func (q *Queries) GetWalletStats(ctx context.Context, workspaceID uuid.UUID) (GetWalletStatsRow, error) {
	row := q.db.QueryRow(ctx, getWalletStats, workspaceID)
	var i GetWalletStatsRow
	err := row.Scan(
		&i.TotalWallets,
		&i.VerifiedWallets,
		&i.PrimaryWallets,
		&i.NetworkTypesCount,
		&i.StandardWalletsCount,
		&i.CircleWalletsCount,
	)
	return i, err
}

const getWalletWithCircleDataByAddress = `-- name: GetWalletWithCircleDataByAddress :one
SELECT 
    w.id, w.workspace_id, w.wallet_type, w.wallet_address, w.network_type, w.network_id, w.nickname, w.ens, w.is_primary, w.verified, w.last_used_at, w.metadata, w.created_at, w.updated_at, w.deleted_at,
    cw.id as circle_wallet_id,
    cw.circle_user_id,
    cw.circle_wallet_id as circle_id,
    cw.chain_id,
    cw.state as circle_state
FROM wallets w
LEFT JOIN circle_wallets cw ON w.id = cw.wallet_id AND w.wallet_type = 'circle_wallet'
WHERE w.wallet_address = $1 AND w.network_type = $2 AND w.deleted_at IS NULL
`

type GetWalletWithCircleDataByAddressParams struct {
	WalletAddress string      `json:"wallet_address"`
	NetworkType   NetworkType `json:"network_type"`
}

type GetWalletWithCircleDataByAddressRow struct {
	ID             uuid.UUID          `json:"id"`
	WorkspaceID    uuid.UUID          `json:"workspace_id"`
	WalletType     string             `json:"wallet_type"`
	WalletAddress  string             `json:"wallet_address"`
	NetworkType    NetworkType        `json:"network_type"`
	NetworkID      pgtype.UUID        `json:"network_id"`
	Nickname       pgtype.Text        `json:"nickname"`
	Ens            pgtype.Text        `json:"ens"`
	IsPrimary      pgtype.Bool        `json:"is_primary"`
	Verified       pgtype.Bool        `json:"verified"`
	LastUsedAt     pgtype.Timestamptz `json:"last_used_at"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	CircleWalletID pgtype.UUID        `json:"circle_wallet_id"`
	CircleUserID   pgtype.UUID        `json:"circle_user_id"`
	CircleID       pgtype.Text        `json:"circle_id"`
	ChainID        pgtype.Int4        `json:"chain_id"`
	CircleState    pgtype.Text        `json:"circle_state"`
}

func (q *Queries) GetWalletWithCircleDataByAddress(ctx context.Context, arg GetWalletWithCircleDataByAddressParams) (GetWalletWithCircleDataByAddressRow, error) {
	row := q.db.QueryRow(ctx, getWalletWithCircleDataByAddress, arg.WalletAddress, arg.NetworkType)
	var i GetWalletWithCircleDataByAddressRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.WalletType,
		&i.WalletAddress,
		&i.NetworkType,
		&i.NetworkID,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CircleWalletID,
		&i.CircleUserID,
		&i.CircleID,
		&i.ChainID,
		&i.CircleState,
	)
	return i, err
}

const getWalletWithCircleDataByID = `-- name: GetWalletWithCircleDataByID :one
SELECT 
    w.id, w.workspace_id, w.wallet_type, w.wallet_address, w.network_type, w.network_id, w.nickname, w.ens, w.is_primary, w.verified, w.last_used_at, w.metadata, w.created_at, w.updated_at, w.deleted_at,
    cw.id as circle_wallet_id,
    cw.circle_user_id,
    cw.circle_wallet_id as circle_id,
    cw.chain_id,
    cw.state as circle_state
FROM wallets w
LEFT JOIN circle_wallets cw ON w.id = cw.wallet_id AND w.wallet_type = 'circle_wallet'
WHERE w.id = $1 AND w.workspace_id = $2 AND w.deleted_at IS NULL
`

type GetWalletWithCircleDataByIDParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

type GetWalletWithCircleDataByIDRow struct {
	ID             uuid.UUID          `json:"id"`
	WorkspaceID    uuid.UUID          `json:"workspace_id"`
	WalletType     string             `json:"wallet_type"`
	WalletAddress  string             `json:"wallet_address"`
	NetworkType    NetworkType        `json:"network_type"`
	NetworkID      pgtype.UUID        `json:"network_id"`
	Nickname       pgtype.Text        `json:"nickname"`
	Ens            pgtype.Text        `json:"ens"`
	IsPrimary      pgtype.Bool        `json:"is_primary"`
	Verified       pgtype.Bool        `json:"verified"`
	LastUsedAt     pgtype.Timestamptz `json:"last_used_at"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	CircleWalletID pgtype.UUID        `json:"circle_wallet_id"`
	CircleUserID   pgtype.UUID        `json:"circle_user_id"`
	CircleID       pgtype.Text        `json:"circle_id"`
	ChainID        pgtype.Int4        `json:"chain_id"`
	CircleState    pgtype.Text        `json:"circle_state"`
}

func (q *Queries) GetWalletWithCircleDataByID(ctx context.Context, arg GetWalletWithCircleDataByIDParams) (GetWalletWithCircleDataByIDRow, error) {
	row := q.db.QueryRow(ctx, getWalletWithCircleDataByID, arg.ID, arg.WorkspaceID)
	var i GetWalletWithCircleDataByIDRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.WalletType,
		&i.WalletAddress,
		&i.NetworkType,
		&i.NetworkID,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CircleWalletID,
		&i.CircleUserID,
		&i.CircleID,
		&i.ChainID,
		&i.CircleState,
	)
	return i, err
}

const getWalletsByENS = `-- name: GetWalletsByENS :many
SELECT id, workspace_id, wallet_type, wallet_address, network_type, network_id, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE workspace_id = $1
AND ens IS NOT NULL 
AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetWalletsByENS(ctx context.Context, workspaceID uuid.UUID) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, getWalletsByENS, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletType,
			&i.WalletAddress,
			&i.NetworkType,
			&i.NetworkID,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCircleWalletsByCircleUserID = `-- name: ListCircleWalletsByCircleUserID :many
SELECT 
    w.id, w.workspace_id, w.wallet_type, w.wallet_address, w.network_type, w.network_id, w.nickname, w.ens, w.is_primary, w.verified, w.last_used_at, w.metadata, w.created_at, w.updated_at, w.deleted_at,
    cw.id as circle_wallet_id,
    cw.circle_user_id,
    cw.circle_wallet_id as circle_id,
    cw.chain_id,
    cw.state as circle_state
FROM wallets w
JOIN circle_wallets cw ON w.id = cw.wallet_id
WHERE cw.circle_user_id = $1 AND w.wallet_type = 'circle_wallet' AND w.deleted_at IS NULL
ORDER BY w.created_at DESC
`

type ListCircleWalletsByCircleUserIDRow struct {
	ID             uuid.UUID          `json:"id"`
	WorkspaceID    uuid.UUID          `json:"workspace_id"`
	WalletType     string             `json:"wallet_type"`
	WalletAddress  string             `json:"wallet_address"`
	NetworkType    NetworkType        `json:"network_type"`
	NetworkID      pgtype.UUID        `json:"network_id"`
	Nickname       pgtype.Text        `json:"nickname"`
	Ens            pgtype.Text        `json:"ens"`
	IsPrimary      pgtype.Bool        `json:"is_primary"`
	Verified       pgtype.Bool        `json:"verified"`
	LastUsedAt     pgtype.Timestamptz `json:"last_used_at"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	CircleWalletID uuid.UUID          `json:"circle_wallet_id"`
	CircleUserID   uuid.UUID          `json:"circle_user_id"`
	CircleID       string             `json:"circle_id"`
	ChainID        int32              `json:"chain_id"`
	CircleState    string             `json:"circle_state"`
}

func (q *Queries) ListCircleWalletsByCircleUserID(ctx context.Context, circleUserID uuid.UUID) ([]ListCircleWalletsByCircleUserIDRow, error) {
	rows, err := q.db.Query(ctx, listCircleWalletsByCircleUserID, circleUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCircleWalletsByCircleUserIDRow{}
	for rows.Next() {
		var i ListCircleWalletsByCircleUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletType,
			&i.WalletAddress,
			&i.NetworkType,
			&i.NetworkID,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CircleWalletID,
			&i.CircleUserID,
			&i.CircleID,
			&i.ChainID,
			&i.CircleState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCircleWalletsByWorkspaceID = `-- name: ListCircleWalletsByWorkspaceID :many
SELECT 
    w.id, w.workspace_id, w.wallet_type, w.wallet_address, w.network_type, w.network_id, w.nickname, w.ens, w.is_primary, w.verified, w.last_used_at, w.metadata, w.created_at, w.updated_at, w.deleted_at,
    cw.id as circle_wallet_id,
    cw.circle_user_id,
    cw.circle_wallet_id as circle_id,
    cw.chain_id,
    cw.state as circle_state
FROM wallets w
JOIN circle_wallets cw ON w.id = cw.wallet_id
WHERE w.workspace_id = $1 AND w.wallet_type = 'circle_wallet' AND w.deleted_at IS NULL
ORDER BY w.created_at DESC
`

type ListCircleWalletsByWorkspaceIDRow struct {
	ID             uuid.UUID          `json:"id"`
	WorkspaceID    uuid.UUID          `json:"workspace_id"`
	WalletType     string             `json:"wallet_type"`
	WalletAddress  string             `json:"wallet_address"`
	NetworkType    NetworkType        `json:"network_type"`
	NetworkID      pgtype.UUID        `json:"network_id"`
	Nickname       pgtype.Text        `json:"nickname"`
	Ens            pgtype.Text        `json:"ens"`
	IsPrimary      pgtype.Bool        `json:"is_primary"`
	Verified       pgtype.Bool        `json:"verified"`
	LastUsedAt     pgtype.Timestamptz `json:"last_used_at"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	CircleWalletID uuid.UUID          `json:"circle_wallet_id"`
	CircleUserID   uuid.UUID          `json:"circle_user_id"`
	CircleID       string             `json:"circle_id"`
	ChainID        int32              `json:"chain_id"`
	CircleState    string             `json:"circle_state"`
}

func (q *Queries) ListCircleWalletsByWorkspaceID(ctx context.Context, workspaceID uuid.UUID) ([]ListCircleWalletsByWorkspaceIDRow, error) {
	rows, err := q.db.Query(ctx, listCircleWalletsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCircleWalletsByWorkspaceIDRow{}
	for rows.Next() {
		var i ListCircleWalletsByWorkspaceIDRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletType,
			&i.WalletAddress,
			&i.NetworkType,
			&i.NetworkID,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CircleWalletID,
			&i.CircleUserID,
			&i.CircleID,
			&i.ChainID,
			&i.CircleState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPrimaryWalletsByWorkspaceID = `-- name: ListPrimaryWalletsByWorkspaceID :many
SELECT id, workspace_id, wallet_type, wallet_address, network_type, network_id, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE workspace_id = $1 AND is_primary = true AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListPrimaryWalletsByWorkspaceID(ctx context.Context, workspaceID uuid.UUID) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, listPrimaryWalletsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletType,
			&i.WalletAddress,
			&i.NetworkType,
			&i.NetworkID,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPrimaryWalletsWithCircleDataByWorkspaceID = `-- name: ListPrimaryWalletsWithCircleDataByWorkspaceID :many
SELECT 
    w.id, w.workspace_id, w.wallet_type, w.wallet_address, w.network_type, w.network_id, w.nickname, w.ens, w.is_primary, w.verified, w.last_used_at, w.metadata, w.created_at, w.updated_at, w.deleted_at,
    cw.id as circle_wallet_id,
    cw.circle_user_id,
    cw.circle_wallet_id as circle_id,
    cw.chain_id,
    cw.state as circle_state
FROM wallets w
LEFT JOIN circle_wallets cw ON w.id = cw.wallet_id AND w.wallet_type = 'circle_wallet'
WHERE w.workspace_id = $1 AND w.is_primary = true AND w.deleted_at IS NULL
ORDER BY w.created_at DESC
`

type ListPrimaryWalletsWithCircleDataByWorkspaceIDRow struct {
	ID             uuid.UUID          `json:"id"`
	WorkspaceID    uuid.UUID          `json:"workspace_id"`
	WalletType     string             `json:"wallet_type"`
	WalletAddress  string             `json:"wallet_address"`
	NetworkType    NetworkType        `json:"network_type"`
	NetworkID      pgtype.UUID        `json:"network_id"`
	Nickname       pgtype.Text        `json:"nickname"`
	Ens            pgtype.Text        `json:"ens"`
	IsPrimary      pgtype.Bool        `json:"is_primary"`
	Verified       pgtype.Bool        `json:"verified"`
	LastUsedAt     pgtype.Timestamptz `json:"last_used_at"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	CircleWalletID pgtype.UUID        `json:"circle_wallet_id"`
	CircleUserID   pgtype.UUID        `json:"circle_user_id"`
	CircleID       pgtype.Text        `json:"circle_id"`
	ChainID        pgtype.Int4        `json:"chain_id"`
	CircleState    pgtype.Text        `json:"circle_state"`
}

func (q *Queries) ListPrimaryWalletsWithCircleDataByWorkspaceID(ctx context.Context, workspaceID uuid.UUID) ([]ListPrimaryWalletsWithCircleDataByWorkspaceIDRow, error) {
	rows, err := q.db.Query(ctx, listPrimaryWalletsWithCircleDataByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPrimaryWalletsWithCircleDataByWorkspaceIDRow{}
	for rows.Next() {
		var i ListPrimaryWalletsWithCircleDataByWorkspaceIDRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletType,
			&i.WalletAddress,
			&i.NetworkType,
			&i.NetworkID,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CircleWalletID,
			&i.CircleUserID,
			&i.CircleID,
			&i.ChainID,
			&i.CircleState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWalletsByNetworkType = `-- name: ListWalletsByNetworkType :many
SELECT id, workspace_id, wallet_type, wallet_address, network_type, network_id, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE workspace_id = $1 AND network_type = $2 AND deleted_at IS NULL
ORDER BY created_at DESC
`

type ListWalletsByNetworkTypeParams struct {
	WorkspaceID uuid.UUID   `json:"workspace_id"`
	NetworkType NetworkType `json:"network_type"`
}

func (q *Queries) ListWalletsByNetworkType(ctx context.Context, arg ListWalletsByNetworkTypeParams) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, listWalletsByNetworkType, arg.WorkspaceID, arg.NetworkType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletType,
			&i.WalletAddress,
			&i.NetworkType,
			&i.NetworkID,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWalletsByWalletType = `-- name: ListWalletsByWalletType :many
SELECT id, workspace_id, wallet_type, wallet_address, network_type, network_id, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE workspace_id = $1 AND wallet_type = $2 AND deleted_at IS NULL
ORDER BY created_at DESC
`

type ListWalletsByWalletTypeParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	WalletType  string    `json:"wallet_type"`
}

func (q *Queries) ListWalletsByWalletType(ctx context.Context, arg ListWalletsByWalletTypeParams) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, listWalletsByWalletType, arg.WorkspaceID, arg.WalletType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletType,
			&i.WalletAddress,
			&i.NetworkType,
			&i.NetworkID,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWalletsByWorkspaceID = `-- name: ListWalletsByWorkspaceID :many
SELECT id, workspace_id, wallet_type, wallet_address, network_type, network_id, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE workspace_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListWalletsByWorkspaceID(ctx context.Context, workspaceID uuid.UUID) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, listWalletsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletType,
			&i.WalletAddress,
			&i.NetworkType,
			&i.NetworkID,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWalletsWithCircleDataByNetworkType = `-- name: ListWalletsWithCircleDataByNetworkType :many
SELECT 
    w.id, w.workspace_id, w.wallet_type, w.wallet_address, w.network_type, w.network_id, w.nickname, w.ens, w.is_primary, w.verified, w.last_used_at, w.metadata, w.created_at, w.updated_at, w.deleted_at,
    cw.id as circle_wallet_id,
    cw.circle_user_id,
    cw.circle_wallet_id as circle_id,
    cw.chain_id,
    cw.state as circle_state
FROM wallets w
LEFT JOIN circle_wallets cw ON w.id = cw.wallet_id AND w.wallet_type = 'circle_wallet'
WHERE w.workspace_id = $1 AND w.network_type = $2 AND w.deleted_at IS NULL
ORDER BY w.created_at DESC
`

type ListWalletsWithCircleDataByNetworkTypeParams struct {
	WorkspaceID uuid.UUID   `json:"workspace_id"`
	NetworkType NetworkType `json:"network_type"`
}

type ListWalletsWithCircleDataByNetworkTypeRow struct {
	ID             uuid.UUID          `json:"id"`
	WorkspaceID    uuid.UUID          `json:"workspace_id"`
	WalletType     string             `json:"wallet_type"`
	WalletAddress  string             `json:"wallet_address"`
	NetworkType    NetworkType        `json:"network_type"`
	NetworkID      pgtype.UUID        `json:"network_id"`
	Nickname       pgtype.Text        `json:"nickname"`
	Ens            pgtype.Text        `json:"ens"`
	IsPrimary      pgtype.Bool        `json:"is_primary"`
	Verified       pgtype.Bool        `json:"verified"`
	LastUsedAt     pgtype.Timestamptz `json:"last_used_at"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	CircleWalletID pgtype.UUID        `json:"circle_wallet_id"`
	CircleUserID   pgtype.UUID        `json:"circle_user_id"`
	CircleID       pgtype.Text        `json:"circle_id"`
	ChainID        pgtype.Int4        `json:"chain_id"`
	CircleState    pgtype.Text        `json:"circle_state"`
}

func (q *Queries) ListWalletsWithCircleDataByNetworkType(ctx context.Context, arg ListWalletsWithCircleDataByNetworkTypeParams) ([]ListWalletsWithCircleDataByNetworkTypeRow, error) {
	rows, err := q.db.Query(ctx, listWalletsWithCircleDataByNetworkType, arg.WorkspaceID, arg.NetworkType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWalletsWithCircleDataByNetworkTypeRow{}
	for rows.Next() {
		var i ListWalletsWithCircleDataByNetworkTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletType,
			&i.WalletAddress,
			&i.NetworkType,
			&i.NetworkID,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CircleWalletID,
			&i.CircleUserID,
			&i.CircleID,
			&i.ChainID,
			&i.CircleState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWalletsWithCircleDataByWorkspaceID = `-- name: ListWalletsWithCircleDataByWorkspaceID :many
SELECT 
    w.id, w.workspace_id, w.wallet_type, w.wallet_address, w.network_type, w.network_id, w.nickname, w.ens, w.is_primary, w.verified, w.last_used_at, w.metadata, w.created_at, w.updated_at, w.deleted_at,
    cw.id as circle_wallet_id,
    cw.circle_user_id,
    cw.circle_wallet_id as circle_id,
    cw.chain_id,
    cw.state as circle_state
FROM wallets w
LEFT JOIN circle_wallets cw ON w.id = cw.wallet_id AND w.wallet_type = 'circle_wallet'
WHERE w.workspace_id = $1 AND w.deleted_at IS NULL
ORDER BY w.created_at DESC
`

type ListWalletsWithCircleDataByWorkspaceIDRow struct {
	ID             uuid.UUID          `json:"id"`
	WorkspaceID    uuid.UUID          `json:"workspace_id"`
	WalletType     string             `json:"wallet_type"`
	WalletAddress  string             `json:"wallet_address"`
	NetworkType    NetworkType        `json:"network_type"`
	NetworkID      pgtype.UUID        `json:"network_id"`
	Nickname       pgtype.Text        `json:"nickname"`
	Ens            pgtype.Text        `json:"ens"`
	IsPrimary      pgtype.Bool        `json:"is_primary"`
	Verified       pgtype.Bool        `json:"verified"`
	LastUsedAt     pgtype.Timestamptz `json:"last_used_at"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	CircleWalletID pgtype.UUID        `json:"circle_wallet_id"`
	CircleUserID   pgtype.UUID        `json:"circle_user_id"`
	CircleID       pgtype.Text        `json:"circle_id"`
	ChainID        pgtype.Int4        `json:"chain_id"`
	CircleState    pgtype.Text        `json:"circle_state"`
}

func (q *Queries) ListWalletsWithCircleDataByWorkspaceID(ctx context.Context, workspaceID uuid.UUID) ([]ListWalletsWithCircleDataByWorkspaceIDRow, error) {
	rows, err := q.db.Query(ctx, listWalletsWithCircleDataByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWalletsWithCircleDataByWorkspaceIDRow{}
	for rows.Next() {
		var i ListWalletsWithCircleDataByWorkspaceIDRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletType,
			&i.WalletAddress,
			&i.NetworkType,
			&i.NetworkID,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CircleWalletID,
			&i.CircleUserID,
			&i.CircleID,
			&i.ChainID,
			&i.CircleState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchWallets = `-- name: SearchWallets :many
SELECT id, workspace_id, wallet_type, wallet_address, network_type, network_id, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at FROM wallets
WHERE workspace_id = $1
AND deleted_at IS NULL
AND (
    wallet_address ILIKE $2 
    OR nickname ILIKE $2 
    OR ens ILIKE $2
)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type SearchWalletsParams struct {
	WorkspaceID   uuid.UUID `json:"workspace_id"`
	WalletAddress string    `json:"wallet_address"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
}

func (q *Queries) SearchWallets(ctx context.Context, arg SearchWalletsParams) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, searchWallets,
		arg.WorkspaceID,
		arg.WalletAddress,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletType,
			&i.WalletAddress,
			&i.NetworkType,
			&i.NetworkID,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchWalletsWithCircleData = `-- name: SearchWalletsWithCircleData :many
SELECT 
    w.id, w.workspace_id, w.wallet_type, w.wallet_address, w.network_type, w.network_id, w.nickname, w.ens, w.is_primary, w.verified, w.last_used_at, w.metadata, w.created_at, w.updated_at, w.deleted_at,
    cw.id as circle_wallet_id,
    cw.circle_user_id,
    cw.circle_wallet_id as circle_id,
    cw.chain_id,
    cw.state as circle_state
FROM wallets w
LEFT JOIN circle_wallets cw ON w.id = cw.wallet_id AND w.wallet_type = 'circle_wallet'
WHERE w.workspace_id = $1
AND w.deleted_at IS NULL
AND (
    w.wallet_address ILIKE $2 
    OR w.nickname ILIKE $2 
    OR w.ens ILIKE $2
    OR cw.circle_wallet_id ILIKE $2
)
ORDER BY w.created_at DESC
LIMIT $3 OFFSET $4
`

type SearchWalletsWithCircleDataParams struct {
	WorkspaceID   uuid.UUID `json:"workspace_id"`
	WalletAddress string    `json:"wallet_address"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
}

type SearchWalletsWithCircleDataRow struct {
	ID             uuid.UUID          `json:"id"`
	WorkspaceID    uuid.UUID          `json:"workspace_id"`
	WalletType     string             `json:"wallet_type"`
	WalletAddress  string             `json:"wallet_address"`
	NetworkType    NetworkType        `json:"network_type"`
	NetworkID      pgtype.UUID        `json:"network_id"`
	Nickname       pgtype.Text        `json:"nickname"`
	Ens            pgtype.Text        `json:"ens"`
	IsPrimary      pgtype.Bool        `json:"is_primary"`
	Verified       pgtype.Bool        `json:"verified"`
	LastUsedAt     pgtype.Timestamptz `json:"last_used_at"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	CircleWalletID pgtype.UUID        `json:"circle_wallet_id"`
	CircleUserID   pgtype.UUID        `json:"circle_user_id"`
	CircleID       pgtype.Text        `json:"circle_id"`
	ChainID        pgtype.Int4        `json:"chain_id"`
	CircleState    pgtype.Text        `json:"circle_state"`
}

func (q *Queries) SearchWalletsWithCircleData(ctx context.Context, arg SearchWalletsWithCircleDataParams) ([]SearchWalletsWithCircleDataRow, error) {
	rows, err := q.db.Query(ctx, searchWalletsWithCircleData,
		arg.WorkspaceID,
		arg.WalletAddress,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchWalletsWithCircleDataRow{}
	for rows.Next() {
		var i SearchWalletsWithCircleDataRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WalletType,
			&i.WalletAddress,
			&i.NetworkType,
			&i.NetworkID,
			&i.Nickname,
			&i.Ens,
			&i.IsPrimary,
			&i.Verified,
			&i.LastUsedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CircleWalletID,
			&i.CircleUserID,
			&i.CircleID,
			&i.ChainID,
			&i.CircleState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setWalletAsPrimary = `-- name: SetWalletAsPrimary :execrows
WITH updated_wallets AS (
    UPDATE wallets w
    SET is_primary = false
    WHERE w.workspace_id = $1
    AND w.network_type = $2 
    AND w.is_primary = true 
    AND w.deleted_at IS NULL
)
UPDATE wallets w
SET 
    is_primary = true,
    updated_at = CURRENT_TIMESTAMP
WHERE w.id = $3 AND w.deleted_at IS NULL
`

type SetWalletAsPrimaryParams struct {
	WorkspaceID uuid.UUID   `json:"workspace_id"`
	NetworkType NetworkType `json:"network_type"`
	ID          uuid.UUID   `json:"id"`
}

func (q *Queries) SetWalletAsPrimary(ctx context.Context, arg SetWalletAsPrimaryParams) (int64, error) {
	result, err := q.db.Exec(ctx, setWalletAsPrimary, arg.WorkspaceID, arg.NetworkType, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const softDeleteWallet = `-- name: SoftDeleteWallet :exec
UPDATE wallets
SET 
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteWallet(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteWallet, id)
	return err
}

const updateCircleWalletState = `-- name: UpdateCircleWalletState :one
UPDATE circle_wallets
SET 
    state = $1,
    updated_at = CURRENT_TIMESTAMP
WHERE wallet_id = $2 AND deleted_at IS NULL
RETURNING id, wallet_id, circle_user_id, circle_wallet_id, chain_id, state, created_at, updated_at, deleted_at
`

type UpdateCircleWalletStateParams struct {
	State    string    `json:"state"`
	WalletID uuid.UUID `json:"wallet_id"`
}

func (q *Queries) UpdateCircleWalletState(ctx context.Context, arg UpdateCircleWalletStateParams) (CircleWallet, error) {
	row := q.db.QueryRow(ctx, updateCircleWalletState, arg.State, arg.WalletID)
	var i CircleWallet
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.CircleUserID,
		&i.CircleWalletID,
		&i.ChainID,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateWallet = `-- name: UpdateWallet :one
UPDATE wallets
SET 
    nickname = COALESCE($1, nickname),
    ens = COALESCE($2, ens),
    is_primary = COALESCE($3, is_primary),
    verified = COALESCE($4, verified),
    metadata = COALESCE($5, metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $6 AND deleted_at IS NULL
RETURNING id, workspace_id, wallet_type, wallet_address, network_type, network_id, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at
`

type UpdateWalletParams struct {
	Nickname  pgtype.Text `json:"nickname"`
	Ens       pgtype.Text `json:"ens"`
	IsPrimary pgtype.Bool `json:"is_primary"`
	Verified  pgtype.Bool `json:"verified"`
	Metadata  []byte      `json:"metadata"`
	ID        uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateWallet(ctx context.Context, arg UpdateWalletParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, updateWallet,
		arg.Nickname,
		arg.Ens,
		arg.IsPrimary,
		arg.Verified,
		arg.Metadata,
		arg.ID,
	)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.WalletType,
		&i.WalletAddress,
		&i.NetworkType,
		&i.NetworkID,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateWalletLastUsed = `-- name: UpdateWalletLastUsed :exec
UPDATE wallets
SET 
    last_used_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) UpdateWalletLastUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateWalletLastUsed, id)
	return err
}

const updateWalletVerificationStatus = `-- name: UpdateWalletVerificationStatus :one
UPDATE wallets
SET 
    verified = $1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $2 AND deleted_at IS NULL
RETURNING id, workspace_id, wallet_type, wallet_address, network_type, network_id, nickname, ens, is_primary, verified, last_used_at, metadata, created_at, updated_at, deleted_at
`

type UpdateWalletVerificationStatusParams struct {
	Verified pgtype.Bool `json:"verified"`
	ID       uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateWalletVerificationStatus(ctx context.Context, arg UpdateWalletVerificationStatusParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, updateWalletVerificationStatus, arg.Verified, arg.ID)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.WalletType,
		&i.WalletAddress,
		&i.NetworkType,
		&i.NetworkID,
		&i.Nickname,
		&i.Ens,
		&i.IsPrimary,
		&i.Verified,
		&i.LastUsedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
