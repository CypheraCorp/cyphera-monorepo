// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: workspace.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countWorkspaceCustomers = `-- name: CountWorkspaceCustomers :one
SELECT COUNT(*) FROM customers
WHERE workspace_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountWorkspaceCustomers(ctx context.Context, workspaceID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countWorkspaceCustomers, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWorkspace = `-- name: CreateWorkspace :one
INSERT INTO workspaces (
    account_id,
    name,
    description,
    business_name,
    business_type,
    website_url,
    support_email,
    support_phone,
    metadata,
    livemode
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, account_id, name, description, business_name, business_type, website_url, support_email, support_phone, metadata, livemode, created_at, updated_at, deleted_at
`

type CreateWorkspaceParams struct {
	AccountID    uuid.UUID   `json:"account_id"`
	Name         string      `json:"name"`
	Description  pgtype.Text `json:"description"`
	BusinessName pgtype.Text `json:"business_name"`
	BusinessType pgtype.Text `json:"business_type"`
	WebsiteUrl   pgtype.Text `json:"website_url"`
	SupportEmail pgtype.Text `json:"support_email"`
	SupportPhone pgtype.Text `json:"support_phone"`
	Metadata     []byte      `json:"metadata"`
	Livemode     pgtype.Bool `json:"livemode"`
}

func (q *Queries) CreateWorkspace(ctx context.Context, arg CreateWorkspaceParams) (Workspace, error) {
	row := q.db.QueryRow(ctx, createWorkspace,
		arg.AccountID,
		arg.Name,
		arg.Description,
		arg.BusinessName,
		arg.BusinessType,
		arg.WebsiteUrl,
		arg.SupportEmail,
		arg.SupportPhone,
		arg.Metadata,
		arg.Livemode,
	)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Name,
		&i.Description,
		&i.BusinessName,
		&i.BusinessType,
		&i.WebsiteUrl,
		&i.SupportEmail,
		&i.SupportPhone,
		&i.Metadata,
		&i.Livemode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteWorkspace = `-- name: DeleteWorkspace :exec
UPDATE workspaces
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteWorkspace(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWorkspace, id)
	return err
}

const getAccountByWorkspaceID = `-- name: GetAccountByWorkspaceID :one
SELECT a.id, a.name, a.account_type, a.business_name, a.business_type, a.website_url, a.support_email, a.support_phone, a.metadata, a.finished_onboarding, a.created_at, a.updated_at, a.deleted_at FROM accounts a
JOIN workspaces w ON w.account_id = a.id
WHERE w.id = $1 
AND w.deleted_at IS NULL 
AND a.deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetAccountByWorkspaceID(ctx context.Context, id uuid.UUID) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByWorkspaceID, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AccountType,
		&i.BusinessName,
		&i.BusinessType,
		&i.WebsiteUrl,
		&i.SupportEmail,
		&i.SupportPhone,
		&i.Metadata,
		&i.FinishedOnboarding,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAllWorkspaces = `-- name: GetAllWorkspaces :many
SELECT id, account_id, name, description, business_name, business_type, website_url, support_email, support_phone, metadata, livemode, created_at, updated_at, deleted_at FROM workspaces
ORDER BY created_at DESC
`

func (q *Queries) GetAllWorkspaces(ctx context.Context) ([]Workspace, error) {
	rows, err := q.db.Query(ctx, getAllWorkspaces)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workspace{}
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Name,
			&i.Description,
			&i.BusinessName,
			&i.BusinessType,
			&i.WebsiteUrl,
			&i.SupportEmail,
			&i.SupportPhone,
			&i.Metadata,
			&i.Livemode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspace = `-- name: GetWorkspace :one
SELECT id, account_id, name, description, business_name, business_type, website_url, support_email, support_phone, metadata, livemode, created_at, updated_at, deleted_at FROM workspaces
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetWorkspace(ctx context.Context, id uuid.UUID) (Workspace, error) {
	row := q.db.QueryRow(ctx, getWorkspace, id)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Name,
		&i.Description,
		&i.BusinessName,
		&i.BusinessType,
		&i.WebsiteUrl,
		&i.SupportEmail,
		&i.SupportPhone,
		&i.Metadata,
		&i.Livemode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const hardDeleteWorkspace = `-- name: HardDeleteWorkspace :exec
DELETE FROM workspaces
WHERE id = $1
`

func (q *Queries) HardDeleteWorkspace(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteWorkspace, id)
	return err
}

const listWorkspaceCustomers = `-- name: ListWorkspaceCustomers :many
SELECT c.id, c.workspace_id, c.external_id, c.email, c.name, c.phone, c.description, c.balance, c.currency, c.default_source_id, c.invoice_prefix, c.next_invoice_sequence, c.tax_exempt, c.tax_ids, c.metadata, c.livemode, c.created_at, c.updated_at, c.deleted_at FROM customers c
INNER JOIN workspaces w ON c.workspace_id = w.id
WHERE w.id = $1 AND c.deleted_at IS NULL
ORDER BY c.created_at DESC
`

func (q *Queries) ListWorkspaceCustomers(ctx context.Context, id uuid.UUID) ([]Customer, error) {
	rows, err := q.db.Query(ctx, listWorkspaceCustomers, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ExternalID,
			&i.Email,
			&i.Name,
			&i.Phone,
			&i.Description,
			&i.Balance,
			&i.Currency,
			&i.DefaultSourceID,
			&i.InvoicePrefix,
			&i.NextInvoiceSequence,
			&i.TaxExempt,
			&i.TaxIds,
			&i.Metadata,
			&i.Livemode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkspaceCustomersWithPagination = `-- name: ListWorkspaceCustomersWithPagination :many
SELECT 
    c.id, c.workspace_id, c.external_id, c.email, c.name, c.phone, c.description, c.balance, c.currency, c.default_source_id, c.invoice_prefix, c.next_invoice_sequence, c.tax_exempt, c.tax_ids, c.metadata, c.livemode, c.created_at, c.updated_at, c.deleted_at,
    w.name as workspace_name
FROM customers c
JOIN workspaces w ON c.workspace_id = w.id
WHERE c.workspace_id = $1 AND c.deleted_at IS NULL
ORDER BY c.created_at DESC
LIMIT $2 OFFSET $3
`

type ListWorkspaceCustomersWithPaginationParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type ListWorkspaceCustomersWithPaginationRow struct {
	ID                  uuid.UUID          `json:"id"`
	WorkspaceID         uuid.UUID          `json:"workspace_id"`
	ExternalID          pgtype.Text        `json:"external_id"`
	Email               pgtype.Text        `json:"email"`
	Name                pgtype.Text        `json:"name"`
	Phone               pgtype.Text        `json:"phone"`
	Description         pgtype.Text        `json:"description"`
	Balance             pgtype.Int4        `json:"balance"`
	Currency            pgtype.Text        `json:"currency"`
	DefaultSourceID     pgtype.UUID        `json:"default_source_id"`
	InvoicePrefix       pgtype.Text        `json:"invoice_prefix"`
	NextInvoiceSequence pgtype.Int4        `json:"next_invoice_sequence"`
	TaxExempt           pgtype.Bool        `json:"tax_exempt"`
	TaxIds              []byte             `json:"tax_ids"`
	Metadata            []byte             `json:"metadata"`
	Livemode            pgtype.Bool        `json:"livemode"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	DeletedAt           pgtype.Timestamptz `json:"deleted_at"`
	WorkspaceName       string             `json:"workspace_name"`
}

func (q *Queries) ListWorkspaceCustomersWithPagination(ctx context.Context, arg ListWorkspaceCustomersWithPaginationParams) ([]ListWorkspaceCustomersWithPaginationRow, error) {
	rows, err := q.db.Query(ctx, listWorkspaceCustomersWithPagination, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWorkspaceCustomersWithPaginationRow{}
	for rows.Next() {
		var i ListWorkspaceCustomersWithPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ExternalID,
			&i.Email,
			&i.Name,
			&i.Phone,
			&i.Description,
			&i.Balance,
			&i.Currency,
			&i.DefaultSourceID,
			&i.InvoicePrefix,
			&i.NextInvoiceSequence,
			&i.TaxExempt,
			&i.TaxIds,
			&i.Metadata,
			&i.Livemode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.WorkspaceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkspaces = `-- name: ListWorkspaces :many
SELECT id, account_id, name, description, business_name, business_type, website_url, support_email, support_phone, metadata, livemode, created_at, updated_at, deleted_at FROM workspaces
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListWorkspaces(ctx context.Context) ([]Workspace, error) {
	rows, err := q.db.Query(ctx, listWorkspaces)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workspace{}
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Name,
			&i.Description,
			&i.BusinessName,
			&i.BusinessType,
			&i.WebsiteUrl,
			&i.SupportEmail,
			&i.SupportPhone,
			&i.Metadata,
			&i.Livemode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkspacesByAccountID = `-- name: ListWorkspacesByAccountID :many
SELECT id, account_id, name, description, business_name, business_type, website_url, support_email, support_phone, metadata, livemode, created_at, updated_at, deleted_at FROM workspaces
WHERE account_id = $1 
AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListWorkspacesByAccountID(ctx context.Context, accountID uuid.UUID) ([]Workspace, error) {
	rows, err := q.db.Query(ctx, listWorkspacesByAccountID, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workspace{}
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Name,
			&i.Description,
			&i.BusinessName,
			&i.BusinessType,
			&i.WebsiteUrl,
			&i.SupportEmail,
			&i.SupportPhone,
			&i.Metadata,
			&i.Livemode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWorkspace = `-- name: UpdateWorkspace :one
UPDATE workspaces
SET
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    business_name = COALESCE($4, business_name),
    business_type = COALESCE($5, business_type),
    website_url = COALESCE($6, website_url),
    support_email = COALESCE($7, support_email),
    support_phone = COALESCE($8, support_phone),
    metadata = COALESCE($9, metadata),
    livemode = COALESCE($10, livemode),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, account_id, name, description, business_name, business_type, website_url, support_email, support_phone, metadata, livemode, created_at, updated_at, deleted_at
`

type UpdateWorkspaceParams struct {
	ID           uuid.UUID   `json:"id"`
	Name         string      `json:"name"`
	Description  pgtype.Text `json:"description"`
	BusinessName pgtype.Text `json:"business_name"`
	BusinessType pgtype.Text `json:"business_type"`
	WebsiteUrl   pgtype.Text `json:"website_url"`
	SupportEmail pgtype.Text `json:"support_email"`
	SupportPhone pgtype.Text `json:"support_phone"`
	Metadata     []byte      `json:"metadata"`
	Livemode     pgtype.Bool `json:"livemode"`
}

func (q *Queries) UpdateWorkspace(ctx context.Context, arg UpdateWorkspaceParams) (Workspace, error) {
	row := q.db.QueryRow(ctx, updateWorkspace,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.BusinessName,
		arg.BusinessType,
		arg.WebsiteUrl,
		arg.SupportEmail,
		arg.SupportPhone,
		arg.Metadata,
		arg.Livemode,
	)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Name,
		&i.Description,
		&i.BusinessName,
		&i.BusinessType,
		&i.WebsiteUrl,
		&i.SupportEmail,
		&i.SupportPhone,
		&i.Metadata,
		&i.Livemode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
