// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: workspace_customers.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addCustomerToWorkspace = `-- name: AddCustomerToWorkspace :one
INSERT INTO workspace_customers (
    workspace_id,
    customer_id
) VALUES (
    $1, $2
)
ON CONFLICT (workspace_id, customer_id) 
DO UPDATE SET 
    deleted_at = NULL,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, workspace_id, customer_id, created_at, updated_at, deleted_at
`

type AddCustomerToWorkspaceParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	CustomerID  uuid.UUID `json:"customer_id"`
}

func (q *Queries) AddCustomerToWorkspace(ctx context.Context, arg AddCustomerToWorkspaceParams) (WorkspaceCustomer, error) {
	row := q.db.QueryRow(ctx, addCustomerToWorkspace, arg.WorkspaceID, arg.CustomerID)
	var i WorkspaceCustomer
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const countWorkspaceCustomers = `-- name: CountWorkspaceCustomers :one
SELECT COUNT(*)
FROM customers c
INNER JOIN workspace_customers wc ON c.id = wc.customer_id
WHERE wc.workspace_id = $1 AND wc.deleted_at IS NULL AND c.deleted_at IS NULL
`

func (q *Queries) CountWorkspaceCustomers(ctx context.Context, workspaceID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countWorkspaceCustomers, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getWorkspaceCustomerAssociation = `-- name: GetWorkspaceCustomerAssociation :one
SELECT id, workspace_id, customer_id, created_at, updated_at, deleted_at
FROM workspace_customers
WHERE workspace_id = $1 AND customer_id = $2 AND deleted_at IS NULL
LIMIT 1
`

type GetWorkspaceCustomerAssociationParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	CustomerID  uuid.UUID `json:"customer_id"`
}

func (q *Queries) GetWorkspaceCustomerAssociation(ctx context.Context, arg GetWorkspaceCustomerAssociationParams) (WorkspaceCustomer, error) {
	row := q.db.QueryRow(ctx, getWorkspaceCustomerAssociation, arg.WorkspaceID, arg.CustomerID)
	var i WorkspaceCustomer
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const isCustomerInWorkspace = `-- name: IsCustomerInWorkspace :one
SELECT EXISTS(
    SELECT 1 FROM workspace_customers 
    WHERE workspace_id = $1 AND customer_id = $2 AND deleted_at IS NULL
)
`

type IsCustomerInWorkspaceParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	CustomerID  uuid.UUID `json:"customer_id"`
}

func (q *Queries) IsCustomerInWorkspace(ctx context.Context, arg IsCustomerInWorkspaceParams) (bool, error) {
	row := q.db.QueryRow(ctx, isCustomerInWorkspace, arg.WorkspaceID, arg.CustomerID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listCustomerWorkspaces = `-- name: ListCustomerWorkspaces :many
SELECT 
    w.id, w.account_id, w.name, w.description, w.business_name, w.business_type, w.website_url, w.support_email, w.support_phone, w.metadata, w.livemode, w.created_at, w.updated_at, w.deleted_at
FROM workspaces w
INNER JOIN workspace_customers wc ON w.id = wc.workspace_id
WHERE wc.customer_id = $1 AND wc.deleted_at IS NULL AND w.deleted_at IS NULL
ORDER BY w.created_at DESC
`

func (q *Queries) ListCustomerWorkspaces(ctx context.Context, customerID uuid.UUID) ([]Workspace, error) {
	rows, err := q.db.Query(ctx, listCustomerWorkspaces, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workspace{}
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Name,
			&i.Description,
			&i.BusinessName,
			&i.BusinessType,
			&i.WebsiteUrl,
			&i.SupportEmail,
			&i.SupportPhone,
			&i.Metadata,
			&i.Livemode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkspaceCustomers = `-- name: ListWorkspaceCustomers :many
SELECT 
    c.id, c.web3auth_id, c.external_id, c.email, c.name, c.phone, c.description, c.metadata, c.finished_onboarding, c.payment_sync_status, c.payment_synced_at, c.payment_sync_version, c.payment_provider, c.created_at, c.updated_at, c.deleted_at
FROM customers c
INNER JOIN workspace_customers wc ON c.id = wc.customer_id
WHERE wc.workspace_id = $1 AND wc.deleted_at IS NULL AND c.deleted_at IS NULL
ORDER BY c.created_at DESC
`

func (q *Queries) ListWorkspaceCustomers(ctx context.Context, workspaceID uuid.UUID) ([]Customer, error) {
	rows, err := q.db.Query(ctx, listWorkspaceCustomers, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Web3authID,
			&i.ExternalID,
			&i.Email,
			&i.Name,
			&i.Phone,
			&i.Description,
			&i.Metadata,
			&i.FinishedOnboarding,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkspaceCustomersWithInfo = `-- name: ListWorkspaceCustomersWithInfo :many
SELECT 
    c.id, c.web3auth_id, c.external_id, c.email, c.name, c.phone, c.description, c.metadata, c.finished_onboarding, c.payment_sync_status, c.payment_synced_at, c.payment_sync_version, c.payment_provider, c.created_at, c.updated_at, c.deleted_at,
    w.name as workspace_name,
    w.business_name as workspace_business_name,
    w.support_email as workspace_support_email,
    wc.created_at as association_created_at
FROM customers c
INNER JOIN workspace_customers wc ON c.id = wc.customer_id
INNER JOIN workspaces w ON wc.workspace_id = w.id
WHERE wc.workspace_id = $1 AND wc.deleted_at IS NULL AND c.deleted_at IS NULL AND w.deleted_at IS NULL
ORDER BY c.created_at DESC
`

type ListWorkspaceCustomersWithInfoRow struct {
	ID                    uuid.UUID          `json:"id"`
	Web3authID            pgtype.Text        `json:"web3auth_id"`
	ExternalID            pgtype.Text        `json:"external_id"`
	Email                 pgtype.Text        `json:"email"`
	Name                  pgtype.Text        `json:"name"`
	Phone                 pgtype.Text        `json:"phone"`
	Description           pgtype.Text        `json:"description"`
	Metadata              []byte             `json:"metadata"`
	FinishedOnboarding    pgtype.Bool        `json:"finished_onboarding"`
	PaymentSyncStatus     pgtype.Text        `json:"payment_sync_status"`
	PaymentSyncedAt       pgtype.Timestamptz `json:"payment_synced_at"`
	PaymentSyncVersion    pgtype.Int4        `json:"payment_sync_version"`
	PaymentProvider       pgtype.Text        `json:"payment_provider"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	DeletedAt             pgtype.Timestamptz `json:"deleted_at"`
	WorkspaceName         string             `json:"workspace_name"`
	WorkspaceBusinessName pgtype.Text        `json:"workspace_business_name"`
	WorkspaceSupportEmail pgtype.Text        `json:"workspace_support_email"`
	AssociationCreatedAt  pgtype.Timestamptz `json:"association_created_at"`
}

func (q *Queries) ListWorkspaceCustomersWithInfo(ctx context.Context, workspaceID uuid.UUID) ([]ListWorkspaceCustomersWithInfoRow, error) {
	rows, err := q.db.Query(ctx, listWorkspaceCustomersWithInfo, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWorkspaceCustomersWithInfoRow{}
	for rows.Next() {
		var i ListWorkspaceCustomersWithInfoRow
		if err := rows.Scan(
			&i.ID,
			&i.Web3authID,
			&i.ExternalID,
			&i.Email,
			&i.Name,
			&i.Phone,
			&i.Description,
			&i.Metadata,
			&i.FinishedOnboarding,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.WorkspaceName,
			&i.WorkspaceBusinessName,
			&i.WorkspaceSupportEmail,
			&i.AssociationCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkspaceCustomersWithPagination = `-- name: ListWorkspaceCustomersWithPagination :many
SELECT 
    c.id, c.web3auth_id, c.external_id, c.email, c.name, c.phone, c.description, c.metadata, c.finished_onboarding, c.payment_sync_status, c.payment_synced_at, c.payment_sync_version, c.payment_provider, c.created_at, c.updated_at, c.deleted_at
FROM customers c
INNER JOIN workspace_customers wc ON c.id = wc.customer_id
WHERE wc.workspace_id = $1 AND wc.deleted_at IS NULL AND c.deleted_at IS NULL
ORDER BY c.created_at DESC
LIMIT $2 OFFSET $3
`

type ListWorkspaceCustomersWithPaginationParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListWorkspaceCustomersWithPagination(ctx context.Context, arg ListWorkspaceCustomersWithPaginationParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, listWorkspaceCustomersWithPagination, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Web3authID,
			&i.ExternalID,
			&i.Email,
			&i.Name,
			&i.Phone,
			&i.Description,
			&i.Metadata,
			&i.FinishedOnboarding,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCustomerFromWorkspace = `-- name: RemoveCustomerFromWorkspace :exec
UPDATE workspace_customers 
SET deleted_at = CURRENT_TIMESTAMP
WHERE workspace_id = $1 AND customer_id = $2 AND deleted_at IS NULL
`

type RemoveCustomerFromWorkspaceParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	CustomerID  uuid.UUID `json:"customer_id"`
}

func (q *Queries) RemoveCustomerFromWorkspace(ctx context.Context, arg RemoveCustomerFromWorkspaceParams) error {
	_, err := q.db.Exec(ctx, removeCustomerFromWorkspace, arg.WorkspaceID, arg.CustomerID)
	return err
}
