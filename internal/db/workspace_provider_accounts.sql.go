// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: workspace_provider_accounts.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countProviderAccountsByProvider = `-- name: CountProviderAccountsByProvider :one
SELECT COUNT(*) FROM workspace_provider_accounts
WHERE provider_name = $1
  AND is_active = true
  AND deleted_at IS NULL
`

func (q *Queries) CountProviderAccountsByProvider(ctx context.Context, providerName string) (int64, error) {
	row := q.db.QueryRow(ctx, countProviderAccountsByProvider, providerName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProviderAccountsByWorkspace = `-- name: CountProviderAccountsByWorkspace :one
SELECT COUNT(*) FROM workspace_provider_accounts
WHERE workspace_id = $1 
  AND is_active = true
  AND deleted_at IS NULL
`

func (q *Queries) CountProviderAccountsByWorkspace(ctx context.Context, workspaceID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProviderAccountsByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWorkspaceProviderAccount = `-- name: CreateWorkspaceProviderAccount :one

INSERT INTO workspace_provider_accounts (
    workspace_id, 
    provider_name,
    provider_account_id, 
    account_type, 
    is_active,
    environment,
    display_name,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, workspace_id, provider_name, provider_account_id, account_type, is_active, environment, display_name, metadata, created_at, updated_at, deleted_at
`

type CreateWorkspaceProviderAccountParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	ProviderName      string      `json:"provider_name"`
	ProviderAccountID string      `json:"provider_account_id"`
	AccountType       string      `json:"account_type"`
	IsActive          bool        `json:"is_active"`
	Environment       string      `json:"environment"`
	DisplayName       pgtype.Text `json:"display_name"`
	Metadata          []byte      `json:"metadata"`
}

// workspace_provider_accounts.sql
// SQLC queries for generic provider account mapping (Stripe, Chargebee, PayPal, etc.)
func (q *Queries) CreateWorkspaceProviderAccount(ctx context.Context, arg CreateWorkspaceProviderAccountParams) (WorkspaceProviderAccount, error) {
	row := q.db.QueryRow(ctx, createWorkspaceProviderAccount,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.ProviderAccountID,
		arg.AccountType,
		arg.IsActive,
		arg.Environment,
		arg.DisplayName,
		arg.Metadata,
	)
	var i WorkspaceProviderAccount
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.ProviderAccountID,
		&i.AccountType,
		&i.IsActive,
		&i.Environment,
		&i.DisplayName,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deactivateWorkspaceProviderAccount = `-- name: DeactivateWorkspaceProviderAccount :one
UPDATE workspace_provider_accounts
SET 
    is_active = false,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
  AND workspace_id = $2
  AND deleted_at IS NULL
RETURNING id, workspace_id, provider_name, provider_account_id, account_type, is_active, environment, display_name, metadata, created_at, updated_at, deleted_at
`

type DeactivateWorkspaceProviderAccountParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) DeactivateWorkspaceProviderAccount(ctx context.Context, arg DeactivateWorkspaceProviderAccountParams) (WorkspaceProviderAccount, error) {
	row := q.db.QueryRow(ctx, deactivateWorkspaceProviderAccount, arg.ID, arg.WorkspaceID)
	var i WorkspaceProviderAccount
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.ProviderAccountID,
		&i.AccountType,
		&i.IsActive,
		&i.Environment,
		&i.DisplayName,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteWorkspaceProviderAccount = `-- name: DeleteWorkspaceProviderAccount :exec
UPDATE workspace_provider_accounts
SET 
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
  AND workspace_id = $2
  AND deleted_at IS NULL
`

type DeleteWorkspaceProviderAccountParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) DeleteWorkspaceProviderAccount(ctx context.Context, arg DeleteWorkspaceProviderAccountParams) error {
	_, err := q.db.Exec(ctx, deleteWorkspaceProviderAccount, arg.ID, arg.WorkspaceID)
	return err
}

const getProviderAccountByID = `-- name: GetProviderAccountByID :one
SELECT id, workspace_id, provider_name, provider_account_id, account_type, is_active, environment, display_name, metadata, created_at, updated_at, deleted_at FROM workspace_provider_accounts
WHERE id = $1 
  AND workspace_id = $2
  AND deleted_at IS NULL
`

type GetProviderAccountByIDParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) GetProviderAccountByID(ctx context.Context, arg GetProviderAccountByIDParams) (WorkspaceProviderAccount, error) {
	row := q.db.QueryRow(ctx, getProviderAccountByID, arg.ID, arg.WorkspaceID)
	var i WorkspaceProviderAccount
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.ProviderAccountID,
		&i.AccountType,
		&i.IsActive,
		&i.Environment,
		&i.DisplayName,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProviderAccountByWorkspace = `-- name: GetProviderAccountByWorkspace :one
SELECT id, workspace_id, provider_name, provider_account_id, account_type, is_active, environment, display_name, metadata, created_at, updated_at, deleted_at FROM workspace_provider_accounts
WHERE workspace_id = $1 
  AND provider_name = $2
  AND is_active = true
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT 1
`

type GetProviderAccountByWorkspaceParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
}

// Get a specific provider account for a workspace
func (q *Queries) GetProviderAccountByWorkspace(ctx context.Context, arg GetProviderAccountByWorkspaceParams) (WorkspaceProviderAccount, error) {
	row := q.db.QueryRow(ctx, getProviderAccountByWorkspace, arg.WorkspaceID, arg.ProviderName)
	var i WorkspaceProviderAccount
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.ProviderAccountID,
		&i.AccountType,
		&i.IsActive,
		&i.Environment,
		&i.DisplayName,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getWorkspaceByProviderAccount = `-- name: GetWorkspaceByProviderAccount :one
SELECT 
    workspace_id, 
    provider_name,
    account_type,
    environment,
    display_name
FROM workspace_provider_accounts
WHERE provider_name = $1 
  AND provider_account_id = $2 
  AND environment = $3
  AND is_active = true
  AND deleted_at IS NULL
`

type GetWorkspaceByProviderAccountParams struct {
	ProviderName      string `json:"provider_name"`
	ProviderAccountID string `json:"provider_account_id"`
	Environment       string `json:"environment"`
}

type GetWorkspaceByProviderAccountRow struct {
	WorkspaceID  uuid.UUID   `json:"workspace_id"`
	ProviderName string      `json:"provider_name"`
	AccountType  string      `json:"account_type"`
	Environment  string      `json:"environment"`
	DisplayName  pgtype.Text `json:"display_name"`
}

// Critical query for webhook routing - maps provider account ID to workspace
func (q *Queries) GetWorkspaceByProviderAccount(ctx context.Context, arg GetWorkspaceByProviderAccountParams) (GetWorkspaceByProviderAccountRow, error) {
	row := q.db.QueryRow(ctx, getWorkspaceByProviderAccount, arg.ProviderName, arg.ProviderAccountID, arg.Environment)
	var i GetWorkspaceByProviderAccountRow
	err := row.Scan(
		&i.WorkspaceID,
		&i.ProviderName,
		&i.AccountType,
		&i.Environment,
		&i.DisplayName,
	)
	return i, err
}

const getWorkspaceProviderAccountForWebhook = `-- name: GetWorkspaceProviderAccountForWebhook :one
SELECT 
    wpa.id, wpa.workspace_id, wpa.provider_name, wpa.provider_account_id, wpa.account_type, wpa.is_active, wpa.environment, wpa.display_name, wpa.metadata, wpa.created_at, wpa.updated_at, wpa.deleted_at,
    w.name as workspace_name,
    w.livemode as workspace_livemode
FROM workspace_provider_accounts wpa
JOIN workspaces w ON w.id = wpa.workspace_id
WHERE wpa.provider_name = $1 
  AND wpa.provider_account_id = $2 
  AND wpa.environment = $3
  AND wpa.is_active = true
  AND wpa.deleted_at IS NULL
  AND w.deleted_at IS NULL
`

type GetWorkspaceProviderAccountForWebhookParams struct {
	ProviderName      string `json:"provider_name"`
	ProviderAccountID string `json:"provider_account_id"`
	Environment       string `json:"environment"`
}

type GetWorkspaceProviderAccountForWebhookRow struct {
	ID                uuid.UUID          `json:"id"`
	WorkspaceID       uuid.UUID          `json:"workspace_id"`
	ProviderName      string             `json:"provider_name"`
	ProviderAccountID string             `json:"provider_account_id"`
	AccountType       string             `json:"account_type"`
	IsActive          bool               `json:"is_active"`
	Environment       string             `json:"environment"`
	DisplayName       pgtype.Text        `json:"display_name"`
	Metadata          []byte             `json:"metadata"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	WorkspaceName     string             `json:"workspace_name"`
	WorkspaceLivemode pgtype.Bool        `json:"workspace_livemode"`
}

// Optimized query for webhook processing - includes all needed data
func (q *Queries) GetWorkspaceProviderAccountForWebhook(ctx context.Context, arg GetWorkspaceProviderAccountForWebhookParams) (GetWorkspaceProviderAccountForWebhookRow, error) {
	row := q.db.QueryRow(ctx, getWorkspaceProviderAccountForWebhook, arg.ProviderName, arg.ProviderAccountID, arg.Environment)
	var i GetWorkspaceProviderAccountForWebhookRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.ProviderAccountID,
		&i.AccountType,
		&i.IsActive,
		&i.Environment,
		&i.DisplayName,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.WorkspaceName,
		&i.WorkspaceLivemode,
	)
	return i, err
}

const listActiveProviders = `-- name: ListActiveProviders :many
SELECT DISTINCT provider_name FROM workspace_provider_accounts
WHERE workspace_id = $1 
  AND is_active = true
  AND deleted_at IS NULL
ORDER BY provider_name
`

// Get list of active providers for a workspace
func (q *Queries) ListActiveProviders(ctx context.Context, workspaceID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, listActiveProviders, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var provider_name string
		if err := rows.Scan(&provider_name); err != nil {
			return nil, err
		}
		items = append(items, provider_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProviderAccountsByProvider = `-- name: ListProviderAccountsByProvider :many
SELECT id, workspace_id, provider_name, provider_account_id, account_type, is_active, environment, display_name, metadata, created_at, updated_at, deleted_at FROM workspace_provider_accounts
WHERE provider_name = $1
  AND is_active = true
  AND deleted_at IS NULL
ORDER BY workspace_id, created_at DESC
LIMIT $2 OFFSET $3
`

type ListProviderAccountsByProviderParams struct {
	ProviderName string `json:"provider_name"`
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
}

// List all accounts for a specific provider across workspaces
func (q *Queries) ListProviderAccountsByProvider(ctx context.Context, arg ListProviderAccountsByProviderParams) ([]WorkspaceProviderAccount, error) {
	rows, err := q.db.Query(ctx, listProviderAccountsByProvider, arg.ProviderName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WorkspaceProviderAccount{}
	for rows.Next() {
		var i WorkspaceProviderAccount
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.ProviderAccountID,
			&i.AccountType,
			&i.IsActive,
			&i.Environment,
			&i.DisplayName,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProviderAccountsByWorkspace = `-- name: ListProviderAccountsByWorkspace :many
SELECT id, workspace_id, provider_name, provider_account_id, account_type, is_active, environment, display_name, metadata, created_at, updated_at, deleted_at FROM workspace_provider_accounts
WHERE workspace_id = $1 
  AND is_active = true
  AND deleted_at IS NULL
ORDER BY provider_name, created_at DESC
LIMIT $2 OFFSET $3
`

type ListProviderAccountsByWorkspaceParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

// List all provider accounts for a workspace
func (q *Queries) ListProviderAccountsByWorkspace(ctx context.Context, arg ListProviderAccountsByWorkspaceParams) ([]WorkspaceProviderAccount, error) {
	rows, err := q.db.Query(ctx, listProviderAccountsByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WorkspaceProviderAccount{}
	for rows.Next() {
		var i WorkspaceProviderAccount
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.ProviderAccountID,
			&i.AccountType,
			&i.IsActive,
			&i.Environment,
			&i.DisplayName,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWorkspaceProviderAccount = `-- name: UpdateWorkspaceProviderAccount :one
UPDATE workspace_provider_accounts
SET 
    account_type = COALESCE($3, account_type),
    is_active = COALESCE($4, is_active),
    environment = COALESCE($5, environment),
    display_name = COALESCE($6, display_name),
    metadata = COALESCE($7, metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
  AND workspace_id = $2
  AND deleted_at IS NULL
RETURNING id, workspace_id, provider_name, provider_account_id, account_type, is_active, environment, display_name, metadata, created_at, updated_at, deleted_at
`

type UpdateWorkspaceProviderAccountParams struct {
	ID          uuid.UUID   `json:"id"`
	WorkspaceID uuid.UUID   `json:"workspace_id"`
	AccountType pgtype.Text `json:"account_type"`
	IsActive    pgtype.Bool `json:"is_active"`
	Environment pgtype.Text `json:"environment"`
	DisplayName pgtype.Text `json:"display_name"`
	Metadata    []byte      `json:"metadata"`
}

func (q *Queries) UpdateWorkspaceProviderAccount(ctx context.Context, arg UpdateWorkspaceProviderAccountParams) (WorkspaceProviderAccount, error) {
	row := q.db.QueryRow(ctx, updateWorkspaceProviderAccount,
		arg.ID,
		arg.WorkspaceID,
		arg.AccountType,
		arg.IsActive,
		arg.Environment,
		arg.DisplayName,
		arg.Metadata,
	)
	var i WorkspaceProviderAccount
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.ProviderAccountID,
		&i.AccountType,
		&i.IsActive,
		&i.Environment,
		&i.DisplayName,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const validateProviderAccountUnique = `-- name: ValidateProviderAccountUnique :one
SELECT COUNT(*) FROM workspace_provider_accounts
WHERE provider_name = $1 
  AND provider_account_id = $2 
  AND environment = $3
  AND deleted_at IS NULL
  AND id != COALESCE($4, '00000000-0000-0000-0000-000000000000'::UUID)
`

type ValidateProviderAccountUniqueParams struct {
	ProviderName      string      `json:"provider_name"`
	ProviderAccountID string      `json:"provider_account_id"`
	Environment       string      `json:"environment"`
	ExcludeID         pgtype.UUID `json:"exclude_id"`
}

// Check if provider account ID already exists (for constraint validation)
func (q *Queries) ValidateProviderAccountUnique(ctx context.Context, arg ValidateProviderAccountUniqueParams) (int64, error) {
	row := q.db.QueryRow(ctx, validateProviderAccountUnique,
		arg.ProviderName,
		arg.ProviderAccountID,
		arg.Environment,
		arg.ExcludeID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}
