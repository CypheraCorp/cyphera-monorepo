// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: delegation_data.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
)

const countDelegations = `-- name: CountDelegations :one
SELECT COUNT(*) FROM delegation_data
WHERE deleted_at IS NULL
`

func (q *Queries) CountDelegations(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countDelegations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDelegationsByDelegator = `-- name: CountDelegationsByDelegator :one
SELECT COUNT(*) FROM delegation_data
WHERE delegator = $1 AND deleted_at IS NULL
`

func (q *Queries) CountDelegationsByDelegator(ctx context.Context, delegator string) (int64, error) {
	row := q.db.QueryRow(ctx, countDelegationsByDelegator, delegator)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDelegationData = `-- name: CreateDelegationData :one
INSERT INTO delegation_data (
    delegate,
    delegator,
    authority,
    caveats,
    salt,
    signature
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, delegate, delegator, authority, caveats, salt, signature, created_at, updated_at, deleted_at
`

type CreateDelegationDataParams struct {
	Delegate  string          `json:"delegate"`
	Delegator string          `json:"delegator"`
	Authority string          `json:"authority"`
	Caveats   json.RawMessage `json:"caveats"`
	Salt      string          `json:"salt"`
	Signature string          `json:"signature"`
}

func (q *Queries) CreateDelegationData(ctx context.Context, arg CreateDelegationDataParams) (DelegationDatum, error) {
	row := q.db.QueryRow(ctx, createDelegationData,
		arg.Delegate,
		arg.Delegator,
		arg.Authority,
		arg.Caveats,
		arg.Salt,
		arg.Signature,
	)
	var i DelegationDatum
	err := row.Scan(
		&i.ID,
		&i.Delegate,
		&i.Delegator,
		&i.Authority,
		&i.Caveats,
		&i.Salt,
		&i.Signature,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteDelegationData = `-- name: DeleteDelegationData :exec
UPDATE delegation_data
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteDelegationData(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDelegationData, id)
	return err
}

const getDelegationData = `-- name: GetDelegationData :one
SELECT id, delegate, delegator, authority, caveats, salt, signature, created_at, updated_at, deleted_at FROM delegation_data
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetDelegationData(ctx context.Context, id uuid.UUID) (DelegationDatum, error) {
	row := q.db.QueryRow(ctx, getDelegationData, id)
	var i DelegationDatum
	err := row.Scan(
		&i.ID,
		&i.Delegate,
		&i.Delegator,
		&i.Authority,
		&i.Caveats,
		&i.Salt,
		&i.Signature,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getDelegationDataBySignature = `-- name: GetDelegationDataBySignature :one
SELECT id, delegate, delegator, authority, caveats, salt, signature, created_at, updated_at, deleted_at FROM delegation_data
WHERE signature = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetDelegationDataBySignature(ctx context.Context, signature string) (DelegationDatum, error) {
	row := q.db.QueryRow(ctx, getDelegationDataBySignature, signature)
	var i DelegationDatum
	err := row.Scan(
		&i.ID,
		&i.Delegate,
		&i.Delegator,
		&i.Authority,
		&i.Caveats,
		&i.Salt,
		&i.Signature,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getDelegationsByDelegate = `-- name: GetDelegationsByDelegate :many
SELECT id, delegate, delegator, authority, caveats, salt, signature, created_at, updated_at, deleted_at FROM delegation_data
WHERE delegate = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetDelegationsByDelegate(ctx context.Context, delegate string) ([]DelegationDatum, error) {
	rows, err := q.db.Query(ctx, getDelegationsByDelegate, delegate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DelegationDatum{}
	for rows.Next() {
		var i DelegationDatum
		if err := rows.Scan(
			&i.ID,
			&i.Delegate,
			&i.Delegator,
			&i.Authority,
			&i.Caveats,
			&i.Salt,
			&i.Signature,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDelegationsByDelegator = `-- name: GetDelegationsByDelegator :many
SELECT id, delegate, delegator, authority, caveats, salt, signature, created_at, updated_at, deleted_at FROM delegation_data
WHERE delegator = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetDelegationsByDelegator(ctx context.Context, delegator string) ([]DelegationDatum, error) {
	rows, err := q.db.Query(ctx, getDelegationsByDelegator, delegator)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DelegationDatum{}
	for rows.Next() {
		var i DelegationDatum
		if err := rows.Scan(
			&i.ID,
			&i.Delegate,
			&i.Delegator,
			&i.Authority,
			&i.Caveats,
			&i.Salt,
			&i.Signature,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDelegationsWithPagination = `-- name: ListDelegationsWithPagination :many
SELECT id, delegate, delegator, authority, caveats, salt, signature, created_at, updated_at, deleted_at FROM delegation_data
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListDelegationsWithPaginationParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListDelegationsWithPagination(ctx context.Context, arg ListDelegationsWithPaginationParams) ([]DelegationDatum, error) {
	rows, err := q.db.Query(ctx, listDelegationsWithPagination, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DelegationDatum{}
	for rows.Next() {
		var i DelegationDatum
		if err := rows.Scan(
			&i.ID,
			&i.Delegate,
			&i.Delegator,
			&i.Authority,
			&i.Caveats,
			&i.Salt,
			&i.Signature,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDelegationData = `-- name: UpdateDelegationData :one
UPDATE delegation_data
SET
    delegate = COALESCE($2, delegate),
    delegator = COALESCE($3, delegator),
    authority = COALESCE($4, authority),
    caveats = COALESCE($5, caveats),
    salt = COALESCE($6, salt),
    signature = COALESCE($7, signature),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, delegate, delegator, authority, caveats, salt, signature, created_at, updated_at, deleted_at
`

type UpdateDelegationDataParams struct {
	ID        uuid.UUID       `json:"id"`
	Delegate  string          `json:"delegate"`
	Delegator string          `json:"delegator"`
	Authority string          `json:"authority"`
	Caveats   json.RawMessage `json:"caveats"`
	Salt      string          `json:"salt"`
	Signature string          `json:"signature"`
}

func (q *Queries) UpdateDelegationData(ctx context.Context, arg UpdateDelegationDataParams) (DelegationDatum, error) {
	row := q.db.QueryRow(ctx, updateDelegationData,
		arg.ID,
		arg.Delegate,
		arg.Delegator,
		arg.Authority,
		arg.Caveats,
		arg.Salt,
		arg.Signature,
	)
	var i DelegationDatum
	err := row.Scan(
		&i.ID,
		&i.Delegate,
		&i.Delegator,
		&i.Authority,
		&i.Caveats,
		&i.Salt,
		&i.Signature,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
