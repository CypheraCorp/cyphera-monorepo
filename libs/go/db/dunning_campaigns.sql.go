// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: dunning_campaigns.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createDunningCampaign = `-- name: CreateDunningCampaign :one
INSERT INTO dunning_campaigns (
    workspace_id,
    configuration_id,
    subscription_id,
    payment_id,
    customer_id,
    status,
    original_failure_reason,
    original_amount_cents,
    currency,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, workspace_id, configuration_id, subscription_id, payment_id, customer_id, status, started_at, completed_at, current_attempt, next_retry_at, last_retry_at, recovered, recovered_at, recovered_amount_cents, final_action_taken, final_action_at, original_failure_reason, original_amount_cents, currency, metadata, created_at, updated_at
`

type CreateDunningCampaignParams struct {
	WorkspaceID           uuid.UUID   `json:"workspace_id"`
	ConfigurationID       uuid.UUID   `json:"configuration_id"`
	SubscriptionID        pgtype.UUID `json:"subscription_id"`
	PaymentID             pgtype.UUID `json:"payment_id"`
	CustomerID            uuid.UUID   `json:"customer_id"`
	Status                string      `json:"status"`
	OriginalFailureReason pgtype.Text `json:"original_failure_reason"`
	OriginalAmountCents   int64       `json:"original_amount_cents"`
	Currency              string      `json:"currency"`
	Metadata              []byte      `json:"metadata"`
}

func (q *Queries) CreateDunningCampaign(ctx context.Context, arg CreateDunningCampaignParams) (DunningCampaign, error) {
	row := q.db.QueryRow(ctx, createDunningCampaign,
		arg.WorkspaceID,
		arg.ConfigurationID,
		arg.SubscriptionID,
		arg.PaymentID,
		arg.CustomerID,
		arg.Status,
		arg.OriginalFailureReason,
		arg.OriginalAmountCents,
		arg.Currency,
		arg.Metadata,
	)
	var i DunningCampaign
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ConfigurationID,
		&i.SubscriptionID,
		&i.PaymentID,
		&i.CustomerID,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CurrentAttempt,
		&i.NextRetryAt,
		&i.LastRetryAt,
		&i.Recovered,
		&i.RecoveredAt,
		&i.RecoveredAmountCents,
		&i.FinalActionTaken,
		&i.FinalActionAt,
		&i.OriginalFailureReason,
		&i.OriginalAmountCents,
		&i.Currency,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const failDunningCampaign = `-- name: FailDunningCampaign :one
UPDATE dunning_campaigns
SET 
    status = 'completed',
    recovered = false,
    final_action_taken = $2,
    final_action_at = CURRENT_TIMESTAMP,
    completed_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, workspace_id, configuration_id, subscription_id, payment_id, customer_id, status, started_at, completed_at, current_attempt, next_retry_at, last_retry_at, recovered, recovered_at, recovered_amount_cents, final_action_taken, final_action_at, original_failure_reason, original_amount_cents, currency, metadata, created_at, updated_at
`

type FailDunningCampaignParams struct {
	ID               uuid.UUID   `json:"id"`
	FinalActionTaken pgtype.Text `json:"final_action_taken"`
}

func (q *Queries) FailDunningCampaign(ctx context.Context, arg FailDunningCampaignParams) (DunningCampaign, error) {
	row := q.db.QueryRow(ctx, failDunningCampaign, arg.ID, arg.FinalActionTaken)
	var i DunningCampaign
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ConfigurationID,
		&i.SubscriptionID,
		&i.PaymentID,
		&i.CustomerID,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CurrentAttempt,
		&i.NextRetryAt,
		&i.LastRetryAt,
		&i.Recovered,
		&i.RecoveredAt,
		&i.RecoveredAmountCents,
		&i.FinalActionTaken,
		&i.FinalActionAt,
		&i.OriginalFailureReason,
		&i.OriginalAmountCents,
		&i.Currency,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActiveDunningCampaignForPayment = `-- name: GetActiveDunningCampaignForPayment :one
SELECT id, workspace_id, configuration_id, subscription_id, payment_id, customer_id, status, started_at, completed_at, current_attempt, next_retry_at, last_retry_at, recovered, recovered_at, recovered_amount_cents, final_action_taken, final_action_at, original_failure_reason, original_amount_cents, currency, metadata, created_at, updated_at FROM dunning_campaigns
WHERE payment_id = $1 
    AND status = 'active'
`

func (q *Queries) GetActiveDunningCampaignForPayment(ctx context.Context, paymentID pgtype.UUID) (DunningCampaign, error) {
	row := q.db.QueryRow(ctx, getActiveDunningCampaignForPayment, paymentID)
	var i DunningCampaign
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ConfigurationID,
		&i.SubscriptionID,
		&i.PaymentID,
		&i.CustomerID,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CurrentAttempt,
		&i.NextRetryAt,
		&i.LastRetryAt,
		&i.Recovered,
		&i.RecoveredAt,
		&i.RecoveredAmountCents,
		&i.FinalActionTaken,
		&i.FinalActionAt,
		&i.OriginalFailureReason,
		&i.OriginalAmountCents,
		&i.Currency,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActiveDunningCampaignForSubscription = `-- name: GetActiveDunningCampaignForSubscription :one
SELECT id, workspace_id, configuration_id, subscription_id, payment_id, customer_id, status, started_at, completed_at, current_attempt, next_retry_at, last_retry_at, recovered, recovered_at, recovered_amount_cents, final_action_taken, final_action_at, original_failure_reason, original_amount_cents, currency, metadata, created_at, updated_at FROM dunning_campaigns
WHERE subscription_id = $1 
    AND status = 'active'
`

func (q *Queries) GetActiveDunningCampaignForSubscription(ctx context.Context, subscriptionID pgtype.UUID) (DunningCampaign, error) {
	row := q.db.QueryRow(ctx, getActiveDunningCampaignForSubscription, subscriptionID)
	var i DunningCampaign
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ConfigurationID,
		&i.SubscriptionID,
		&i.PaymentID,
		&i.CustomerID,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CurrentAttempt,
		&i.NextRetryAt,
		&i.LastRetryAt,
		&i.Recovered,
		&i.RecoveredAt,
		&i.RecoveredAmountCents,
		&i.FinalActionTaken,
		&i.FinalActionAt,
		&i.OriginalFailureReason,
		&i.OriginalAmountCents,
		&i.Currency,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCampaignsNeedingFinalAction = `-- name: GetCampaignsNeedingFinalAction :many
SELECT 
    dc.id, dc.workspace_id, dc.configuration_id, dc.subscription_id, dc.payment_id, dc.customer_id, dc.status, dc.started_at, dc.completed_at, dc.current_attempt, dc.next_retry_at, dc.last_retry_at, dc.recovered, dc.recovered_at, dc.recovered_amount_cents, dc.final_action_taken, dc.final_action_at, dc.original_failure_reason, dc.original_amount_cents, dc.currency, dc.metadata, dc.created_at, dc.updated_at,
    dconf.final_action,
    dconf.final_action_config
FROM dunning_campaigns dc
JOIN dunning_configurations dconf ON dc.configuration_id = dconf.id
WHERE dc.status = 'active'
AND dc.current_attempt_number >= dconf.max_retry_attempts
AND dc.final_action_taken IS NULL
AND dconf.final_action IS NOT NULL
AND dconf.final_action != ''
ORDER BY dc.created_at ASC
`

type GetCampaignsNeedingFinalActionRow struct {
	ID                    uuid.UUID          `json:"id"`
	WorkspaceID           uuid.UUID          `json:"workspace_id"`
	ConfigurationID       uuid.UUID          `json:"configuration_id"`
	SubscriptionID        pgtype.UUID        `json:"subscription_id"`
	PaymentID             pgtype.UUID        `json:"payment_id"`
	CustomerID            uuid.UUID          `json:"customer_id"`
	Status                string             `json:"status"`
	StartedAt             pgtype.Timestamptz `json:"started_at"`
	CompletedAt           pgtype.Timestamptz `json:"completed_at"`
	CurrentAttempt        int32              `json:"current_attempt"`
	NextRetryAt           pgtype.Timestamptz `json:"next_retry_at"`
	LastRetryAt           pgtype.Timestamptz `json:"last_retry_at"`
	Recovered             pgtype.Bool        `json:"recovered"`
	RecoveredAt           pgtype.Timestamptz `json:"recovered_at"`
	RecoveredAmountCents  pgtype.Int8        `json:"recovered_amount_cents"`
	FinalActionTaken      pgtype.Text        `json:"final_action_taken"`
	FinalActionAt         pgtype.Timestamptz `json:"final_action_at"`
	OriginalFailureReason pgtype.Text        `json:"original_failure_reason"`
	OriginalAmountCents   int64              `json:"original_amount_cents"`
	Currency              string             `json:"currency"`
	Metadata              []byte             `json:"metadata"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	FinalAction           string             `json:"final_action"`
	FinalActionConfig     []byte             `json:"final_action_config"`
}

func (q *Queries) GetCampaignsNeedingFinalAction(ctx context.Context) ([]GetCampaignsNeedingFinalActionRow, error) {
	rows, err := q.db.Query(ctx, getCampaignsNeedingFinalAction)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCampaignsNeedingFinalActionRow{}
	for rows.Next() {
		var i GetCampaignsNeedingFinalActionRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ConfigurationID,
			&i.SubscriptionID,
			&i.PaymentID,
			&i.CustomerID,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CurrentAttempt,
			&i.NextRetryAt,
			&i.LastRetryAt,
			&i.Recovered,
			&i.RecoveredAt,
			&i.RecoveredAmountCents,
			&i.FinalActionTaken,
			&i.FinalActionAt,
			&i.OriginalFailureReason,
			&i.OriginalAmountCents,
			&i.Currency,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FinalAction,
			&i.FinalActionConfig,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDunningCampaign = `-- name: GetDunningCampaign :one
SELECT 
    dc.id, dc.workspace_id, dc.configuration_id, dc.subscription_id, dc.payment_id, dc.customer_id, dc.status, dc.started_at, dc.completed_at, dc.current_attempt, dc.next_retry_at, dc.last_retry_at, dc.recovered, dc.recovered_at, dc.recovered_amount_cents, dc.final_action_taken, dc.final_action_at, dc.original_failure_reason, dc.original_amount_cents, dc.currency, dc.metadata, dc.created_at, dc.updated_at,
    dconf.name as configuration_name,
    dconf.max_retry_attempts,
    dconf.retry_interval_days,
    c.email as customer_email,
    c.name as customer_name
FROM dunning_campaigns dc
JOIN dunning_configurations dconf ON dc.configuration_id = dconf.id
JOIN customers c ON dc.customer_id = c.id
WHERE dc.id = $1
`

type GetDunningCampaignRow struct {
	ID                    uuid.UUID          `json:"id"`
	WorkspaceID           uuid.UUID          `json:"workspace_id"`
	ConfigurationID       uuid.UUID          `json:"configuration_id"`
	SubscriptionID        pgtype.UUID        `json:"subscription_id"`
	PaymentID             pgtype.UUID        `json:"payment_id"`
	CustomerID            uuid.UUID          `json:"customer_id"`
	Status                string             `json:"status"`
	StartedAt             pgtype.Timestamptz `json:"started_at"`
	CompletedAt           pgtype.Timestamptz `json:"completed_at"`
	CurrentAttempt        int32              `json:"current_attempt"`
	NextRetryAt           pgtype.Timestamptz `json:"next_retry_at"`
	LastRetryAt           pgtype.Timestamptz `json:"last_retry_at"`
	Recovered             pgtype.Bool        `json:"recovered"`
	RecoveredAt           pgtype.Timestamptz `json:"recovered_at"`
	RecoveredAmountCents  pgtype.Int8        `json:"recovered_amount_cents"`
	FinalActionTaken      pgtype.Text        `json:"final_action_taken"`
	FinalActionAt         pgtype.Timestamptz `json:"final_action_at"`
	OriginalFailureReason pgtype.Text        `json:"original_failure_reason"`
	OriginalAmountCents   int64              `json:"original_amount_cents"`
	Currency              string             `json:"currency"`
	Metadata              []byte             `json:"metadata"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	ConfigurationName     string             `json:"configuration_name"`
	MaxRetryAttempts      int32              `json:"max_retry_attempts"`
	RetryIntervalDays     []int32            `json:"retry_interval_days"`
	CustomerEmail         pgtype.Text        `json:"customer_email"`
	CustomerName          pgtype.Text        `json:"customer_name"`
}

func (q *Queries) GetDunningCampaign(ctx context.Context, id uuid.UUID) (GetDunningCampaignRow, error) {
	row := q.db.QueryRow(ctx, getDunningCampaign, id)
	var i GetDunningCampaignRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ConfigurationID,
		&i.SubscriptionID,
		&i.PaymentID,
		&i.CustomerID,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CurrentAttempt,
		&i.NextRetryAt,
		&i.LastRetryAt,
		&i.Recovered,
		&i.RecoveredAt,
		&i.RecoveredAmountCents,
		&i.FinalActionTaken,
		&i.FinalActionAt,
		&i.OriginalFailureReason,
		&i.OriginalAmountCents,
		&i.Currency,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConfigurationName,
		&i.MaxRetryAttempts,
		&i.RetryIntervalDays,
		&i.CustomerEmail,
		&i.CustomerName,
	)
	return i, err
}

const getDunningCampaignStats = `-- name: GetDunningCampaignStats :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'active') as active_campaigns,
    COUNT(*) FILTER (WHERE status = 'completed' AND recovered = true) as recovered_campaigns,
    COUNT(*) FILTER (WHERE status = 'completed' AND recovered = false) as lost_campaigns,
    SUM(original_amount_cents) FILTER (WHERE status = 'active') as at_risk_amount_cents,
    SUM(recovered_amount_cents) FILTER (WHERE recovered = true) as recovered_amount_cents,
    SUM(original_amount_cents) FILTER (WHERE status = 'completed' AND recovered = false) as lost_amount_cents
FROM dunning_campaigns
WHERE workspace_id = $1
    AND created_at >= $2
    AND created_at < $3
`

type GetDunningCampaignStatsParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetDunningCampaignStatsRow struct {
	ActiveCampaigns      int64 `json:"active_campaigns"`
	RecoveredCampaigns   int64 `json:"recovered_campaigns"`
	LostCampaigns        int64 `json:"lost_campaigns"`
	AtRiskAmountCents    int64 `json:"at_risk_amount_cents"`
	RecoveredAmountCents int64 `json:"recovered_amount_cents"`
	LostAmountCents      int64 `json:"lost_amount_cents"`
}

func (q *Queries) GetDunningCampaignStats(ctx context.Context, arg GetDunningCampaignStatsParams) (GetDunningCampaignStatsRow, error) {
	row := q.db.QueryRow(ctx, getDunningCampaignStats, arg.WorkspaceID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetDunningCampaignStatsRow
	err := row.Scan(
		&i.ActiveCampaigns,
		&i.RecoveredCampaigns,
		&i.LostCampaigns,
		&i.AtRiskAmountCents,
		&i.RecoveredAmountCents,
		&i.LostAmountCents,
	)
	return i, err
}

const listDunningCampaigns = `-- name: ListDunningCampaigns :many
SELECT 
    dc.id, dc.workspace_id, dc.configuration_id, dc.subscription_id, dc.payment_id, dc.customer_id, dc.status, dc.started_at, dc.completed_at, dc.current_attempt, dc.next_retry_at, dc.last_retry_at, dc.recovered, dc.recovered_at, dc.recovered_amount_cents, dc.final_action_taken, dc.final_action_at, dc.original_failure_reason, dc.original_amount_cents, dc.currency, dc.metadata, dc.created_at, dc.updated_at,
    c.email as customer_email,
    c.name as customer_name,
    s.product_id as subscription_product_id
FROM dunning_campaigns dc
JOIN customers c ON dc.customer_id = c.id
LEFT JOIN subscriptions s ON dc.subscription_id = s.id
WHERE dc.workspace_id = $1
    AND ($4::varchar IS NULL OR dc.status = $4)
    AND ($5::uuid IS NULL OR dc.customer_id = $5)
ORDER BY dc.created_at DESC
LIMIT $2 OFFSET $3
`

type ListDunningCampaignsParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
	Status      string    `json:"status"`
	CustomerID  uuid.UUID `json:"customer_id"`
}

type ListDunningCampaignsRow struct {
	ID                    uuid.UUID          `json:"id"`
	WorkspaceID           uuid.UUID          `json:"workspace_id"`
	ConfigurationID       uuid.UUID          `json:"configuration_id"`
	SubscriptionID        pgtype.UUID        `json:"subscription_id"`
	PaymentID             pgtype.UUID        `json:"payment_id"`
	CustomerID            uuid.UUID          `json:"customer_id"`
	Status                string             `json:"status"`
	StartedAt             pgtype.Timestamptz `json:"started_at"`
	CompletedAt           pgtype.Timestamptz `json:"completed_at"`
	CurrentAttempt        int32              `json:"current_attempt"`
	NextRetryAt           pgtype.Timestamptz `json:"next_retry_at"`
	LastRetryAt           pgtype.Timestamptz `json:"last_retry_at"`
	Recovered             pgtype.Bool        `json:"recovered"`
	RecoveredAt           pgtype.Timestamptz `json:"recovered_at"`
	RecoveredAmountCents  pgtype.Int8        `json:"recovered_amount_cents"`
	FinalActionTaken      pgtype.Text        `json:"final_action_taken"`
	FinalActionAt         pgtype.Timestamptz `json:"final_action_at"`
	OriginalFailureReason pgtype.Text        `json:"original_failure_reason"`
	OriginalAmountCents   int64              `json:"original_amount_cents"`
	Currency              string             `json:"currency"`
	Metadata              []byte             `json:"metadata"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	CustomerEmail         pgtype.Text        `json:"customer_email"`
	CustomerName          pgtype.Text        `json:"customer_name"`
	SubscriptionProductID pgtype.UUID        `json:"subscription_product_id"`
}

func (q *Queries) ListDunningCampaigns(ctx context.Context, arg ListDunningCampaignsParams) ([]ListDunningCampaignsRow, error) {
	rows, err := q.db.Query(ctx, listDunningCampaigns,
		arg.WorkspaceID,
		arg.Limit,
		arg.Offset,
		arg.Status,
		arg.CustomerID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDunningCampaignsRow{}
	for rows.Next() {
		var i ListDunningCampaignsRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ConfigurationID,
			&i.SubscriptionID,
			&i.PaymentID,
			&i.CustomerID,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CurrentAttempt,
			&i.NextRetryAt,
			&i.LastRetryAt,
			&i.Recovered,
			&i.RecoveredAt,
			&i.RecoveredAmountCents,
			&i.FinalActionTaken,
			&i.FinalActionAt,
			&i.OriginalFailureReason,
			&i.OriginalAmountCents,
			&i.Currency,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CustomerEmail,
			&i.CustomerName,
			&i.SubscriptionProductID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDunningCampaignsForRetry = `-- name: ListDunningCampaignsForRetry :many
SELECT id, workspace_id, configuration_id, subscription_id, payment_id, customer_id, status, started_at, completed_at, current_attempt, next_retry_at, last_retry_at, recovered, recovered_at, recovered_amount_cents, final_action_taken, final_action_at, original_failure_reason, original_amount_cents, currency, metadata, created_at, updated_at FROM dunning_campaigns
WHERE status = 'active'
    AND next_retry_at <= CURRENT_TIMESTAMP
ORDER BY next_retry_at
LIMIT $1
`

func (q *Queries) ListDunningCampaignsForRetry(ctx context.Context, limit int32) ([]DunningCampaign, error) {
	rows, err := q.db.Query(ctx, listDunningCampaignsForRetry, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DunningCampaign{}
	for rows.Next() {
		var i DunningCampaign
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ConfigurationID,
			&i.SubscriptionID,
			&i.PaymentID,
			&i.CustomerID,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CurrentAttempt,
			&i.NextRetryAt,
			&i.LastRetryAt,
			&i.Recovered,
			&i.RecoveredAt,
			&i.RecoveredAmountCents,
			&i.FinalActionTaken,
			&i.FinalActionAt,
			&i.OriginalFailureReason,
			&i.OriginalAmountCents,
			&i.Currency,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pauseDunningCampaign = `-- name: PauseDunningCampaign :one
UPDATE dunning_campaigns
SET 
    status = 'paused',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, workspace_id, configuration_id, subscription_id, payment_id, customer_id, status, started_at, completed_at, current_attempt, next_retry_at, last_retry_at, recovered, recovered_at, recovered_amount_cents, final_action_taken, final_action_at, original_failure_reason, original_amount_cents, currency, metadata, created_at, updated_at
`

func (q *Queries) PauseDunningCampaign(ctx context.Context, id uuid.UUID) (DunningCampaign, error) {
	row := q.db.QueryRow(ctx, pauseDunningCampaign, id)
	var i DunningCampaign
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ConfigurationID,
		&i.SubscriptionID,
		&i.PaymentID,
		&i.CustomerID,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CurrentAttempt,
		&i.NextRetryAt,
		&i.LastRetryAt,
		&i.Recovered,
		&i.RecoveredAt,
		&i.RecoveredAmountCents,
		&i.FinalActionTaken,
		&i.FinalActionAt,
		&i.OriginalFailureReason,
		&i.OriginalAmountCents,
		&i.Currency,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const recoverDunningCampaign = `-- name: RecoverDunningCampaign :one
UPDATE dunning_campaigns
SET 
    status = 'completed',
    recovered = true,
    recovered_at = CURRENT_TIMESTAMP,
    recovered_amount_cents = $2,
    completed_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, workspace_id, configuration_id, subscription_id, payment_id, customer_id, status, started_at, completed_at, current_attempt, next_retry_at, last_retry_at, recovered, recovered_at, recovered_amount_cents, final_action_taken, final_action_at, original_failure_reason, original_amount_cents, currency, metadata, created_at, updated_at
`

type RecoverDunningCampaignParams struct {
	ID                   uuid.UUID   `json:"id"`
	RecoveredAmountCents pgtype.Int8 `json:"recovered_amount_cents"`
}

func (q *Queries) RecoverDunningCampaign(ctx context.Context, arg RecoverDunningCampaignParams) (DunningCampaign, error) {
	row := q.db.QueryRow(ctx, recoverDunningCampaign, arg.ID, arg.RecoveredAmountCents)
	var i DunningCampaign
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ConfigurationID,
		&i.SubscriptionID,
		&i.PaymentID,
		&i.CustomerID,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CurrentAttempt,
		&i.NextRetryAt,
		&i.LastRetryAt,
		&i.Recovered,
		&i.RecoveredAt,
		&i.RecoveredAmountCents,
		&i.FinalActionTaken,
		&i.FinalActionAt,
		&i.OriginalFailureReason,
		&i.OriginalAmountCents,
		&i.Currency,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const resumeDunningCampaign = `-- name: ResumeDunningCampaign :one
UPDATE dunning_campaigns
SET 
    status = 'active',
    next_retry_at = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, workspace_id, configuration_id, subscription_id, payment_id, customer_id, status, started_at, completed_at, current_attempt, next_retry_at, last_retry_at, recovered, recovered_at, recovered_amount_cents, final_action_taken, final_action_at, original_failure_reason, original_amount_cents, currency, metadata, created_at, updated_at
`

type ResumeDunningCampaignParams struct {
	ID          uuid.UUID          `json:"id"`
	NextRetryAt pgtype.Timestamptz `json:"next_retry_at"`
}

func (q *Queries) ResumeDunningCampaign(ctx context.Context, arg ResumeDunningCampaignParams) (DunningCampaign, error) {
	row := q.db.QueryRow(ctx, resumeDunningCampaign, arg.ID, arg.NextRetryAt)
	var i DunningCampaign
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ConfigurationID,
		&i.SubscriptionID,
		&i.PaymentID,
		&i.CustomerID,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CurrentAttempt,
		&i.NextRetryAt,
		&i.LastRetryAt,
		&i.Recovered,
		&i.RecoveredAt,
		&i.RecoveredAmountCents,
		&i.FinalActionTaken,
		&i.FinalActionAt,
		&i.OriginalFailureReason,
		&i.OriginalAmountCents,
		&i.Currency,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDunningCampaign = `-- name: UpdateDunningCampaign :one
UPDATE dunning_campaigns
SET 
    status = COALESCE($2, status),
    current_attempt = COALESCE($3, current_attempt),
    next_retry_at = $4,
    last_retry_at = $5,
    recovered = COALESCE($6, recovered),
    recovered_at = $7,
    recovered_amount_cents = COALESCE($8, recovered_amount_cents),
    final_action_taken = COALESCE($9, final_action_taken),
    final_action_at = $10,
    completed_at = $11,
    metadata = COALESCE($12, metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, workspace_id, configuration_id, subscription_id, payment_id, customer_id, status, started_at, completed_at, current_attempt, next_retry_at, last_retry_at, recovered, recovered_at, recovered_amount_cents, final_action_taken, final_action_at, original_failure_reason, original_amount_cents, currency, metadata, created_at, updated_at
`

type UpdateDunningCampaignParams struct {
	ID                   uuid.UUID          `json:"id"`
	Status               string             `json:"status"`
	CurrentAttempt       int32              `json:"current_attempt"`
	NextRetryAt          pgtype.Timestamptz `json:"next_retry_at"`
	LastRetryAt          pgtype.Timestamptz `json:"last_retry_at"`
	Recovered            pgtype.Bool        `json:"recovered"`
	RecoveredAt          pgtype.Timestamptz `json:"recovered_at"`
	RecoveredAmountCents pgtype.Int8        `json:"recovered_amount_cents"`
	FinalActionTaken     pgtype.Text        `json:"final_action_taken"`
	FinalActionAt        pgtype.Timestamptz `json:"final_action_at"`
	CompletedAt          pgtype.Timestamptz `json:"completed_at"`
	Metadata             []byte             `json:"metadata"`
}

func (q *Queries) UpdateDunningCampaign(ctx context.Context, arg UpdateDunningCampaignParams) (DunningCampaign, error) {
	row := q.db.QueryRow(ctx, updateDunningCampaign,
		arg.ID,
		arg.Status,
		arg.CurrentAttempt,
		arg.NextRetryAt,
		arg.LastRetryAt,
		arg.Recovered,
		arg.RecoveredAt,
		arg.RecoveredAmountCents,
		arg.FinalActionTaken,
		arg.FinalActionAt,
		arg.CompletedAt,
		arg.Metadata,
	)
	var i DunningCampaign
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ConfigurationID,
		&i.SubscriptionID,
		&i.PaymentID,
		&i.CustomerID,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CurrentAttempt,
		&i.NextRetryAt,
		&i.LastRetryAt,
		&i.Recovered,
		&i.RecoveredAt,
		&i.RecoveredAmountCents,
		&i.FinalActionTaken,
		&i.FinalActionAt,
		&i.OriginalFailureReason,
		&i.OriginalAmountCents,
		&i.Currency,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
