// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: failed_payment_detection.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkExistingDunningCampaign = `-- name: CheckExistingDunningCampaign :one
SELECT EXISTS(
    SELECT 1
    FROM dunning_campaigns
    WHERE subscription_id = $1
        AND status IN ('active', 'paused')
        AND (completed_at IS NULL OR completed_at > $2)
) as exists
`

type CheckExistingDunningCampaignParams struct {
	SubscriptionID pgtype.UUID        `json:"subscription_id"`
	CompletedAt    pgtype.Timestamptz `json:"completed_at"`
}

// Check if there's an active dunning campaign for a subscription
func (q *Queries) CheckExistingDunningCampaign(ctx context.Context, arg CheckExistingDunningCampaignParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkExistingDunningCampaign, arg.SubscriptionID, arg.CompletedAt)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getFailedPaymentCount = `-- name: GetFailedPaymentCount :one
SELECT COUNT(*) as failed_count
FROM subscription_events
WHERE subscription_id = $1
    AND event_type IN ('failed', 'failed_redemption')
    AND occurred_at >= $2
`

type GetFailedPaymentCountParams struct {
	SubscriptionID uuid.UUID          `json:"subscription_id"`
	OccurredAt     pgtype.Timestamptz `json:"occurred_at"`
}

// Get count of failed payments for a subscription
func (q *Queries) GetFailedPaymentCount(ctx context.Context, arg GetFailedPaymentCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getFailedPaymentCount, arg.SubscriptionID, arg.OccurredAt)
	var failed_count int64
	err := row.Scan(&failed_count)
	return failed_count, err
}

const getSubscriptionPaymentHistory = `-- name: GetSubscriptionPaymentHistory :many
SELECT 
    event_type,
    occurred_at,
    amount_in_cents,
    transaction_hash
FROM subscription_events
WHERE subscription_id = $1
    AND event_type IN ('redeemed', 'failed', 'failed_redemption')
ORDER BY occurred_at DESC
LIMIT 100
`

type GetSubscriptionPaymentHistoryRow struct {
	EventType       SubscriptionEventType `json:"event_type"`
	OccurredAt      pgtype.Timestamptz    `json:"occurred_at"`
	AmountInCents   int32                 `json:"amount_in_cents"`
	TransactionHash pgtype.Text           `json:"transaction_hash"`
}

// Get payment history for campaign strategy determination
func (q *Queries) GetSubscriptionPaymentHistory(ctx context.Context, subscriptionID uuid.UUID) ([]GetSubscriptionPaymentHistoryRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionPaymentHistory, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSubscriptionPaymentHistoryRow{}
	for rows.Next() {
		var i GetSubscriptionPaymentHistoryRow
		if err := rows.Scan(
			&i.EventType,
			&i.OccurredAt,
			&i.AmountInCents,
			&i.TransactionHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentFailedPayments = `-- name: ListRecentFailedPayments :many
SELECT DISTINCT ON (se.subscription_id) 
    se.id, se.subscription_id, se.event_type, se.transaction_hash, se.amount_in_cents, se.occurred_at, se.error_message, se.metadata, se.created_at, se.updated_at,
    s.workspace_id,
    s.customer_id,
    s.product_id,
    s.price_id,
    s.status as subscription_status
FROM subscription_events se
JOIN subscriptions s ON se.subscription_id = s.id
WHERE se.event_type IN ('failed', 'failed_redemption')
    AND se.occurred_at >= $1
    AND NOT EXISTS (
        SELECT 1 
        FROM dunning_campaigns dc 
        WHERE dc.subscription_id = se.subscription_id
            AND dc.status IN ('active', 'paused')
            AND dc.created_at > se.occurred_at
    )
ORDER BY se.subscription_id, se.occurred_at DESC
`

type ListRecentFailedPaymentsRow struct {
	ID                 uuid.UUID             `json:"id"`
	SubscriptionID     uuid.UUID             `json:"subscription_id"`
	EventType          SubscriptionEventType `json:"event_type"`
	TransactionHash    pgtype.Text           `json:"transaction_hash"`
	AmountInCents      int32                 `json:"amount_in_cents"`
	OccurredAt         pgtype.Timestamptz    `json:"occurred_at"`
	ErrorMessage       pgtype.Text           `json:"error_message"`
	Metadata           []byte                `json:"metadata"`
	CreatedAt          pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz    `json:"updated_at"`
	WorkspaceID        uuid.UUID             `json:"workspace_id"`
	CustomerID         uuid.UUID             `json:"customer_id"`
	ProductID          uuid.UUID             `json:"product_id"`
	PriceID            uuid.UUID             `json:"price_id"`
	SubscriptionStatus SubscriptionStatus    `json:"subscription_status"`
}

// Get recent failed payments that don't have dunning campaigns
func (q *Queries) ListRecentFailedPayments(ctx context.Context, occurredAt pgtype.Timestamptz) ([]ListRecentFailedPaymentsRow, error) {
	rows, err := q.db.Query(ctx, listRecentFailedPayments, occurredAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecentFailedPaymentsRow{}
	for rows.Next() {
		var i ListRecentFailedPaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.EventType,
			&i.TransactionHash,
			&i.AmountInCents,
			&i.OccurredAt,
			&i.ErrorMessage,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.ProductID,
			&i.PriceID,
			&i.SubscriptionStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
