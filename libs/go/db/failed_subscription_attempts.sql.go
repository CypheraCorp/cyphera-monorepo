// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: failed_subscription_attempts.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countFailedSubscriptionAttempts = `-- name: CountFailedSubscriptionAttempts :one
SELECT COUNT(*) FROM failed_subscription_attempts
`

func (q *Queries) CountFailedSubscriptionAttempts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countFailedSubscriptionAttempts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFailedSubscriptionAttemptsByErrorType = `-- name: CountFailedSubscriptionAttemptsByErrorType :one
SELECT COUNT(*) FROM failed_subscription_attempts
WHERE error_type = $1
`

func (q *Queries) CountFailedSubscriptionAttemptsByErrorType(ctx context.Context, errorType SubscriptionEventType) (int64, error) {
	row := q.db.QueryRow(ctx, countFailedSubscriptionAttemptsByErrorType, errorType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFailedSubscriptionAttempt = `-- name: CreateFailedSubscriptionAttempt :one
INSERT INTO failed_subscription_attempts (
    customer_id,
    product_id,
    product_token_id,
    customer_wallet_id,
    wallet_address,
    error_type,
    error_message,
    error_details,
    delegation_signature,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, customer_id, product_id, product_token_id, customer_wallet_id, wallet_address, error_type, error_message, error_details, delegation_signature, occurred_at, metadata, created_at, updated_at
`

type CreateFailedSubscriptionAttemptParams struct {
	CustomerID          pgtype.UUID           `json:"customer_id"`
	ProductID           uuid.UUID             `json:"product_id"`
	ProductTokenID      uuid.UUID             `json:"product_token_id"`
	CustomerWalletID    pgtype.UUID           `json:"customer_wallet_id"`
	WalletAddress       string                `json:"wallet_address"`
	ErrorType           SubscriptionEventType `json:"error_type"`
	ErrorMessage        string                `json:"error_message"`
	ErrorDetails        []byte                `json:"error_details"`
	DelegationSignature pgtype.Text           `json:"delegation_signature"`
	Metadata            []byte                `json:"metadata"`
}

func (q *Queries) CreateFailedSubscriptionAttempt(ctx context.Context, arg CreateFailedSubscriptionAttemptParams) (FailedSubscriptionAttempt, error) {
	row := q.db.QueryRow(ctx, createFailedSubscriptionAttempt,
		arg.CustomerID,
		arg.ProductID,
		arg.ProductTokenID,
		arg.CustomerWalletID,
		arg.WalletAddress,
		arg.ErrorType,
		arg.ErrorMessage,
		arg.ErrorDetails,
		arg.DelegationSignature,
		arg.Metadata,
	)
	var i FailedSubscriptionAttempt
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.ProductTokenID,
		&i.CustomerWalletID,
		&i.WalletAddress,
		&i.ErrorType,
		&i.ErrorMessage,
		&i.ErrorDetails,
		&i.DelegationSignature,
		&i.OccurredAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFailedSubscriptionAttempt = `-- name: DeleteFailedSubscriptionAttempt :exec
DELETE FROM failed_subscription_attempts
WHERE id = $1
`

func (q *Queries) DeleteFailedSubscriptionAttempt(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFailedSubscriptionAttempt, id)
	return err
}

const getFailedSubscriptionAttempt = `-- name: GetFailedSubscriptionAttempt :one
SELECT id, customer_id, product_id, product_token_id, customer_wallet_id, wallet_address, error_type, error_message, error_details, delegation_signature, occurred_at, metadata, created_at, updated_at FROM failed_subscription_attempts
WHERE id = $1
`

func (q *Queries) GetFailedSubscriptionAttempt(ctx context.Context, id uuid.UUID) (FailedSubscriptionAttempt, error) {
	row := q.db.QueryRow(ctx, getFailedSubscriptionAttempt, id)
	var i FailedSubscriptionAttempt
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.ProductTokenID,
		&i.CustomerWalletID,
		&i.WalletAddress,
		&i.ErrorType,
		&i.ErrorMessage,
		&i.ErrorDetails,
		&i.DelegationSignature,
		&i.OccurredAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listFailedSubscriptionAttempts = `-- name: ListFailedSubscriptionAttempts :many
SELECT id, customer_id, product_id, product_token_id, customer_wallet_id, wallet_address, error_type, error_message, error_details, delegation_signature, occurred_at, metadata, created_at, updated_at FROM failed_subscription_attempts
ORDER BY occurred_at DESC
`

func (q *Queries) ListFailedSubscriptionAttempts(ctx context.Context) ([]FailedSubscriptionAttempt, error) {
	rows, err := q.db.Query(ctx, listFailedSubscriptionAttempts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FailedSubscriptionAttempt{}
	for rows.Next() {
		var i FailedSubscriptionAttempt
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.ProductTokenID,
			&i.CustomerWalletID,
			&i.WalletAddress,
			&i.ErrorType,
			&i.ErrorMessage,
			&i.ErrorDetails,
			&i.DelegationSignature,
			&i.OccurredAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFailedSubscriptionAttemptsByCustomer = `-- name: ListFailedSubscriptionAttemptsByCustomer :many
SELECT id, customer_id, product_id, product_token_id, customer_wallet_id, wallet_address, error_type, error_message, error_details, delegation_signature, occurred_at, metadata, created_at, updated_at FROM failed_subscription_attempts
WHERE customer_id = $1
ORDER BY occurred_at DESC
`

func (q *Queries) ListFailedSubscriptionAttemptsByCustomer(ctx context.Context, customerID pgtype.UUID) ([]FailedSubscriptionAttempt, error) {
	rows, err := q.db.Query(ctx, listFailedSubscriptionAttemptsByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FailedSubscriptionAttempt{}
	for rows.Next() {
		var i FailedSubscriptionAttempt
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.ProductTokenID,
			&i.CustomerWalletID,
			&i.WalletAddress,
			&i.ErrorType,
			&i.ErrorMessage,
			&i.ErrorDetails,
			&i.DelegationSignature,
			&i.OccurredAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFailedSubscriptionAttemptsByErrorType = `-- name: ListFailedSubscriptionAttemptsByErrorType :many
SELECT id, customer_id, product_id, product_token_id, customer_wallet_id, wallet_address, error_type, error_message, error_details, delegation_signature, occurred_at, metadata, created_at, updated_at FROM failed_subscription_attempts
WHERE error_type = $1
ORDER BY occurred_at DESC
`

func (q *Queries) ListFailedSubscriptionAttemptsByErrorType(ctx context.Context, errorType SubscriptionEventType) ([]FailedSubscriptionAttempt, error) {
	rows, err := q.db.Query(ctx, listFailedSubscriptionAttemptsByErrorType, errorType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FailedSubscriptionAttempt{}
	for rows.Next() {
		var i FailedSubscriptionAttempt
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.ProductTokenID,
			&i.CustomerWalletID,
			&i.WalletAddress,
			&i.ErrorType,
			&i.ErrorMessage,
			&i.ErrorDetails,
			&i.DelegationSignature,
			&i.OccurredAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFailedSubscriptionAttemptsByProduct = `-- name: ListFailedSubscriptionAttemptsByProduct :many
SELECT id, customer_id, product_id, product_token_id, customer_wallet_id, wallet_address, error_type, error_message, error_details, delegation_signature, occurred_at, metadata, created_at, updated_at FROM failed_subscription_attempts
WHERE product_id = $1
ORDER BY occurred_at DESC
`

func (q *Queries) ListFailedSubscriptionAttemptsByProduct(ctx context.Context, productID uuid.UUID) ([]FailedSubscriptionAttempt, error) {
	rows, err := q.db.Query(ctx, listFailedSubscriptionAttemptsByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FailedSubscriptionAttempt{}
	for rows.Next() {
		var i FailedSubscriptionAttempt
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.ProductTokenID,
			&i.CustomerWalletID,
			&i.WalletAddress,
			&i.ErrorType,
			&i.ErrorMessage,
			&i.ErrorDetails,
			&i.DelegationSignature,
			&i.OccurredAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFailedSubscriptionAttemptsByWalletAddress = `-- name: ListFailedSubscriptionAttemptsByWalletAddress :many
SELECT id, customer_id, product_id, product_token_id, customer_wallet_id, wallet_address, error_type, error_message, error_details, delegation_signature, occurred_at, metadata, created_at, updated_at FROM failed_subscription_attempts
WHERE wallet_address = $1
ORDER BY occurred_at DESC
`

func (q *Queries) ListFailedSubscriptionAttemptsByWalletAddress(ctx context.Context, walletAddress string) ([]FailedSubscriptionAttempt, error) {
	rows, err := q.db.Query(ctx, listFailedSubscriptionAttemptsByWalletAddress, walletAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FailedSubscriptionAttempt{}
	for rows.Next() {
		var i FailedSubscriptionAttempt
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.ProductTokenID,
			&i.CustomerWalletID,
			&i.WalletAddress,
			&i.ErrorType,
			&i.ErrorMessage,
			&i.ErrorDetails,
			&i.DelegationSignature,
			&i.OccurredAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFailedSubscriptionAttemptsWithPagination = `-- name: ListFailedSubscriptionAttemptsWithPagination :many
SELECT id, customer_id, product_id, product_token_id, customer_wallet_id, wallet_address, error_type, error_message, error_details, delegation_signature, occurred_at, metadata, created_at, updated_at FROM failed_subscription_attempts
ORDER BY occurred_at DESC
LIMIT $1 OFFSET $2
`

type ListFailedSubscriptionAttemptsWithPaginationParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListFailedSubscriptionAttemptsWithPagination(ctx context.Context, arg ListFailedSubscriptionAttemptsWithPaginationParams) ([]FailedSubscriptionAttempt, error) {
	rows, err := q.db.Query(ctx, listFailedSubscriptionAttemptsWithPagination, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FailedSubscriptionAttempt{}
	for rows.Next() {
		var i FailedSubscriptionAttempt
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.ProductTokenID,
			&i.CustomerWalletID,
			&i.WalletAddress,
			&i.ErrorType,
			&i.ErrorMessage,
			&i.ErrorDetails,
			&i.DelegationSignature,
			&i.OccurredAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentFailedSubscriptionAttempts = `-- name: ListRecentFailedSubscriptionAttempts :many
SELECT id, customer_id, product_id, product_token_id, customer_wallet_id, wallet_address, error_type, error_message, error_details, delegation_signature, occurred_at, metadata, created_at, updated_at FROM failed_subscription_attempts
WHERE occurred_at >= $1
ORDER BY occurred_at DESC
`

func (q *Queries) ListRecentFailedSubscriptionAttempts(ctx context.Context, occurredAt pgtype.Timestamptz) ([]FailedSubscriptionAttempt, error) {
	rows, err := q.db.Query(ctx, listRecentFailedSubscriptionAttempts, occurredAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FailedSubscriptionAttempt{}
	for rows.Next() {
		var i FailedSubscriptionAttempt
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.ProductTokenID,
			&i.CustomerWalletID,
			&i.WalletAddress,
			&i.ErrorType,
			&i.ErrorMessage,
			&i.ErrorDetails,
			&i.DelegationSignature,
			&i.OccurredAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
