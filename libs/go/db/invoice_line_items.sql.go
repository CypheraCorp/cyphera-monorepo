// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: invoice_line_items.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createInvoiceLineItem = `-- name: CreateInvoiceLineItem :one
INSERT INTO invoice_line_items (
    invoice_id,
    description,
    quantity,
    unit_amount_in_cents,
    amount_in_cents,
    fiat_currency,
    subscription_id,
    product_id,
    price_id,
    network_id,
    token_id,
    crypto_amount,
    exchange_rate,
    tax_rate,
    tax_amount_in_cents,
    tax_crypto_amount,
    period_start,
    period_end,
    line_item_type,
    gas_fee_payment_id,
    is_gas_sponsored,
    gas_sponsor_type,
    gas_sponsor_name,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24
)
RETURNING id, invoice_id, description, quantity, unit_amount_in_cents, amount_in_cents, fiat_currency, subscription_id, product_id, price_id, network_id, token_id, crypto_amount, exchange_rate, tax_rate, tax_amount_in_cents, tax_crypto_amount, period_start, period_end, line_item_type, gas_fee_payment_id, is_gas_sponsored, gas_sponsor_type, gas_sponsor_name, metadata, created_at, updated_at
`

type CreateInvoiceLineItemParams struct {
	InvoiceID         uuid.UUID          `json:"invoice_id"`
	Description       string             `json:"description"`
	Quantity          pgtype.Numeric     `json:"quantity"`
	UnitAmountInCents int64              `json:"unit_amount_in_cents"`
	AmountInCents     int64              `json:"amount_in_cents"`
	FiatCurrency      string             `json:"fiat_currency"`
	SubscriptionID    pgtype.UUID        `json:"subscription_id"`
	ProductID         pgtype.UUID        `json:"product_id"`
	PriceID           pgtype.UUID        `json:"price_id"`
	NetworkID         pgtype.UUID        `json:"network_id"`
	TokenID           pgtype.UUID        `json:"token_id"`
	CryptoAmount      pgtype.Numeric     `json:"crypto_amount"`
	ExchangeRate      pgtype.Numeric     `json:"exchange_rate"`
	TaxRate           pgtype.Numeric     `json:"tax_rate"`
	TaxAmountInCents  pgtype.Int8        `json:"tax_amount_in_cents"`
	TaxCryptoAmount   pgtype.Numeric     `json:"tax_crypto_amount"`
	PeriodStart       pgtype.Timestamptz `json:"period_start"`
	PeriodEnd         pgtype.Timestamptz `json:"period_end"`
	LineItemType      pgtype.Text        `json:"line_item_type"`
	GasFeePaymentID   pgtype.UUID        `json:"gas_fee_payment_id"`
	IsGasSponsored    pgtype.Bool        `json:"is_gas_sponsored"`
	GasSponsorType    pgtype.Text        `json:"gas_sponsor_type"`
	GasSponsorName    pgtype.Text        `json:"gas_sponsor_name"`
	Metadata          []byte             `json:"metadata"`
}

func (q *Queries) CreateInvoiceLineItem(ctx context.Context, arg CreateInvoiceLineItemParams) (InvoiceLineItem, error) {
	row := q.db.QueryRow(ctx, createInvoiceLineItem,
		arg.InvoiceID,
		arg.Description,
		arg.Quantity,
		arg.UnitAmountInCents,
		arg.AmountInCents,
		arg.FiatCurrency,
		arg.SubscriptionID,
		arg.ProductID,
		arg.PriceID,
		arg.NetworkID,
		arg.TokenID,
		arg.CryptoAmount,
		arg.ExchangeRate,
		arg.TaxRate,
		arg.TaxAmountInCents,
		arg.TaxCryptoAmount,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.LineItemType,
		arg.GasFeePaymentID,
		arg.IsGasSponsored,
		arg.GasSponsorType,
		arg.GasSponsorName,
		arg.Metadata,
	)
	var i InvoiceLineItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Description,
		&i.Quantity,
		&i.UnitAmountInCents,
		&i.AmountInCents,
		&i.FiatCurrency,
		&i.SubscriptionID,
		&i.ProductID,
		&i.PriceID,
		&i.NetworkID,
		&i.TokenID,
		&i.CryptoAmount,
		&i.ExchangeRate,
		&i.TaxRate,
		&i.TaxAmountInCents,
		&i.TaxCryptoAmount,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.LineItemType,
		&i.GasFeePaymentID,
		&i.IsGasSponsored,
		&i.GasSponsorType,
		&i.GasSponsorName,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

type CreateInvoiceLineItemBatchParams struct {
	InvoiceID         uuid.UUID      `json:"invoice_id"`
	Description       string         `json:"description"`
	Quantity          pgtype.Numeric `json:"quantity"`
	UnitAmountInCents int64          `json:"unit_amount_in_cents"`
	AmountInCents     int64          `json:"amount_in_cents"`
	FiatCurrency      string         `json:"fiat_currency"`
	ProductID         pgtype.UUID    `json:"product_id"`
	PriceID           pgtype.UUID    `json:"price_id"`
	LineItemType      pgtype.Text    `json:"line_item_type"`
}

const deleteInvoiceLineItem = `-- name: DeleteInvoiceLineItem :exec
DELETE FROM invoice_line_items
WHERE id = $1
`

func (q *Queries) DeleteInvoiceLineItem(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteInvoiceLineItem, id)
	return err
}

const deleteInvoiceLineItems = `-- name: DeleteInvoiceLineItems :exec
DELETE FROM invoice_line_items
WHERE invoice_id = $1
`

func (q *Queries) DeleteInvoiceLineItems(ctx context.Context, invoiceID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteInvoiceLineItems, invoiceID)
	return err
}

const getGasLineItemsByInvoice = `-- name: GetGasLineItemsByInvoice :many
SELECT 
    ili.id, ili.invoice_id, ili.description, ili.quantity, ili.unit_amount_in_cents, ili.amount_in_cents, ili.fiat_currency, ili.subscription_id, ili.product_id, ili.price_id, ili.network_id, ili.token_id, ili.crypto_amount, ili.exchange_rate, ili.tax_rate, ili.tax_amount_in_cents, ili.tax_crypto_amount, ili.period_start, ili.period_end, ili.line_item_type, ili.gas_fee_payment_id, ili.is_gas_sponsored, ili.gas_sponsor_type, ili.gas_sponsor_name, ili.metadata, ili.created_at, ili.updated_at,
    gfp.gas_fee_wei,
    gfp.gas_price_gwei,
    gfp.gas_units_used,
    n.name as network_name
FROM invoice_line_items ili
LEFT JOIN gas_fee_payments gfp ON ili.gas_fee_payment_id = gfp.id
LEFT JOIN networks n ON ili.network_id = n.id
WHERE ili.invoice_id = $1
    AND ili.line_item_type = 'gas_fee'
ORDER BY ili.created_at ASC
`

type GetGasLineItemsByInvoiceRow struct {
	ID                uuid.UUID          `json:"id"`
	InvoiceID         uuid.UUID          `json:"invoice_id"`
	Description       string             `json:"description"`
	Quantity          pgtype.Numeric     `json:"quantity"`
	UnitAmountInCents int64              `json:"unit_amount_in_cents"`
	AmountInCents     int64              `json:"amount_in_cents"`
	FiatCurrency      string             `json:"fiat_currency"`
	SubscriptionID    pgtype.UUID        `json:"subscription_id"`
	ProductID         pgtype.UUID        `json:"product_id"`
	PriceID           pgtype.UUID        `json:"price_id"`
	NetworkID         pgtype.UUID        `json:"network_id"`
	TokenID           pgtype.UUID        `json:"token_id"`
	CryptoAmount      pgtype.Numeric     `json:"crypto_amount"`
	ExchangeRate      pgtype.Numeric     `json:"exchange_rate"`
	TaxRate           pgtype.Numeric     `json:"tax_rate"`
	TaxAmountInCents  pgtype.Int8        `json:"tax_amount_in_cents"`
	TaxCryptoAmount   pgtype.Numeric     `json:"tax_crypto_amount"`
	PeriodStart       pgtype.Timestamptz `json:"period_start"`
	PeriodEnd         pgtype.Timestamptz `json:"period_end"`
	LineItemType      pgtype.Text        `json:"line_item_type"`
	GasFeePaymentID   pgtype.UUID        `json:"gas_fee_payment_id"`
	IsGasSponsored    pgtype.Bool        `json:"is_gas_sponsored"`
	GasSponsorType    pgtype.Text        `json:"gas_sponsor_type"`
	GasSponsorName    pgtype.Text        `json:"gas_sponsor_name"`
	Metadata          []byte             `json:"metadata"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	GasFeeWei         pgtype.Text        `json:"gas_fee_wei"`
	GasPriceGwei      pgtype.Text        `json:"gas_price_gwei"`
	GasUnitsUsed      pgtype.Int8        `json:"gas_units_used"`
	NetworkName       pgtype.Text        `json:"network_name"`
}

func (q *Queries) GetGasLineItemsByInvoice(ctx context.Context, invoiceID uuid.UUID) ([]GetGasLineItemsByInvoiceRow, error) {
	rows, err := q.db.Query(ctx, getGasLineItemsByInvoice, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGasLineItemsByInvoiceRow{}
	for rows.Next() {
		var i GetGasLineItemsByInvoiceRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceID,
			&i.Description,
			&i.Quantity,
			&i.UnitAmountInCents,
			&i.AmountInCents,
			&i.FiatCurrency,
			&i.SubscriptionID,
			&i.ProductID,
			&i.PriceID,
			&i.NetworkID,
			&i.TokenID,
			&i.CryptoAmount,
			&i.ExchangeRate,
			&i.TaxRate,
			&i.TaxAmountInCents,
			&i.TaxCryptoAmount,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.LineItemType,
			&i.GasFeePaymentID,
			&i.IsGasSponsored,
			&i.GasSponsorType,
			&i.GasSponsorName,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GasFeeWei,
			&i.GasPriceGwei,
			&i.GasUnitsUsed,
			&i.NetworkName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoiceCryptoAmounts = `-- name: GetInvoiceCryptoAmounts :many
SELECT 
    token_id,
    network_id,
    SUM(crypto_amount) as total_crypto_amount,
    SUM(tax_crypto_amount) as total_tax_crypto_amount
FROM invoice_line_items
WHERE invoice_id = $1
    AND token_id IS NOT NULL
GROUP BY token_id, network_id
`

type GetInvoiceCryptoAmountsRow struct {
	TokenID              pgtype.UUID `json:"token_id"`
	NetworkID            pgtype.UUID `json:"network_id"`
	TotalCryptoAmount    int64       `json:"total_crypto_amount"`
	TotalTaxCryptoAmount int64       `json:"total_tax_crypto_amount"`
}

func (q *Queries) GetInvoiceCryptoAmounts(ctx context.Context, invoiceID uuid.UUID) ([]GetInvoiceCryptoAmountsRow, error) {
	rows, err := q.db.Query(ctx, getInvoiceCryptoAmounts, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvoiceCryptoAmountsRow{}
	for rows.Next() {
		var i GetInvoiceCryptoAmountsRow
		if err := rows.Scan(
			&i.TokenID,
			&i.NetworkID,
			&i.TotalCryptoAmount,
			&i.TotalTaxCryptoAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoiceLineItem = `-- name: GetInvoiceLineItem :one
SELECT id, invoice_id, description, quantity, unit_amount_in_cents, amount_in_cents, fiat_currency, subscription_id, product_id, price_id, network_id, token_id, crypto_amount, exchange_rate, tax_rate, tax_amount_in_cents, tax_crypto_amount, period_start, period_end, line_item_type, gas_fee_payment_id, is_gas_sponsored, gas_sponsor_type, gas_sponsor_name, metadata, created_at, updated_at FROM invoice_line_items
WHERE id = $1
`

func (q *Queries) GetInvoiceLineItem(ctx context.Context, id uuid.UUID) (InvoiceLineItem, error) {
	row := q.db.QueryRow(ctx, getInvoiceLineItem, id)
	var i InvoiceLineItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Description,
		&i.Quantity,
		&i.UnitAmountInCents,
		&i.AmountInCents,
		&i.FiatCurrency,
		&i.SubscriptionID,
		&i.ProductID,
		&i.PriceID,
		&i.NetworkID,
		&i.TokenID,
		&i.CryptoAmount,
		&i.ExchangeRate,
		&i.TaxRate,
		&i.TaxAmountInCents,
		&i.TaxCryptoAmount,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.LineItemType,
		&i.GasFeePaymentID,
		&i.IsGasSponsored,
		&i.GasSponsorType,
		&i.GasSponsorName,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInvoiceLineItems = `-- name: GetInvoiceLineItems :many
SELECT id, invoice_id, description, quantity, unit_amount_in_cents, amount_in_cents, fiat_currency, subscription_id, product_id, price_id, network_id, token_id, crypto_amount, exchange_rate, tax_rate, tax_amount_in_cents, tax_crypto_amount, period_start, period_end, line_item_type, gas_fee_payment_id, is_gas_sponsored, gas_sponsor_type, gas_sponsor_name, metadata, created_at, updated_at FROM invoice_line_items
WHERE invoice_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetInvoiceLineItems(ctx context.Context, invoiceID uuid.UUID) ([]InvoiceLineItem, error) {
	rows, err := q.db.Query(ctx, getInvoiceLineItems, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InvoiceLineItem{}
	for rows.Next() {
		var i InvoiceLineItem
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceID,
			&i.Description,
			&i.Quantity,
			&i.UnitAmountInCents,
			&i.AmountInCents,
			&i.FiatCurrency,
			&i.SubscriptionID,
			&i.ProductID,
			&i.PriceID,
			&i.NetworkID,
			&i.TokenID,
			&i.CryptoAmount,
			&i.ExchangeRate,
			&i.TaxRate,
			&i.TaxAmountInCents,
			&i.TaxCryptoAmount,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.LineItemType,
			&i.GasFeePaymentID,
			&i.IsGasSponsored,
			&i.GasSponsorType,
			&i.GasSponsorName,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoiceLineItemsByType = `-- name: GetInvoiceLineItemsByType :many
SELECT id, invoice_id, description, quantity, unit_amount_in_cents, amount_in_cents, fiat_currency, subscription_id, product_id, price_id, network_id, token_id, crypto_amount, exchange_rate, tax_rate, tax_amount_in_cents, tax_crypto_amount, period_start, period_end, line_item_type, gas_fee_payment_id, is_gas_sponsored, gas_sponsor_type, gas_sponsor_name, metadata, created_at, updated_at FROM invoice_line_items
WHERE invoice_id = $1 AND line_item_type = $2
ORDER BY created_at ASC
`

type GetInvoiceLineItemsByTypeParams struct {
	InvoiceID    uuid.UUID   `json:"invoice_id"`
	LineItemType pgtype.Text `json:"line_item_type"`
}

func (q *Queries) GetInvoiceLineItemsByType(ctx context.Context, arg GetInvoiceLineItemsByTypeParams) ([]InvoiceLineItem, error) {
	rows, err := q.db.Query(ctx, getInvoiceLineItemsByType, arg.InvoiceID, arg.LineItemType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InvoiceLineItem{}
	for rows.Next() {
		var i InvoiceLineItem
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceID,
			&i.Description,
			&i.Quantity,
			&i.UnitAmountInCents,
			&i.AmountInCents,
			&i.FiatCurrency,
			&i.SubscriptionID,
			&i.ProductID,
			&i.PriceID,
			&i.NetworkID,
			&i.TokenID,
			&i.CryptoAmount,
			&i.ExchangeRate,
			&i.TaxRate,
			&i.TaxAmountInCents,
			&i.TaxCryptoAmount,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.LineItemType,
			&i.GasFeePaymentID,
			&i.IsGasSponsored,
			&i.GasSponsorType,
			&i.GasSponsorName,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoiceSubtotal = `-- name: GetInvoiceSubtotal :one
SELECT 
    SUM(amount_in_cents) FILTER (WHERE line_item_type = 'product') as product_subtotal,
    SUM(amount_in_cents) FILTER (WHERE line_item_type = 'gas_fee' AND NOT is_gas_sponsored) as customer_gas_fees,
    SUM(amount_in_cents) FILTER (WHERE line_item_type = 'gas_fee' AND is_gas_sponsored) as sponsored_gas_fees,
    SUM(tax_amount_in_cents) as total_tax,
    SUM(amount_in_cents) FILTER (WHERE line_item_type = 'discount') as total_discount,
    SUM(amount_in_cents) - COALESCE(SUM(amount_in_cents) FILTER (WHERE is_gas_sponsored), 0) as customer_total
FROM invoice_line_items
WHERE invoice_id = $1
`

type GetInvoiceSubtotalRow struct {
	ProductSubtotal  int64 `json:"product_subtotal"`
	CustomerGasFees  int64 `json:"customer_gas_fees"`
	SponsoredGasFees int64 `json:"sponsored_gas_fees"`
	TotalTax         int64 `json:"total_tax"`
	TotalDiscount    int64 `json:"total_discount"`
	CustomerTotal    int32 `json:"customer_total"`
}

func (q *Queries) GetInvoiceSubtotal(ctx context.Context, invoiceID uuid.UUID) (GetInvoiceSubtotalRow, error) {
	row := q.db.QueryRow(ctx, getInvoiceSubtotal, invoiceID)
	var i GetInvoiceSubtotalRow
	err := row.Scan(
		&i.ProductSubtotal,
		&i.CustomerGasFees,
		&i.SponsoredGasFees,
		&i.TotalTax,
		&i.TotalDiscount,
		&i.CustomerTotal,
	)
	return i, err
}

const getLineItemsByCurrency = `-- name: GetLineItemsByCurrency :many
SELECT id, invoice_id, description, quantity, unit_amount_in_cents, amount_in_cents, fiat_currency, subscription_id, product_id, price_id, network_id, token_id, crypto_amount, exchange_rate, tax_rate, tax_amount_in_cents, tax_crypto_amount, period_start, period_end, line_item_type, gas_fee_payment_id, is_gas_sponsored, gas_sponsor_type, gas_sponsor_name, metadata, created_at, updated_at FROM invoice_line_items
WHERE invoice_id = $1 AND fiat_currency = $2
ORDER BY created_at ASC
`

type GetLineItemsByCurrencyParams struct {
	InvoiceID    uuid.UUID `json:"invoice_id"`
	FiatCurrency string    `json:"fiat_currency"`
}

func (q *Queries) GetLineItemsByCurrency(ctx context.Context, arg GetLineItemsByCurrencyParams) ([]InvoiceLineItem, error) {
	rows, err := q.db.Query(ctx, getLineItemsByCurrency, arg.InvoiceID, arg.FiatCurrency)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InvoiceLineItem{}
	for rows.Next() {
		var i InvoiceLineItem
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceID,
			&i.Description,
			&i.Quantity,
			&i.UnitAmountInCents,
			&i.AmountInCents,
			&i.FiatCurrency,
			&i.SubscriptionID,
			&i.ProductID,
			&i.PriceID,
			&i.NetworkID,
			&i.TokenID,
			&i.CryptoAmount,
			&i.ExchangeRate,
			&i.TaxRate,
			&i.TaxAmountInCents,
			&i.TaxCryptoAmount,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.LineItemType,
			&i.GasFeePaymentID,
			&i.IsGasSponsored,
			&i.GasSponsorType,
			&i.GasSponsorName,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLineItemsByProduct = `-- name: GetLineItemsByProduct :many
SELECT id, invoice_id, description, quantity, unit_amount_in_cents, amount_in_cents, fiat_currency, subscription_id, product_id, price_id, network_id, token_id, crypto_amount, exchange_rate, tax_rate, tax_amount_in_cents, tax_crypto_amount, period_start, period_end, line_item_type, gas_fee_payment_id, is_gas_sponsored, gas_sponsor_type, gas_sponsor_name, metadata, created_at, updated_at FROM invoice_line_items
WHERE product_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetLineItemsByProductParams struct {
	ProductID pgtype.UUID `json:"product_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) GetLineItemsByProduct(ctx context.Context, arg GetLineItemsByProductParams) ([]InvoiceLineItem, error) {
	rows, err := q.db.Query(ctx, getLineItemsByProduct, arg.ProductID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InvoiceLineItem{}
	for rows.Next() {
		var i InvoiceLineItem
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceID,
			&i.Description,
			&i.Quantity,
			&i.UnitAmountInCents,
			&i.AmountInCents,
			&i.FiatCurrency,
			&i.SubscriptionID,
			&i.ProductID,
			&i.PriceID,
			&i.NetworkID,
			&i.TokenID,
			&i.CryptoAmount,
			&i.ExchangeRate,
			&i.TaxRate,
			&i.TaxAmountInCents,
			&i.TaxCryptoAmount,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.LineItemType,
			&i.GasFeePaymentID,
			&i.IsGasSponsored,
			&i.GasSponsorType,
			&i.GasSponsorName,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductLineItemsByInvoice = `-- name: GetProductLineItemsByInvoice :many
SELECT 
    ili.id, ili.invoice_id, ili.description, ili.quantity, ili.unit_amount_in_cents, ili.amount_in_cents, ili.fiat_currency, ili.subscription_id, ili.product_id, ili.price_id, ili.network_id, ili.token_id, ili.crypto_amount, ili.exchange_rate, ili.tax_rate, ili.tax_amount_in_cents, ili.tax_crypto_amount, ili.period_start, ili.period_end, ili.line_item_type, ili.gas_fee_payment_id, ili.is_gas_sponsored, ili.gas_sponsor_type, ili.gas_sponsor_name, ili.metadata, ili.created_at, ili.updated_at,
    p.name as product_name,
    pr.interval_type,
    pr.term_length
FROM invoice_line_items ili
LEFT JOIN products p ON ili.product_id = p.id
LEFT JOIN prices pr ON ili.price_id = pr.id
WHERE ili.invoice_id = $1
    AND ili.line_item_type = 'product'
ORDER BY ili.created_at ASC
`

type GetProductLineItemsByInvoiceRow struct {
	ID                uuid.UUID          `json:"id"`
	InvoiceID         uuid.UUID          `json:"invoice_id"`
	Description       string             `json:"description"`
	Quantity          pgtype.Numeric     `json:"quantity"`
	UnitAmountInCents int64              `json:"unit_amount_in_cents"`
	AmountInCents     int64              `json:"amount_in_cents"`
	FiatCurrency      string             `json:"fiat_currency"`
	SubscriptionID    pgtype.UUID        `json:"subscription_id"`
	ProductID         pgtype.UUID        `json:"product_id"`
	PriceID           pgtype.UUID        `json:"price_id"`
	NetworkID         pgtype.UUID        `json:"network_id"`
	TokenID           pgtype.UUID        `json:"token_id"`
	CryptoAmount      pgtype.Numeric     `json:"crypto_amount"`
	ExchangeRate      pgtype.Numeric     `json:"exchange_rate"`
	TaxRate           pgtype.Numeric     `json:"tax_rate"`
	TaxAmountInCents  pgtype.Int8        `json:"tax_amount_in_cents"`
	TaxCryptoAmount   pgtype.Numeric     `json:"tax_crypto_amount"`
	PeriodStart       pgtype.Timestamptz `json:"period_start"`
	PeriodEnd         pgtype.Timestamptz `json:"period_end"`
	LineItemType      pgtype.Text        `json:"line_item_type"`
	GasFeePaymentID   pgtype.UUID        `json:"gas_fee_payment_id"`
	IsGasSponsored    pgtype.Bool        `json:"is_gas_sponsored"`
	GasSponsorType    pgtype.Text        `json:"gas_sponsor_type"`
	GasSponsorName    pgtype.Text        `json:"gas_sponsor_name"`
	Metadata          []byte             `json:"metadata"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	ProductName       pgtype.Text        `json:"product_name"`
	IntervalType      NullIntervalType   `json:"interval_type"`
	TermLength        pgtype.Int4        `json:"term_length"`
}

func (q *Queries) GetProductLineItemsByInvoice(ctx context.Context, invoiceID uuid.UUID) ([]GetProductLineItemsByInvoiceRow, error) {
	rows, err := q.db.Query(ctx, getProductLineItemsByInvoice, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductLineItemsByInvoiceRow{}
	for rows.Next() {
		var i GetProductLineItemsByInvoiceRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceID,
			&i.Description,
			&i.Quantity,
			&i.UnitAmountInCents,
			&i.AmountInCents,
			&i.FiatCurrency,
			&i.SubscriptionID,
			&i.ProductID,
			&i.PriceID,
			&i.NetworkID,
			&i.TokenID,
			&i.CryptoAmount,
			&i.ExchangeRate,
			&i.TaxRate,
			&i.TaxAmountInCents,
			&i.TaxCryptoAmount,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.LineItemType,
			&i.GasFeePaymentID,
			&i.IsGasSponsored,
			&i.GasSponsorType,
			&i.GasSponsorName,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.IntervalType,
			&i.TermLength,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvoiceLineItem = `-- name: UpdateInvoiceLineItem :one
UPDATE invoice_line_items
SET 
    description = $2,
    quantity = $3,
    unit_amount_in_cents = $4,
    amount_in_cents = $5,
    tax_rate = $6,
    tax_amount_in_cents = $7,
    tax_crypto_amount = $8,
    metadata = $9,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, invoice_id, description, quantity, unit_amount_in_cents, amount_in_cents, fiat_currency, subscription_id, product_id, price_id, network_id, token_id, crypto_amount, exchange_rate, tax_rate, tax_amount_in_cents, tax_crypto_amount, period_start, period_end, line_item_type, gas_fee_payment_id, is_gas_sponsored, gas_sponsor_type, gas_sponsor_name, metadata, created_at, updated_at
`

type UpdateInvoiceLineItemParams struct {
	ID                uuid.UUID      `json:"id"`
	Description       string         `json:"description"`
	Quantity          pgtype.Numeric `json:"quantity"`
	UnitAmountInCents int64          `json:"unit_amount_in_cents"`
	AmountInCents     int64          `json:"amount_in_cents"`
	TaxRate           pgtype.Numeric `json:"tax_rate"`
	TaxAmountInCents  pgtype.Int8    `json:"tax_amount_in_cents"`
	TaxCryptoAmount   pgtype.Numeric `json:"tax_crypto_amount"`
	Metadata          []byte         `json:"metadata"`
}

func (q *Queries) UpdateInvoiceLineItem(ctx context.Context, arg UpdateInvoiceLineItemParams) (InvoiceLineItem, error) {
	row := q.db.QueryRow(ctx, updateInvoiceLineItem,
		arg.ID,
		arg.Description,
		arg.Quantity,
		arg.UnitAmountInCents,
		arg.AmountInCents,
		arg.TaxRate,
		arg.TaxAmountInCents,
		arg.TaxCryptoAmount,
		arg.Metadata,
	)
	var i InvoiceLineItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Description,
		&i.Quantity,
		&i.UnitAmountInCents,
		&i.AmountInCents,
		&i.FiatCurrency,
		&i.SubscriptionID,
		&i.ProductID,
		&i.PriceID,
		&i.NetworkID,
		&i.TokenID,
		&i.CryptoAmount,
		&i.ExchangeRate,
		&i.TaxRate,
		&i.TaxAmountInCents,
		&i.TaxCryptoAmount,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.LineItemType,
		&i.GasFeePaymentID,
		&i.IsGasSponsored,
		&i.GasSponsorType,
		&i.GasSponsorName,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLineItemGasSponsorship = `-- name: UpdateLineItemGasSponsorship :one
UPDATE invoice_line_items
SET 
    is_gas_sponsored = $2,
    gas_sponsor_type = $3,
    gas_sponsor_name = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, invoice_id, description, quantity, unit_amount_in_cents, amount_in_cents, fiat_currency, subscription_id, product_id, price_id, network_id, token_id, crypto_amount, exchange_rate, tax_rate, tax_amount_in_cents, tax_crypto_amount, period_start, period_end, line_item_type, gas_fee_payment_id, is_gas_sponsored, gas_sponsor_type, gas_sponsor_name, metadata, created_at, updated_at
`

type UpdateLineItemGasSponsorshipParams struct {
	ID             uuid.UUID   `json:"id"`
	IsGasSponsored pgtype.Bool `json:"is_gas_sponsored"`
	GasSponsorType pgtype.Text `json:"gas_sponsor_type"`
	GasSponsorName pgtype.Text `json:"gas_sponsor_name"`
}

func (q *Queries) UpdateLineItemGasSponsorship(ctx context.Context, arg UpdateLineItemGasSponsorshipParams) (InvoiceLineItem, error) {
	row := q.db.QueryRow(ctx, updateLineItemGasSponsorship,
		arg.ID,
		arg.IsGasSponsored,
		arg.GasSponsorType,
		arg.GasSponsorName,
	)
	var i InvoiceLineItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Description,
		&i.Quantity,
		&i.UnitAmountInCents,
		&i.AmountInCents,
		&i.FiatCurrency,
		&i.SubscriptionID,
		&i.ProductID,
		&i.PriceID,
		&i.NetworkID,
		&i.TokenID,
		&i.CryptoAmount,
		&i.ExchangeRate,
		&i.TaxRate,
		&i.TaxAmountInCents,
		&i.TaxCryptoAmount,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.LineItemType,
		&i.GasFeePaymentID,
		&i.IsGasSponsored,
		&i.GasSponsorType,
		&i.GasSponsorName,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
