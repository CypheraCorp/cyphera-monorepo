// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: invoices.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const bulkUpdateInvoiceSyncStatus = `-- name: BulkUpdateInvoiceSyncStatus :exec
UPDATE invoices SET
    payment_sync_status = $2,
    payment_synced_at = CASE 
        WHEN $2 = 'synced' THEN CURRENT_TIMESTAMP 
        ELSE payment_synced_at 
    END,
    updated_at = CURRENT_TIMESTAMP
WHERE workspace_id = $1 
    AND payment_provider = $3 
    AND external_id = ANY($4::text[]) 
    AND deleted_at IS NULL
`

type BulkUpdateInvoiceSyncStatusParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
	Column4           []string    `json:"column_4"`
}

func (q *Queries) BulkUpdateInvoiceSyncStatus(ctx context.Context, arg BulkUpdateInvoiceSyncStatusParams) error {
	_, err := q.db.Exec(ctx, bulkUpdateInvoiceSyncStatus,
		arg.WorkspaceID,
		arg.PaymentSyncStatus,
		arg.PaymentProvider,
		arg.Column4,
	)
	return err
}

const countInvoicesByProvider = `-- name: CountInvoicesByProvider :one
SELECT COUNT(*) FROM invoices 
WHERE workspace_id = $1 AND payment_provider = $2 AND deleted_at IS NULL
`

type CountInvoicesByProviderParams struct {
	WorkspaceID     uuid.UUID   `json:"workspace_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
}

func (q *Queries) CountInvoicesByProvider(ctx context.Context, arg CountInvoicesByProviderParams) (int64, error) {
	row := q.db.QueryRow(ctx, countInvoicesByProvider, arg.WorkspaceID, arg.PaymentProvider)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInvoicesByStatus = `-- name: CountInvoicesByStatus :one
SELECT COUNT(*) FROM invoices 
WHERE workspace_id = $1 AND status = $2 AND deleted_at IS NULL
`

type CountInvoicesByStatusParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Status      string    `json:"status"`
}

func (q *Queries) CountInvoicesByStatus(ctx context.Context, arg CountInvoicesByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countInvoicesByStatus, arg.WorkspaceID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInvoicesByWorkspace = `-- name: CountInvoicesByWorkspace :one
SELECT COUNT(*) FROM invoices 
WHERE workspace_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountInvoicesByWorkspace(ctx context.Context, workspaceID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countInvoicesByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO invoices (
    workspace_id,
    customer_id,
    subscription_id,
    external_id,
    external_customer_id,
    external_subscription_id,
    status,
    collection_method,
    amount_due,
    amount_paid,
    amount_remaining,
    currency,
    due_date,
    paid_at,
    created_date,
    invoice_pdf,
    hosted_invoice_url,
    charge_id,
    payment_intent_id,
    line_items,
    tax_amount,
    total_tax_amounts,
    billing_reason,
    paid_out_of_band,
    payment_provider,
    payment_sync_status,
    payment_synced_at,
    attempt_count,
    next_payment_attempt,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
    $21, $22, $23, $24, $25, $26, $27, $28, $29, $30
) RETURNING id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at
`

type CreateInvoiceParams struct {
	WorkspaceID            uuid.UUID          `json:"workspace_id"`
	CustomerID             pgtype.UUID        `json:"customer_id"`
	SubscriptionID         pgtype.UUID        `json:"subscription_id"`
	ExternalID             string             `json:"external_id"`
	ExternalCustomerID     pgtype.Text        `json:"external_customer_id"`
	ExternalSubscriptionID pgtype.Text        `json:"external_subscription_id"`
	Status                 string             `json:"status"`
	CollectionMethod       pgtype.Text        `json:"collection_method"`
	AmountDue              int32              `json:"amount_due"`
	AmountPaid             int32              `json:"amount_paid"`
	AmountRemaining        int32              `json:"amount_remaining"`
	Currency               string             `json:"currency"`
	DueDate                pgtype.Timestamptz `json:"due_date"`
	PaidAt                 pgtype.Timestamptz `json:"paid_at"`
	CreatedDate            pgtype.Timestamptz `json:"created_date"`
	InvoicePdf             pgtype.Text        `json:"invoice_pdf"`
	HostedInvoiceUrl       pgtype.Text        `json:"hosted_invoice_url"`
	ChargeID               pgtype.Text        `json:"charge_id"`
	PaymentIntentID        pgtype.Text        `json:"payment_intent_id"`
	LineItems              []byte             `json:"line_items"`
	TaxAmount              pgtype.Int4        `json:"tax_amount"`
	TotalTaxAmounts        []byte             `json:"total_tax_amounts"`
	BillingReason          pgtype.Text        `json:"billing_reason"`
	PaidOutOfBand          pgtype.Bool        `json:"paid_out_of_band"`
	PaymentProvider        pgtype.Text        `json:"payment_provider"`
	PaymentSyncStatus      pgtype.Text        `json:"payment_sync_status"`
	PaymentSyncedAt        pgtype.Timestamptz `json:"payment_synced_at"`
	AttemptCount           pgtype.Int4        `json:"attempt_count"`
	NextPaymentAttempt     pgtype.Timestamptz `json:"next_payment_attempt"`
	Metadata               []byte             `json:"metadata"`
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.WorkspaceID,
		arg.CustomerID,
		arg.SubscriptionID,
		arg.ExternalID,
		arg.ExternalCustomerID,
		arg.ExternalSubscriptionID,
		arg.Status,
		arg.CollectionMethod,
		arg.AmountDue,
		arg.AmountPaid,
		arg.AmountRemaining,
		arg.Currency,
		arg.DueDate,
		arg.PaidAt,
		arg.CreatedDate,
		arg.InvoicePdf,
		arg.HostedInvoiceUrl,
		arg.ChargeID,
		arg.PaymentIntentID,
		arg.LineItems,
		arg.TaxAmount,
		arg.TotalTaxAmounts,
		arg.BillingReason,
		arg.PaidOutOfBand,
		arg.PaymentProvider,
		arg.PaymentSyncStatus,
		arg.PaymentSyncedAt,
		arg.AttemptCount,
		arg.NextPaymentAttempt,
		arg.Metadata,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteInvoice = `-- name: DeleteInvoice :exec
UPDATE invoices SET 
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
`

type DeleteInvoiceParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) DeleteInvoice(ctx context.Context, arg DeleteInvoiceParams) error {
	_, err := q.db.Exec(ctx, deleteInvoice, arg.ID, arg.WorkspaceID)
	return err
}

const getInvoiceByExternalID = `-- name: GetInvoiceByExternalID :one
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at FROM invoices 
WHERE external_id = $1 AND workspace_id = $2 AND payment_provider = $3 AND deleted_at IS NULL
`

type GetInvoiceByExternalIDParams struct {
	ExternalID      string      `json:"external_id"`
	WorkspaceID     uuid.UUID   `json:"workspace_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
}

func (q *Queries) GetInvoiceByExternalID(ctx context.Context, arg GetInvoiceByExternalIDParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceByExternalID, arg.ExternalID, arg.WorkspaceID, arg.PaymentProvider)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getInvoiceByID = `-- name: GetInvoiceByID :one
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at FROM invoices 
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
`

type GetInvoiceByIDParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) GetInvoiceByID(ctx context.Context, arg GetInvoiceByIDParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceByID, arg.ID, arg.WorkspaceID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getInvoicesByExternalCustomerID = `-- name: GetInvoicesByExternalCustomerID :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at FROM invoices 
WHERE workspace_id = $1 AND external_customer_id = $2 AND payment_provider = $3 AND deleted_at IS NULL
ORDER BY created_date DESC
`

type GetInvoicesByExternalCustomerIDParams struct {
	WorkspaceID        uuid.UUID   `json:"workspace_id"`
	ExternalCustomerID pgtype.Text `json:"external_customer_id"`
	PaymentProvider    pgtype.Text `json:"payment_provider"`
}

func (q *Queries) GetInvoicesByExternalCustomerID(ctx context.Context, arg GetInvoicesByExternalCustomerIDParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByExternalCustomerID, arg.WorkspaceID, arg.ExternalCustomerID, arg.PaymentProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByExternalSubscriptionID = `-- name: GetInvoicesByExternalSubscriptionID :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at FROM invoices 
WHERE workspace_id = $1 AND external_subscription_id = $2 AND payment_provider = $3 AND deleted_at IS NULL
ORDER BY created_date DESC
`

type GetInvoicesByExternalSubscriptionIDParams struct {
	WorkspaceID            uuid.UUID   `json:"workspace_id"`
	ExternalSubscriptionID pgtype.Text `json:"external_subscription_id"`
	PaymentProvider        pgtype.Text `json:"payment_provider"`
}

func (q *Queries) GetInvoicesByExternalSubscriptionID(ctx context.Context, arg GetInvoicesByExternalSubscriptionIDParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByExternalSubscriptionID, arg.WorkspaceID, arg.ExternalSubscriptionID, arg.PaymentProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOverdueInvoices = `-- name: GetOverdueInvoices :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at FROM invoices 
WHERE workspace_id = $1 
    AND status IN ('open') 
    AND due_date < CURRENT_TIMESTAMP 
    AND deleted_at IS NULL
ORDER BY due_date ASC
LIMIT $2 OFFSET $3
`

type GetOverdueInvoicesParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) GetOverdueInvoices(ctx context.Context, arg GetOverdueInvoicesParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getOverdueInvoices, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentInvoices = `-- name: GetRecentInvoices :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at FROM invoices 
WHERE workspace_id = $1 
    AND created_date >= $2 
    AND deleted_at IS NULL
ORDER BY created_date DESC
LIMIT $3 OFFSET $4
`

type GetRecentInvoicesParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	CreatedDate pgtype.Timestamptz `json:"created_date"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

func (q *Queries) GetRecentInvoices(ctx context.Context, arg GetRecentInvoicesParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getRecentInvoices,
		arg.WorkspaceID,
		arg.CreatedDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnpaidInvoices = `-- name: GetUnpaidInvoices :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at FROM invoices 
WHERE workspace_id = $1 
    AND status IN ('open', 'draft') 
    AND amount_remaining > 0 
    AND deleted_at IS NULL
ORDER BY created_date DESC
LIMIT $2 OFFSET $3
`

type GetUnpaidInvoicesParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) GetUnpaidInvoices(ctx context.Context, arg GetUnpaidInvoicesParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getUnpaidInvoices, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByCustomer = `-- name: ListInvoicesByCustomer :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at FROM invoices 
WHERE workspace_id = $1 AND customer_id = $2 AND deleted_at IS NULL
ORDER BY created_date DESC
LIMIT $3 OFFSET $4
`

type ListInvoicesByCustomerParams struct {
	WorkspaceID uuid.UUID   `json:"workspace_id"`
	CustomerID  pgtype.UUID `json:"customer_id"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

func (q *Queries) ListInvoicesByCustomer(ctx context.Context, arg ListInvoicesByCustomerParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByCustomer,
		arg.WorkspaceID,
		arg.CustomerID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByProvider = `-- name: ListInvoicesByProvider :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at FROM invoices 
WHERE workspace_id = $1 AND payment_provider = $2 AND deleted_at IS NULL
ORDER BY created_date DESC
LIMIT $3 OFFSET $4
`

type ListInvoicesByProviderParams struct {
	WorkspaceID     uuid.UUID   `json:"workspace_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
}

func (q *Queries) ListInvoicesByProvider(ctx context.Context, arg ListInvoicesByProviderParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByProvider,
		arg.WorkspaceID,
		arg.PaymentProvider,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByStatus = `-- name: ListInvoicesByStatus :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at FROM invoices 
WHERE workspace_id = $1 AND status = $2 AND deleted_at IS NULL
ORDER BY created_date DESC
LIMIT $3 OFFSET $4
`

type ListInvoicesByStatusParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Status      string    `json:"status"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListInvoicesByStatus(ctx context.Context, arg ListInvoicesByStatusParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByStatus,
		arg.WorkspaceID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesBySubscription = `-- name: ListInvoicesBySubscription :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at FROM invoices 
WHERE workspace_id = $1 AND subscription_id = $2 AND deleted_at IS NULL
ORDER BY created_date DESC
LIMIT $3 OFFSET $4
`

type ListInvoicesBySubscriptionParams struct {
	WorkspaceID    uuid.UUID   `json:"workspace_id"`
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

func (q *Queries) ListInvoicesBySubscription(ctx context.Context, arg ListInvoicesBySubscriptionParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesBySubscription,
		arg.WorkspaceID,
		arg.SubscriptionID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesBySyncStatus = `-- name: ListInvoicesBySyncStatus :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at FROM invoices 
WHERE workspace_id = $1 AND payment_sync_status = $2 AND deleted_at IS NULL
ORDER BY created_date DESC
LIMIT $3 OFFSET $4
`

type ListInvoicesBySyncStatusParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
	Limit             int32       `json:"limit"`
	Offset            int32       `json:"offset"`
}

func (q *Queries) ListInvoicesBySyncStatus(ctx context.Context, arg ListInvoicesBySyncStatusParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesBySyncStatus,
		arg.WorkspaceID,
		arg.PaymentSyncStatus,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByWorkspace = `-- name: ListInvoicesByWorkspace :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at FROM invoices 
WHERE workspace_id = $1 AND deleted_at IS NULL
ORDER BY created_date DESC
LIMIT $2 OFFSET $3
`

type ListInvoicesByWorkspaceParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListInvoicesByWorkspace(ctx context.Context, arg ListInvoicesByWorkspaceParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvoice = `-- name: UpdateInvoice :one
UPDATE invoices SET
    customer_id = $3,
    subscription_id = $4,
    status = $5,
    collection_method = $6,
    amount_due = $7,
    amount_paid = $8,
    amount_remaining = $9,
    currency = $10,
    due_date = $11,
    paid_at = $12,
    invoice_pdf = $13,
    hosted_invoice_url = $14,
    charge_id = $15,
    payment_intent_id = $16,
    line_items = $17,
    tax_amount = $18,
    total_tax_amounts = $19,
    billing_reason = $20,
    paid_out_of_band = $21,
    attempt_count = $22,
    next_payment_attempt = $23,
    metadata = $24,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
RETURNING id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at
`

type UpdateInvoiceParams struct {
	ID                 uuid.UUID          `json:"id"`
	WorkspaceID        uuid.UUID          `json:"workspace_id"`
	CustomerID         pgtype.UUID        `json:"customer_id"`
	SubscriptionID     pgtype.UUID        `json:"subscription_id"`
	Status             string             `json:"status"`
	CollectionMethod   pgtype.Text        `json:"collection_method"`
	AmountDue          int32              `json:"amount_due"`
	AmountPaid         int32              `json:"amount_paid"`
	AmountRemaining    int32              `json:"amount_remaining"`
	Currency           string             `json:"currency"`
	DueDate            pgtype.Timestamptz `json:"due_date"`
	PaidAt             pgtype.Timestamptz `json:"paid_at"`
	InvoicePdf         pgtype.Text        `json:"invoice_pdf"`
	HostedInvoiceUrl   pgtype.Text        `json:"hosted_invoice_url"`
	ChargeID           pgtype.Text        `json:"charge_id"`
	PaymentIntentID    pgtype.Text        `json:"payment_intent_id"`
	LineItems          []byte             `json:"line_items"`
	TaxAmount          pgtype.Int4        `json:"tax_amount"`
	TotalTaxAmounts    []byte             `json:"total_tax_amounts"`
	BillingReason      pgtype.Text        `json:"billing_reason"`
	PaidOutOfBand      pgtype.Bool        `json:"paid_out_of_band"`
	AttemptCount       pgtype.Int4        `json:"attempt_count"`
	NextPaymentAttempt pgtype.Timestamptz `json:"next_payment_attempt"`
	Metadata           []byte             `json:"metadata"`
}

func (q *Queries) UpdateInvoice(ctx context.Context, arg UpdateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoice,
		arg.ID,
		arg.WorkspaceID,
		arg.CustomerID,
		arg.SubscriptionID,
		arg.Status,
		arg.CollectionMethod,
		arg.AmountDue,
		arg.AmountPaid,
		arg.AmountRemaining,
		arg.Currency,
		arg.DueDate,
		arg.PaidAt,
		arg.InvoicePdf,
		arg.HostedInvoiceUrl,
		arg.ChargeID,
		arg.PaymentIntentID,
		arg.LineItems,
		arg.TaxAmount,
		arg.TotalTaxAmounts,
		arg.BillingReason,
		arg.PaidOutOfBand,
		arg.AttemptCount,
		arg.NextPaymentAttempt,
		arg.Metadata,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateInvoiceSyncStatus = `-- name: UpdateInvoiceSyncStatus :one
UPDATE invoices SET
    payment_sync_status = $3,
    payment_synced_at = CASE 
        WHEN $3 = 'synced' THEN CURRENT_TIMESTAMP 
        ELSE payment_synced_at 
    END,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
RETURNING id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at
`

type UpdateInvoiceSyncStatusParams struct {
	ID                uuid.UUID   `json:"id"`
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
}

func (q *Queries) UpdateInvoiceSyncStatus(ctx context.Context, arg UpdateInvoiceSyncStatusParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoiceSyncStatus, arg.ID, arg.WorkspaceID, arg.PaymentSyncStatus)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const upsertInvoice = `-- name: UpsertInvoice :one
INSERT INTO invoices (
    workspace_id,
    customer_id,
    subscription_id,
    external_id,
    external_customer_id,
    external_subscription_id,
    status,
    collection_method,
    amount_due,
    amount_paid,
    amount_remaining,
    currency,
    due_date,
    paid_at,
    created_date,
    invoice_pdf,
    hosted_invoice_url,
    charge_id,
    payment_intent_id,
    line_items,
    tax_amount,
    total_tax_amounts,
    billing_reason,
    paid_out_of_band,
    payment_provider,
    payment_sync_status,
    payment_synced_at,
    attempt_count,
    next_payment_attempt,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
    $21, $22, $23, $24, $25, $26, $27, $28, $29, $30
)
ON CONFLICT (workspace_id, external_id, payment_provider)
DO UPDATE SET
    customer_id = EXCLUDED.customer_id,
    subscription_id = EXCLUDED.subscription_id,
    status = EXCLUDED.status,
    collection_method = EXCLUDED.collection_method,
    amount_due = EXCLUDED.amount_due,
    amount_paid = EXCLUDED.amount_paid,
    amount_remaining = EXCLUDED.amount_remaining,
    currency = EXCLUDED.currency,
    due_date = EXCLUDED.due_date,
    paid_at = EXCLUDED.paid_at,
    created_date = EXCLUDED.created_date,
    invoice_pdf = EXCLUDED.invoice_pdf,
    hosted_invoice_url = EXCLUDED.hosted_invoice_url,
    charge_id = EXCLUDED.charge_id,
    payment_intent_id = EXCLUDED.payment_intent_id,
    line_items = EXCLUDED.line_items,
    tax_amount = EXCLUDED.tax_amount,
    total_tax_amounts = EXCLUDED.total_tax_amounts,
    billing_reason = EXCLUDED.billing_reason,
    paid_out_of_band = EXCLUDED.paid_out_of_band,
    payment_sync_status = EXCLUDED.payment_sync_status,
    payment_synced_at = EXCLUDED.payment_synced_at,
    attempt_count = EXCLUDED.attempt_count,
    next_payment_attempt = EXCLUDED.next_payment_attempt,
    metadata = EXCLUDED.metadata,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at
`

type UpsertInvoiceParams struct {
	WorkspaceID            uuid.UUID          `json:"workspace_id"`
	CustomerID             pgtype.UUID        `json:"customer_id"`
	SubscriptionID         pgtype.UUID        `json:"subscription_id"`
	ExternalID             string             `json:"external_id"`
	ExternalCustomerID     pgtype.Text        `json:"external_customer_id"`
	ExternalSubscriptionID pgtype.Text        `json:"external_subscription_id"`
	Status                 string             `json:"status"`
	CollectionMethod       pgtype.Text        `json:"collection_method"`
	AmountDue              int32              `json:"amount_due"`
	AmountPaid             int32              `json:"amount_paid"`
	AmountRemaining        int32              `json:"amount_remaining"`
	Currency               string             `json:"currency"`
	DueDate                pgtype.Timestamptz `json:"due_date"`
	PaidAt                 pgtype.Timestamptz `json:"paid_at"`
	CreatedDate            pgtype.Timestamptz `json:"created_date"`
	InvoicePdf             pgtype.Text        `json:"invoice_pdf"`
	HostedInvoiceUrl       pgtype.Text        `json:"hosted_invoice_url"`
	ChargeID               pgtype.Text        `json:"charge_id"`
	PaymentIntentID        pgtype.Text        `json:"payment_intent_id"`
	LineItems              []byte             `json:"line_items"`
	TaxAmount              pgtype.Int4        `json:"tax_amount"`
	TotalTaxAmounts        []byte             `json:"total_tax_amounts"`
	BillingReason          pgtype.Text        `json:"billing_reason"`
	PaidOutOfBand          pgtype.Bool        `json:"paid_out_of_band"`
	PaymentProvider        pgtype.Text        `json:"payment_provider"`
	PaymentSyncStatus      pgtype.Text        `json:"payment_sync_status"`
	PaymentSyncedAt        pgtype.Timestamptz `json:"payment_synced_at"`
	AttemptCount           pgtype.Int4        `json:"attempt_count"`
	NextPaymentAttempt     pgtype.Timestamptz `json:"next_payment_attempt"`
	Metadata               []byte             `json:"metadata"`
}

func (q *Queries) UpsertInvoice(ctx context.Context, arg UpsertInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, upsertInvoice,
		arg.WorkspaceID,
		arg.CustomerID,
		arg.SubscriptionID,
		arg.ExternalID,
		arg.ExternalCustomerID,
		arg.ExternalSubscriptionID,
		arg.Status,
		arg.CollectionMethod,
		arg.AmountDue,
		arg.AmountPaid,
		arg.AmountRemaining,
		arg.Currency,
		arg.DueDate,
		arg.PaidAt,
		arg.CreatedDate,
		arg.InvoicePdf,
		arg.HostedInvoiceUrl,
		arg.ChargeID,
		arg.PaymentIntentID,
		arg.LineItems,
		arg.TaxAmount,
		arg.TotalTaxAmounts,
		arg.BillingReason,
		arg.PaidOutOfBand,
		arg.PaymentProvider,
		arg.PaymentSyncStatus,
		arg.PaymentSyncedAt,
		arg.AttemptCount,
		arg.NextPaymentAttempt,
		arg.Metadata,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
