// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: invoices.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const bulkUpdateInvoiceSyncStatus = `-- name: BulkUpdateInvoiceSyncStatus :exec
UPDATE invoices SET
    payment_sync_status = $2,
    payment_synced_at = CASE 
        WHEN $2 = 'synced' THEN CURRENT_TIMESTAMP 
        ELSE payment_synced_at 
    END,
    updated_at = CURRENT_TIMESTAMP
WHERE workspace_id = $1 
    AND payment_provider = $3 
    AND external_id = ANY($4::text[]) 
    AND deleted_at IS NULL
`

type BulkUpdateInvoiceSyncStatusParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
	Column4           []string    `json:"column_4"`
}

func (q *Queries) BulkUpdateInvoiceSyncStatus(ctx context.Context, arg BulkUpdateInvoiceSyncStatusParams) error {
	_, err := q.db.Exec(ctx, bulkUpdateInvoiceSyncStatus,
		arg.WorkspaceID,
		arg.PaymentSyncStatus,
		arg.PaymentProvider,
		arg.Column4,
	)
	return err
}

const checkInvoiceExistsForPeriod = `-- name: CheckInvoiceExistsForPeriod :one
SELECT EXISTS (
    SELECT 1 FROM invoices i
    JOIN invoice_line_items ili ON i.id = ili.invoice_id
    WHERE i.subscription_id = $1 
    AND i.workspace_id = $2
    AND ili.period_start = $3
    AND ili.period_end = $4
    AND i.deleted_at IS NULL
    AND i.status != 'void'
)
`

type CheckInvoiceExistsForPeriodParams struct {
	SubscriptionID pgtype.UUID        `json:"subscription_id"`
	WorkspaceID    uuid.UUID          `json:"workspace_id"`
	PeriodStart    pgtype.Timestamptz `json:"period_start"`
	PeriodEnd      pgtype.Timestamptz `json:"period_end"`
}

func (q *Queries) CheckInvoiceExistsForPeriod(ctx context.Context, arg CheckInvoiceExistsForPeriodParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkInvoiceExistsForPeriod,
		arg.SubscriptionID,
		arg.WorkspaceID,
		arg.PeriodStart,
		arg.PeriodEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countInvoicesByProvider = `-- name: CountInvoicesByProvider :one
SELECT COUNT(*) FROM invoices 
WHERE workspace_id = $1 AND payment_provider = $2 AND deleted_at IS NULL
`

type CountInvoicesByProviderParams struct {
	WorkspaceID     uuid.UUID   `json:"workspace_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
}

func (q *Queries) CountInvoicesByProvider(ctx context.Context, arg CountInvoicesByProviderParams) (int64, error) {
	row := q.db.QueryRow(ctx, countInvoicesByProvider, arg.WorkspaceID, arg.PaymentProvider)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInvoicesByStatus = `-- name: CountInvoicesByStatus :one
SELECT COUNT(*) FROM invoices 
WHERE workspace_id = $1 AND status = $2 AND deleted_at IS NULL
`

type CountInvoicesByStatusParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Status      string    `json:"status"`
}

func (q *Queries) CountInvoicesByStatus(ctx context.Context, arg CountInvoicesByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countInvoicesByStatus, arg.WorkspaceID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInvoicesByWorkspace = `-- name: CountInvoicesByWorkspace :one
SELECT COUNT(*) FROM invoices 
WHERE workspace_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountInvoicesByWorkspace(ctx context.Context, workspaceID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countInvoicesByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO invoices (
    workspace_id,
    customer_id,
    subscription_id,
    external_id,
    external_customer_id,
    external_subscription_id,
    status,
    collection_method,
    amount_due,
    amount_paid,
    amount_remaining,
    currency,
    due_date,
    paid_at,
    created_date,
    invoice_pdf,
    hosted_invoice_url,
    charge_id,
    payment_intent_id,
    line_items,
    tax_amount,
    total_tax_amounts,
    billing_reason,
    paid_out_of_band,
    payment_provider,
    payment_sync_status,
    payment_synced_at,
    attempt_count,
    next_payment_attempt,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
    $21, $22, $23, $24, $25, $26, $27, $28, $29, $30
) RETURNING id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies
`

type CreateInvoiceParams struct {
	WorkspaceID            uuid.UUID          `json:"workspace_id"`
	CustomerID             pgtype.UUID        `json:"customer_id"`
	SubscriptionID         pgtype.UUID        `json:"subscription_id"`
	ExternalID             string             `json:"external_id"`
	ExternalCustomerID     pgtype.Text        `json:"external_customer_id"`
	ExternalSubscriptionID pgtype.Text        `json:"external_subscription_id"`
	Status                 string             `json:"status"`
	CollectionMethod       pgtype.Text        `json:"collection_method"`
	AmountDue              int32              `json:"amount_due"`
	AmountPaid             int32              `json:"amount_paid"`
	AmountRemaining        int32              `json:"amount_remaining"`
	Currency               string             `json:"currency"`
	DueDate                pgtype.Timestamptz `json:"due_date"`
	PaidAt                 pgtype.Timestamptz `json:"paid_at"`
	CreatedDate            pgtype.Timestamptz `json:"created_date"`
	InvoicePdf             pgtype.Text        `json:"invoice_pdf"`
	HostedInvoiceUrl       pgtype.Text        `json:"hosted_invoice_url"`
	ChargeID               pgtype.Text        `json:"charge_id"`
	PaymentIntentID        pgtype.Text        `json:"payment_intent_id"`
	LineItems              []byte             `json:"line_items"`
	TaxAmount              pgtype.Int4        `json:"tax_amount"`
	TotalTaxAmounts        []byte             `json:"total_tax_amounts"`
	BillingReason          pgtype.Text        `json:"billing_reason"`
	PaidOutOfBand          pgtype.Bool        `json:"paid_out_of_band"`
	PaymentProvider        pgtype.Text        `json:"payment_provider"`
	PaymentSyncStatus      pgtype.Text        `json:"payment_sync_status"`
	PaymentSyncedAt        pgtype.Timestamptz `json:"payment_synced_at"`
	AttemptCount           pgtype.Int4        `json:"attempt_count"`
	NextPaymentAttempt     pgtype.Timestamptz `json:"next_payment_attempt"`
	Metadata               []byte             `json:"metadata"`
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.WorkspaceID,
		arg.CustomerID,
		arg.SubscriptionID,
		arg.ExternalID,
		arg.ExternalCustomerID,
		arg.ExternalSubscriptionID,
		arg.Status,
		arg.CollectionMethod,
		arg.AmountDue,
		arg.AmountPaid,
		arg.AmountRemaining,
		arg.Currency,
		arg.DueDate,
		arg.PaidAt,
		arg.CreatedDate,
		arg.InvoicePdf,
		arg.HostedInvoiceUrl,
		arg.ChargeID,
		arg.PaymentIntentID,
		arg.LineItems,
		arg.TaxAmount,
		arg.TotalTaxAmounts,
		arg.BillingReason,
		arg.PaidOutOfBand,
		arg.PaymentProvider,
		arg.PaymentSyncStatus,
		arg.PaymentSyncedAt,
		arg.AttemptCount,
		arg.NextPaymentAttempt,
		arg.Metadata,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvoiceNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.PaymentLinkID,
		&i.DelegationAddress,
		&i.QrCodeData,
		&i.TaxAmountCents,
		&i.TaxDetails,
		&i.CustomerTaxID,
		&i.CustomerJurisdictionID,
		&i.ReverseChargeApplies,
	)
	return i, err
}

const createInvoiceWithDetails = `-- name: CreateInvoiceWithDetails :one
INSERT INTO invoices (
    workspace_id,
    customer_id,
    subscription_id,
    invoice_number,
    status,
    amount_due,
    currency,
    subtotal_cents,
    discount_cents,
    tax_amount_cents,
    tax_details,
    due_date,
    payment_link_id,
    delegation_address,
    qr_code_data,
    customer_tax_id,
    customer_jurisdiction_id,
    reverse_charge_applies,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19
) RETURNING id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies
`

type CreateInvoiceWithDetailsParams struct {
	WorkspaceID            uuid.UUID          `json:"workspace_id"`
	CustomerID             pgtype.UUID        `json:"customer_id"`
	SubscriptionID         pgtype.UUID        `json:"subscription_id"`
	InvoiceNumber          pgtype.Text        `json:"invoice_number"`
	Status                 string             `json:"status"`
	AmountDue              int32              `json:"amount_due"`
	Currency               string             `json:"currency"`
	SubtotalCents          pgtype.Int8        `json:"subtotal_cents"`
	DiscountCents          pgtype.Int8        `json:"discount_cents"`
	TaxAmountCents         int64              `json:"tax_amount_cents"`
	TaxDetails             []byte             `json:"tax_details"`
	DueDate                pgtype.Timestamptz `json:"due_date"`
	PaymentLinkID          pgtype.UUID        `json:"payment_link_id"`
	DelegationAddress      pgtype.Text        `json:"delegation_address"`
	QrCodeData             pgtype.Text        `json:"qr_code_data"`
	CustomerTaxID          pgtype.Text        `json:"customer_tax_id"`
	CustomerJurisdictionID pgtype.UUID        `json:"customer_jurisdiction_id"`
	ReverseChargeApplies   pgtype.Bool        `json:"reverse_charge_applies"`
	Metadata               []byte             `json:"metadata"`
}

func (q *Queries) CreateInvoiceWithDetails(ctx context.Context, arg CreateInvoiceWithDetailsParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, createInvoiceWithDetails,
		arg.WorkspaceID,
		arg.CustomerID,
		arg.SubscriptionID,
		arg.InvoiceNumber,
		arg.Status,
		arg.AmountDue,
		arg.Currency,
		arg.SubtotalCents,
		arg.DiscountCents,
		arg.TaxAmountCents,
		arg.TaxDetails,
		arg.DueDate,
		arg.PaymentLinkID,
		arg.DelegationAddress,
		arg.QrCodeData,
		arg.CustomerTaxID,
		arg.CustomerJurisdictionID,
		arg.ReverseChargeApplies,
		arg.Metadata,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvoiceNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.PaymentLinkID,
		&i.DelegationAddress,
		&i.QrCodeData,
		&i.TaxAmountCents,
		&i.TaxDetails,
		&i.CustomerTaxID,
		&i.CustomerJurisdictionID,
		&i.ReverseChargeApplies,
	)
	return i, err
}

const deleteInvoice = `-- name: DeleteInvoice :exec
UPDATE invoices SET 
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
`

type DeleteInvoiceParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) DeleteInvoice(ctx context.Context, arg DeleteInvoiceParams) error {
	_, err := q.db.Exec(ctx, deleteInvoice, arg.ID, arg.WorkspaceID)
	return err
}

const getInvoiceByExternalID = `-- name: GetInvoiceByExternalID :one
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies FROM invoices 
WHERE external_id = $1 AND workspace_id = $2 AND payment_provider = $3 AND deleted_at IS NULL
`

type GetInvoiceByExternalIDParams struct {
	ExternalID      string      `json:"external_id"`
	WorkspaceID     uuid.UUID   `json:"workspace_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
}

func (q *Queries) GetInvoiceByExternalID(ctx context.Context, arg GetInvoiceByExternalIDParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceByExternalID, arg.ExternalID, arg.WorkspaceID, arg.PaymentProvider)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvoiceNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.PaymentLinkID,
		&i.DelegationAddress,
		&i.QrCodeData,
		&i.TaxAmountCents,
		&i.TaxDetails,
		&i.CustomerTaxID,
		&i.CustomerJurisdictionID,
		&i.ReverseChargeApplies,
	)
	return i, err
}

const getInvoiceByID = `-- name: GetInvoiceByID :one
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies FROM invoices 
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
`

type GetInvoiceByIDParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) GetInvoiceByID(ctx context.Context, arg GetInvoiceByIDParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceByID, arg.ID, arg.WorkspaceID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvoiceNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.PaymentLinkID,
		&i.DelegationAddress,
		&i.QrCodeData,
		&i.TaxAmountCents,
		&i.TaxDetails,
		&i.CustomerTaxID,
		&i.CustomerJurisdictionID,
		&i.ReverseChargeApplies,
	)
	return i, err
}

const getInvoiceByNumber = `-- name: GetInvoiceByNumber :one
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies FROM invoices
WHERE workspace_id = $1 AND invoice_number = $2 AND deleted_at IS NULL
`

type GetInvoiceByNumberParams struct {
	WorkspaceID   uuid.UUID   `json:"workspace_id"`
	InvoiceNumber pgtype.Text `json:"invoice_number"`
}

func (q *Queries) GetInvoiceByNumber(ctx context.Context, arg GetInvoiceByNumberParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceByNumber, arg.WorkspaceID, arg.InvoiceNumber)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvoiceNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.PaymentLinkID,
		&i.DelegationAddress,
		&i.QrCodeData,
		&i.TaxAmountCents,
		&i.TaxDetails,
		&i.CustomerTaxID,
		&i.CustomerJurisdictionID,
		&i.ReverseChargeApplies,
	)
	return i, err
}

const getInvoiceWithLineItems = `-- name: GetInvoiceWithLineItems :one
SELECT 
    i.id, i.workspace_id, i.customer_id, i.subscription_id, i.external_id, i.external_customer_id, i.external_subscription_id, i.status, i.collection_method, i.amount_due, i.amount_paid, i.amount_remaining, i.currency, i.due_date, i.paid_at, i.created_date, i.invoice_pdf, i.hosted_invoice_url, i.charge_id, i.payment_intent_id, i.line_items, i.tax_amount, i.total_tax_amounts, i.billing_reason, i.paid_out_of_band, i.payment_provider, i.payment_sync_status, i.payment_synced_at, i.attempt_count, i.next_payment_attempt, i.metadata, i.created_at, i.updated_at, i.deleted_at, i.invoice_number, i.subtotal_cents, i.discount_cents, i.payment_link_id, i.delegation_address, i.qr_code_data, i.tax_amount_cents, i.tax_details, i.customer_tax_id, i.customer_jurisdiction_id, i.reverse_charge_applies,
    COALESCE(
        (SELECT json_agg(ili.* ORDER BY ili.created_at)
         FROM invoice_line_items ili
         WHERE ili.invoice_id = i.id),
        '[]'::json
    ) as line_items_detail
FROM invoices i
WHERE i.id = $1 AND i.workspace_id = $2 AND i.deleted_at IS NULL
`

type GetInvoiceWithLineItemsParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

type GetInvoiceWithLineItemsRow struct {
	ID                     uuid.UUID          `json:"id"`
	WorkspaceID            uuid.UUID          `json:"workspace_id"`
	CustomerID             pgtype.UUID        `json:"customer_id"`
	SubscriptionID         pgtype.UUID        `json:"subscription_id"`
	ExternalID             string             `json:"external_id"`
	ExternalCustomerID     pgtype.Text        `json:"external_customer_id"`
	ExternalSubscriptionID pgtype.Text        `json:"external_subscription_id"`
	Status                 string             `json:"status"`
	CollectionMethod       pgtype.Text        `json:"collection_method"`
	AmountDue              int32              `json:"amount_due"`
	AmountPaid             int32              `json:"amount_paid"`
	AmountRemaining        int32              `json:"amount_remaining"`
	Currency               string             `json:"currency"`
	DueDate                pgtype.Timestamptz `json:"due_date"`
	PaidAt                 pgtype.Timestamptz `json:"paid_at"`
	CreatedDate            pgtype.Timestamptz `json:"created_date"`
	InvoicePdf             pgtype.Text        `json:"invoice_pdf"`
	HostedInvoiceUrl       pgtype.Text        `json:"hosted_invoice_url"`
	ChargeID               pgtype.Text        `json:"charge_id"`
	PaymentIntentID        pgtype.Text        `json:"payment_intent_id"`
	LineItems              []byte             `json:"line_items"`
	TaxAmount              pgtype.Int4        `json:"tax_amount"`
	TotalTaxAmounts        []byte             `json:"total_tax_amounts"`
	BillingReason          pgtype.Text        `json:"billing_reason"`
	PaidOutOfBand          pgtype.Bool        `json:"paid_out_of_band"`
	PaymentProvider        pgtype.Text        `json:"payment_provider"`
	PaymentSyncStatus      pgtype.Text        `json:"payment_sync_status"`
	PaymentSyncedAt        pgtype.Timestamptz `json:"payment_synced_at"`
	AttemptCount           pgtype.Int4        `json:"attempt_count"`
	NextPaymentAttempt     pgtype.Timestamptz `json:"next_payment_attempt"`
	Metadata               []byte             `json:"metadata"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	DeletedAt              pgtype.Timestamptz `json:"deleted_at"`
	InvoiceNumber          pgtype.Text        `json:"invoice_number"`
	SubtotalCents          pgtype.Int8        `json:"subtotal_cents"`
	DiscountCents          pgtype.Int8        `json:"discount_cents"`
	PaymentLinkID          pgtype.UUID        `json:"payment_link_id"`
	DelegationAddress      pgtype.Text        `json:"delegation_address"`
	QrCodeData             pgtype.Text        `json:"qr_code_data"`
	TaxAmountCents         int64              `json:"tax_amount_cents"`
	TaxDetails             []byte             `json:"tax_details"`
	CustomerTaxID          pgtype.Text        `json:"customer_tax_id"`
	CustomerJurisdictionID pgtype.UUID        `json:"customer_jurisdiction_id"`
	ReverseChargeApplies   pgtype.Bool        `json:"reverse_charge_applies"`
	LineItemsDetail        interface{}        `json:"line_items_detail"`
}

func (q *Queries) GetInvoiceWithLineItems(ctx context.Context, arg GetInvoiceWithLineItemsParams) (GetInvoiceWithLineItemsRow, error) {
	row := q.db.QueryRow(ctx, getInvoiceWithLineItems, arg.ID, arg.WorkspaceID)
	var i GetInvoiceWithLineItemsRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvoiceNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.PaymentLinkID,
		&i.DelegationAddress,
		&i.QrCodeData,
		&i.TaxAmountCents,
		&i.TaxDetails,
		&i.CustomerTaxID,
		&i.CustomerJurisdictionID,
		&i.ReverseChargeApplies,
		&i.LineItemsDetail,
	)
	return i, err
}

const getInvoicesByExternalCustomerID = `-- name: GetInvoicesByExternalCustomerID :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies FROM invoices 
WHERE workspace_id = $1 AND external_customer_id = $2 AND payment_provider = $3 AND deleted_at IS NULL
ORDER BY created_date DESC
`

type GetInvoicesByExternalCustomerIDParams struct {
	WorkspaceID        uuid.UUID   `json:"workspace_id"`
	ExternalCustomerID pgtype.Text `json:"external_customer_id"`
	PaymentProvider    pgtype.Text `json:"payment_provider"`
}

func (q *Queries) GetInvoicesByExternalCustomerID(ctx context.Context, arg GetInvoicesByExternalCustomerIDParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByExternalCustomerID, arg.WorkspaceID, arg.ExternalCustomerID, arg.PaymentProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.InvoiceNumber,
			&i.SubtotalCents,
			&i.DiscountCents,
			&i.PaymentLinkID,
			&i.DelegationAddress,
			&i.QrCodeData,
			&i.TaxAmountCents,
			&i.TaxDetails,
			&i.CustomerTaxID,
			&i.CustomerJurisdictionID,
			&i.ReverseChargeApplies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByExternalSubscriptionID = `-- name: GetInvoicesByExternalSubscriptionID :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies FROM invoices 
WHERE workspace_id = $1 AND external_subscription_id = $2 AND payment_provider = $3 AND deleted_at IS NULL
ORDER BY created_date DESC
`

type GetInvoicesByExternalSubscriptionIDParams struct {
	WorkspaceID            uuid.UUID   `json:"workspace_id"`
	ExternalSubscriptionID pgtype.Text `json:"external_subscription_id"`
	PaymentProvider        pgtype.Text `json:"payment_provider"`
}

func (q *Queries) GetInvoicesByExternalSubscriptionID(ctx context.Context, arg GetInvoicesByExternalSubscriptionIDParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByExternalSubscriptionID, arg.WorkspaceID, arg.ExternalSubscriptionID, arg.PaymentProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.InvoiceNumber,
			&i.SubtotalCents,
			&i.DiscountCents,
			&i.PaymentLinkID,
			&i.DelegationAddress,
			&i.QrCodeData,
			&i.TaxAmountCents,
			&i.TaxDetails,
			&i.CustomerTaxID,
			&i.CustomerJurisdictionID,
			&i.ReverseChargeApplies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByPaymentLink = `-- name: GetInvoicesByPaymentLink :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies FROM invoices
WHERE workspace_id = $1 AND payment_link_id = $2 AND deleted_at IS NULL
ORDER BY created_at DESC
`

type GetInvoicesByPaymentLinkParams struct {
	WorkspaceID   uuid.UUID   `json:"workspace_id"`
	PaymentLinkID pgtype.UUID `json:"payment_link_id"`
}

func (q *Queries) GetInvoicesByPaymentLink(ctx context.Context, arg GetInvoicesByPaymentLinkParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByPaymentLink, arg.WorkspaceID, arg.PaymentLinkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.InvoiceNumber,
			&i.SubtotalCents,
			&i.DiscountCents,
			&i.PaymentLinkID,
			&i.DelegationAddress,
			&i.QrCodeData,
			&i.TaxAmountCents,
			&i.TaxDetails,
			&i.CustomerTaxID,
			&i.CustomerJurisdictionID,
			&i.ReverseChargeApplies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextInvoiceNumber = `-- name: GetNextInvoiceNumber :one
SELECT 
    COALESCE(MAX(CAST(REGEXP_REPLACE(invoice_number, '[^0-9]', '', 'g') AS INTEGER)), 0) + 1 as next_number
FROM invoices
WHERE workspace_id = $1 
    AND invoice_number ~ '^[A-Z]*[0-9]+$'
    AND deleted_at IS NULL
`

func (q *Queries) GetNextInvoiceNumber(ctx context.Context, workspaceID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getNextInvoiceNumber, workspaceID)
	var next_number int32
	err := row.Scan(&next_number)
	return next_number, err
}

const getOverdueInvoices = `-- name: GetOverdueInvoices :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies FROM invoices 
WHERE workspace_id = $1 
    AND status IN ('open') 
    AND due_date < CURRENT_TIMESTAMP 
    AND deleted_at IS NULL
ORDER BY due_date ASC
LIMIT $2 OFFSET $3
`

type GetOverdueInvoicesParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) GetOverdueInvoices(ctx context.Context, arg GetOverdueInvoicesParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getOverdueInvoices, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.InvoiceNumber,
			&i.SubtotalCents,
			&i.DiscountCents,
			&i.PaymentLinkID,
			&i.DelegationAddress,
			&i.QrCodeData,
			&i.TaxAmountCents,
			&i.TaxDetails,
			&i.CustomerTaxID,
			&i.CustomerJurisdictionID,
			&i.ReverseChargeApplies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingInvoicesForGeneration = `-- name: GetPendingInvoicesForGeneration :many
SELECT DISTINCT
    s.id as subscription_id,
    s.workspace_id,
    s.customer_id,
    s.next_redemption_date,
    s.current_period_end,
    s.total_amount_in_cents,
    sli.currency
FROM subscriptions s
JOIN subscription_line_items sli ON s.id = sli.subscription_id AND sli.line_item_type = 'base' AND sli.is_active = true
WHERE s.status = 'active'
AND s.next_redemption_date <= $1  -- Within look-ahead period
AND s.deleted_at IS NULL
AND NOT EXISTS (
    SELECT 1 FROM invoices i
    WHERE i.subscription_id = s.id
    AND i.status != 'void'
    AND i.created_at >= s.current_period_start
    AND i.deleted_at IS NULL
)
ORDER BY s.next_redemption_date
`

type GetPendingInvoicesForGenerationRow struct {
	SubscriptionID     uuid.UUID          `json:"subscription_id"`
	WorkspaceID        uuid.UUID          `json:"workspace_id"`
	CustomerID         uuid.UUID          `json:"customer_id"`
	NextRedemptionDate pgtype.Timestamptz `json:"next_redemption_date"`
	CurrentPeriodEnd   pgtype.Timestamptz `json:"current_period_end"`
	TotalAmountInCents int32              `json:"total_amount_in_cents"`
	Currency           string             `json:"currency"`
}

func (q *Queries) GetPendingInvoicesForGeneration(ctx context.Context, nextRedemptionDate pgtype.Timestamptz) ([]GetPendingInvoicesForGenerationRow, error) {
	rows, err := q.db.Query(ctx, getPendingInvoicesForGeneration, nextRedemptionDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingInvoicesForGenerationRow{}
	for rows.Next() {
		var i GetPendingInvoicesForGenerationRow
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.NextRedemptionDate,
			&i.CurrentPeriodEnd,
			&i.TotalAmountInCents,
			&i.Currency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentInvoices = `-- name: GetRecentInvoices :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies FROM invoices 
WHERE workspace_id = $1 
    AND created_date >= $2 
    AND deleted_at IS NULL
ORDER BY created_date DESC
LIMIT $3 OFFSET $4
`

type GetRecentInvoicesParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	CreatedDate pgtype.Timestamptz `json:"created_date"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

func (q *Queries) GetRecentInvoices(ctx context.Context, arg GetRecentInvoicesParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getRecentInvoices,
		arg.WorkspaceID,
		arg.CreatedDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.InvoiceNumber,
			&i.SubtotalCents,
			&i.DiscountCents,
			&i.PaymentLinkID,
			&i.DelegationAddress,
			&i.QrCodeData,
			&i.TaxAmountCents,
			&i.TaxDetails,
			&i.CustomerTaxID,
			&i.CustomerJurisdictionID,
			&i.ReverseChargeApplies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionForInvoicing = `-- name: GetSubscriptionForInvoicing :one
SELECT 
    s.id, s.num_id, s.customer_id, s.product_id, s.workspace_id, s.product_token_id, s.external_id, s.token_amount, s.delegation_id, s.customer_wallet_id, s.status, s.current_period_start, s.current_period_end, s.next_redemption_date, s.total_redemptions, s.total_amount_in_cents, s.metadata, s.payment_sync_status, s.payment_synced_at, s.payment_sync_version, s.payment_provider, s.created_at, s.updated_at, s.deleted_at, s.currency, s.cancel_at, s.cancelled_at, s.cancellation_reason, s.paused_at, s.pause_ends_at, s.trial_start, s.trial_end,
    c.id as cust_id,
    c.name as customer_name,
    c.email as customer_email,
    c.is_business,
    c.business_name,
    c.tax_id,
    c.billing_country,
    c.billing_state,
    c.billing_city,
    c.billing_postal_code,
    w.id as wallet_id,
    w.wallet_address
FROM subscriptions s
JOIN customers c ON s.customer_id = c.id
LEFT JOIN customer_wallets cw ON s.customer_wallet_id = cw.id
LEFT JOIN wallets w ON cw.wallet_id = w.id
WHERE s.id = $1
AND s.deleted_at IS NULL
`

type GetSubscriptionForInvoicingRow struct {
	ID                 uuid.UUID          `json:"id"`
	NumID              int64              `json:"num_id"`
	CustomerID         uuid.UUID          `json:"customer_id"`
	ProductID          uuid.UUID          `json:"product_id"`
	WorkspaceID        uuid.UUID          `json:"workspace_id"`
	ProductTokenID     uuid.UUID          `json:"product_token_id"`
	ExternalID         pgtype.Text        `json:"external_id"`
	TokenAmount        int32              `json:"token_amount"`
	DelegationID       uuid.UUID          `json:"delegation_id"`
	CustomerWalletID   pgtype.UUID        `json:"customer_wallet_id"`
	Status             SubscriptionStatus `json:"status"`
	CurrentPeriodStart pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamptz `json:"current_period_end"`
	NextRedemptionDate pgtype.Timestamptz `json:"next_redemption_date"`
	TotalRedemptions   int32              `json:"total_redemptions"`
	TotalAmountInCents int32              `json:"total_amount_in_cents"`
	Metadata           []byte             `json:"metadata"`
	PaymentSyncStatus  pgtype.Text        `json:"payment_sync_status"`
	PaymentSyncedAt    pgtype.Timestamptz `json:"payment_synced_at"`
	PaymentSyncVersion pgtype.Int4        `json:"payment_sync_version"`
	PaymentProvider    pgtype.Text        `json:"payment_provider"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	DeletedAt          pgtype.Timestamptz `json:"deleted_at"`
	Currency           pgtype.Text        `json:"currency"`
	CancelAt           pgtype.Timestamptz `json:"cancel_at"`
	CancelledAt        pgtype.Timestamptz `json:"cancelled_at"`
	CancellationReason pgtype.Text        `json:"cancellation_reason"`
	PausedAt           pgtype.Timestamptz `json:"paused_at"`
	PauseEndsAt        pgtype.Timestamptz `json:"pause_ends_at"`
	TrialStart         pgtype.Timestamptz `json:"trial_start"`
	TrialEnd           pgtype.Timestamptz `json:"trial_end"`
	CustID             uuid.UUID          `json:"cust_id"`
	CustomerName       pgtype.Text        `json:"customer_name"`
	CustomerEmail      pgtype.Text        `json:"customer_email"`
	IsBusiness         pgtype.Bool        `json:"is_business"`
	BusinessName       pgtype.Text        `json:"business_name"`
	TaxID              pgtype.Text        `json:"tax_id"`
	BillingCountry     pgtype.Text        `json:"billing_country"`
	BillingState       pgtype.Text        `json:"billing_state"`
	BillingCity        pgtype.Text        `json:"billing_city"`
	BillingPostalCode  pgtype.Text        `json:"billing_postal_code"`
	WalletID           pgtype.UUID        `json:"wallet_id"`
	WalletAddress      pgtype.Text        `json:"wallet_address"`
}

func (q *Queries) GetSubscriptionForInvoicing(ctx context.Context, id uuid.UUID) (GetSubscriptionForInvoicingRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionForInvoicing, id)
	var i GetSubscriptionForInvoicingRow
	err := row.Scan(
		&i.ID,
		&i.NumID,
		&i.CustomerID,
		&i.ProductID,
		&i.WorkspaceID,
		&i.ProductTokenID,
		&i.ExternalID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.PaymentSyncVersion,
		&i.PaymentProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Currency,
		&i.CancelAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.PausedAt,
		&i.PauseEndsAt,
		&i.TrialStart,
		&i.TrialEnd,
		&i.CustID,
		&i.CustomerName,
		&i.CustomerEmail,
		&i.IsBusiness,
		&i.BusinessName,
		&i.TaxID,
		&i.BillingCountry,
		&i.BillingState,
		&i.BillingCity,
		&i.BillingPostalCode,
		&i.WalletID,
		&i.WalletAddress,
	)
	return i, err
}

const getSubscriptionWithLineItems = `-- name: GetSubscriptionWithLineItems :many
SELECT 
    s.id as subscription_id,
    s.workspace_id,
    s.customer_id,
    s.status as subscription_status,
    s.current_period_start,
    s.current_period_end,
    s.next_redemption_date,
    s.total_amount_in_cents,
    sli.id as line_item_id,
    sli.product_id,
    sli.quantity,
    sli.unit_amount_in_pennies,
    sli.total_amount_in_pennies,
    sli.line_item_type,
    sli.currency as line_item_currency,
    sli.price_type,
    sli.interval_type as line_item_interval_type,
    p.name as product_name,
    p.description as product_description,
    p.product_type,
    p.interval_type as product_interval_type,
    p.term_length
FROM subscriptions s
JOIN subscription_line_items sli ON s.id = sli.subscription_id
LEFT JOIN products p ON sli.product_id = p.id
WHERE s.id = $1 
AND sli.is_active = true
ORDER BY 
    CASE WHEN sli.line_item_type = 'base' THEN 0 ELSE 1 END,
    sli.created_at
`

type GetSubscriptionWithLineItemsRow struct {
	SubscriptionID       uuid.UUID          `json:"subscription_id"`
	WorkspaceID          uuid.UUID          `json:"workspace_id"`
	CustomerID           uuid.UUID          `json:"customer_id"`
	SubscriptionStatus   SubscriptionStatus `json:"subscription_status"`
	CurrentPeriodStart   pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd     pgtype.Timestamptz `json:"current_period_end"`
	NextRedemptionDate   pgtype.Timestamptz `json:"next_redemption_date"`
	TotalAmountInCents   int32              `json:"total_amount_in_cents"`
	LineItemID           uuid.UUID          `json:"line_item_id"`
	ProductID            uuid.UUID          `json:"product_id"`
	Quantity             int32              `json:"quantity"`
	UnitAmountInPennies  int32              `json:"unit_amount_in_pennies"`
	TotalAmountInPennies int32              `json:"total_amount_in_pennies"`
	LineItemType         string             `json:"line_item_type"`
	LineItemCurrency     string             `json:"line_item_currency"`
	PriceType            PriceType          `json:"price_type"`
	LineItemIntervalType NullIntervalType   `json:"line_item_interval_type"`
	ProductName          pgtype.Text        `json:"product_name"`
	ProductDescription   pgtype.Text        `json:"product_description"`
	ProductType          pgtype.Text        `json:"product_type"`
	ProductIntervalType  NullIntervalType   `json:"product_interval_type"`
	TermLength           pgtype.Int4        `json:"term_length"`
}

func (q *Queries) GetSubscriptionWithLineItems(ctx context.Context, id uuid.UUID) ([]GetSubscriptionWithLineItemsRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionWithLineItems, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSubscriptionWithLineItemsRow{}
	for rows.Next() {
		var i GetSubscriptionWithLineItemsRow
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionStatus,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalAmountInCents,
			&i.LineItemID,
			&i.ProductID,
			&i.Quantity,
			&i.UnitAmountInPennies,
			&i.TotalAmountInPennies,
			&i.LineItemType,
			&i.LineItemCurrency,
			&i.PriceType,
			&i.LineItemIntervalType,
			&i.ProductName,
			&i.ProductDescription,
			&i.ProductType,
			&i.ProductIntervalType,
			&i.TermLength,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnpaidInvoices = `-- name: GetUnpaidInvoices :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies FROM invoices 
WHERE workspace_id = $1 
    AND status IN ('open', 'draft') 
    AND amount_remaining > 0 
    AND deleted_at IS NULL
ORDER BY created_date DESC
LIMIT $2 OFFSET $3
`

type GetUnpaidInvoicesParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) GetUnpaidInvoices(ctx context.Context, arg GetUnpaidInvoicesParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getUnpaidInvoices, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.InvoiceNumber,
			&i.SubtotalCents,
			&i.DiscountCents,
			&i.PaymentLinkID,
			&i.DelegationAddress,
			&i.QrCodeData,
			&i.TaxAmountCents,
			&i.TaxDetails,
			&i.CustomerTaxID,
			&i.CustomerJurisdictionID,
			&i.ReverseChargeApplies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkInvoiceToPaymentLink = `-- name: LinkInvoiceToPaymentLink :one
UPDATE invoices SET
    payment_link_id = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
RETURNING id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies
`

type LinkInvoiceToPaymentLinkParams struct {
	ID            uuid.UUID   `json:"id"`
	WorkspaceID   uuid.UUID   `json:"workspace_id"`
	PaymentLinkID pgtype.UUID `json:"payment_link_id"`
}

func (q *Queries) LinkInvoiceToPaymentLink(ctx context.Context, arg LinkInvoiceToPaymentLinkParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, linkInvoiceToPaymentLink, arg.ID, arg.WorkspaceID, arg.PaymentLinkID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvoiceNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.PaymentLinkID,
		&i.DelegationAddress,
		&i.QrCodeData,
		&i.TaxAmountCents,
		&i.TaxDetails,
		&i.CustomerTaxID,
		&i.CustomerJurisdictionID,
		&i.ReverseChargeApplies,
	)
	return i, err
}

const listInvoicesByCustomer = `-- name: ListInvoicesByCustomer :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies FROM invoices 
WHERE workspace_id = $1 AND customer_id = $2 AND deleted_at IS NULL
ORDER BY created_date DESC
LIMIT $3 OFFSET $4
`

type ListInvoicesByCustomerParams struct {
	WorkspaceID uuid.UUID   `json:"workspace_id"`
	CustomerID  pgtype.UUID `json:"customer_id"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

func (q *Queries) ListInvoicesByCustomer(ctx context.Context, arg ListInvoicesByCustomerParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByCustomer,
		arg.WorkspaceID,
		arg.CustomerID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.InvoiceNumber,
			&i.SubtotalCents,
			&i.DiscountCents,
			&i.PaymentLinkID,
			&i.DelegationAddress,
			&i.QrCodeData,
			&i.TaxAmountCents,
			&i.TaxDetails,
			&i.CustomerTaxID,
			&i.CustomerJurisdictionID,
			&i.ReverseChargeApplies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByProvider = `-- name: ListInvoicesByProvider :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies FROM invoices 
WHERE workspace_id = $1 AND payment_provider = $2 AND deleted_at IS NULL
ORDER BY created_date DESC
LIMIT $3 OFFSET $4
`

type ListInvoicesByProviderParams struct {
	WorkspaceID     uuid.UUID   `json:"workspace_id"`
	PaymentProvider pgtype.Text `json:"payment_provider"`
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
}

func (q *Queries) ListInvoicesByProvider(ctx context.Context, arg ListInvoicesByProviderParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByProvider,
		arg.WorkspaceID,
		arg.PaymentProvider,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.InvoiceNumber,
			&i.SubtotalCents,
			&i.DiscountCents,
			&i.PaymentLinkID,
			&i.DelegationAddress,
			&i.QrCodeData,
			&i.TaxAmountCents,
			&i.TaxDetails,
			&i.CustomerTaxID,
			&i.CustomerJurisdictionID,
			&i.ReverseChargeApplies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByStatus = `-- name: ListInvoicesByStatus :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies FROM invoices 
WHERE workspace_id = $1 AND status = $2 AND deleted_at IS NULL
ORDER BY created_date DESC
LIMIT $3 OFFSET $4
`

type ListInvoicesByStatusParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Status      string    `json:"status"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListInvoicesByStatus(ctx context.Context, arg ListInvoicesByStatusParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByStatus,
		arg.WorkspaceID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.InvoiceNumber,
			&i.SubtotalCents,
			&i.DiscountCents,
			&i.PaymentLinkID,
			&i.DelegationAddress,
			&i.QrCodeData,
			&i.TaxAmountCents,
			&i.TaxDetails,
			&i.CustomerTaxID,
			&i.CustomerJurisdictionID,
			&i.ReverseChargeApplies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesBySubscription = `-- name: ListInvoicesBySubscription :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies FROM invoices 
WHERE workspace_id = $1 AND subscription_id = $2 AND deleted_at IS NULL
ORDER BY created_date DESC
LIMIT $3 OFFSET $4
`

type ListInvoicesBySubscriptionParams struct {
	WorkspaceID    uuid.UUID   `json:"workspace_id"`
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

func (q *Queries) ListInvoicesBySubscription(ctx context.Context, arg ListInvoicesBySubscriptionParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesBySubscription,
		arg.WorkspaceID,
		arg.SubscriptionID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.InvoiceNumber,
			&i.SubtotalCents,
			&i.DiscountCents,
			&i.PaymentLinkID,
			&i.DelegationAddress,
			&i.QrCodeData,
			&i.TaxAmountCents,
			&i.TaxDetails,
			&i.CustomerTaxID,
			&i.CustomerJurisdictionID,
			&i.ReverseChargeApplies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesBySyncStatus = `-- name: ListInvoicesBySyncStatus :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies FROM invoices 
WHERE workspace_id = $1 AND payment_sync_status = $2 AND deleted_at IS NULL
ORDER BY created_date DESC
LIMIT $3 OFFSET $4
`

type ListInvoicesBySyncStatusParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
	Limit             int32       `json:"limit"`
	Offset            int32       `json:"offset"`
}

func (q *Queries) ListInvoicesBySyncStatus(ctx context.Context, arg ListInvoicesBySyncStatusParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesBySyncStatus,
		arg.WorkspaceID,
		arg.PaymentSyncStatus,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.InvoiceNumber,
			&i.SubtotalCents,
			&i.DiscountCents,
			&i.PaymentLinkID,
			&i.DelegationAddress,
			&i.QrCodeData,
			&i.TaxAmountCents,
			&i.TaxDetails,
			&i.CustomerTaxID,
			&i.CustomerJurisdictionID,
			&i.ReverseChargeApplies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByWorkspace = `-- name: ListInvoicesByWorkspace :many
SELECT id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies FROM invoices 
WHERE workspace_id = $1 AND deleted_at IS NULL
ORDER BY created_date DESC
LIMIT $2 OFFSET $3
`

type ListInvoicesByWorkspaceParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListInvoicesByWorkspace(ctx context.Context, arg ListInvoicesByWorkspaceParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.ExternalID,
			&i.ExternalCustomerID,
			&i.ExternalSubscriptionID,
			&i.Status,
			&i.CollectionMethod,
			&i.AmountDue,
			&i.AmountPaid,
			&i.AmountRemaining,
			&i.Currency,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedDate,
			&i.InvoicePdf,
			&i.HostedInvoiceUrl,
			&i.ChargeID,
			&i.PaymentIntentID,
			&i.LineItems,
			&i.TaxAmount,
			&i.TotalTaxAmounts,
			&i.BillingReason,
			&i.PaidOutOfBand,
			&i.PaymentProvider,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.AttemptCount,
			&i.NextPaymentAttempt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.InvoiceNumber,
			&i.SubtotalCents,
			&i.DiscountCents,
			&i.PaymentLinkID,
			&i.DelegationAddress,
			&i.QrCodeData,
			&i.TaxAmountCents,
			&i.TaxDetails,
			&i.CustomerTaxID,
			&i.CustomerJurisdictionID,
			&i.ReverseChargeApplies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markInvoicePaid = `-- name: MarkInvoicePaid :one
UPDATE invoices SET
    status = 'paid',
    amount_paid = amount_due,
    amount_remaining = 0,
    paid_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 
AND status = 'open'
AND deleted_at IS NULL
RETURNING id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies
`

type MarkInvoicePaidParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) MarkInvoicePaid(ctx context.Context, arg MarkInvoicePaidParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, markInvoicePaid, arg.ID, arg.WorkspaceID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvoiceNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.PaymentLinkID,
		&i.DelegationAddress,
		&i.QrCodeData,
		&i.TaxAmountCents,
		&i.TaxDetails,
		&i.CustomerTaxID,
		&i.CustomerJurisdictionID,
		&i.ReverseChargeApplies,
	)
	return i, err
}

const updateInvoice = `-- name: UpdateInvoice :one
UPDATE invoices SET
    customer_id = $3,
    subscription_id = $4,
    status = $5,
    collection_method = $6,
    amount_due = $7,
    amount_paid = $8,
    amount_remaining = $9,
    currency = $10,
    due_date = $11,
    paid_at = $12,
    invoice_pdf = $13,
    hosted_invoice_url = $14,
    charge_id = $15,
    payment_intent_id = $16,
    line_items = $17,
    tax_amount = $18,
    total_tax_amounts = $19,
    billing_reason = $20,
    paid_out_of_band = $21,
    attempt_count = $22,
    next_payment_attempt = $23,
    metadata = $24,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
RETURNING id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies
`

type UpdateInvoiceParams struct {
	ID                 uuid.UUID          `json:"id"`
	WorkspaceID        uuid.UUID          `json:"workspace_id"`
	CustomerID         pgtype.UUID        `json:"customer_id"`
	SubscriptionID     pgtype.UUID        `json:"subscription_id"`
	Status             string             `json:"status"`
	CollectionMethod   pgtype.Text        `json:"collection_method"`
	AmountDue          int32              `json:"amount_due"`
	AmountPaid         int32              `json:"amount_paid"`
	AmountRemaining    int32              `json:"amount_remaining"`
	Currency           string             `json:"currency"`
	DueDate            pgtype.Timestamptz `json:"due_date"`
	PaidAt             pgtype.Timestamptz `json:"paid_at"`
	InvoicePdf         pgtype.Text        `json:"invoice_pdf"`
	HostedInvoiceUrl   pgtype.Text        `json:"hosted_invoice_url"`
	ChargeID           pgtype.Text        `json:"charge_id"`
	PaymentIntentID    pgtype.Text        `json:"payment_intent_id"`
	LineItems          []byte             `json:"line_items"`
	TaxAmount          pgtype.Int4        `json:"tax_amount"`
	TotalTaxAmounts    []byte             `json:"total_tax_amounts"`
	BillingReason      pgtype.Text        `json:"billing_reason"`
	PaidOutOfBand      pgtype.Bool        `json:"paid_out_of_band"`
	AttemptCount       pgtype.Int4        `json:"attempt_count"`
	NextPaymentAttempt pgtype.Timestamptz `json:"next_payment_attempt"`
	Metadata           []byte             `json:"metadata"`
}

func (q *Queries) UpdateInvoice(ctx context.Context, arg UpdateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoice,
		arg.ID,
		arg.WorkspaceID,
		arg.CustomerID,
		arg.SubscriptionID,
		arg.Status,
		arg.CollectionMethod,
		arg.AmountDue,
		arg.AmountPaid,
		arg.AmountRemaining,
		arg.Currency,
		arg.DueDate,
		arg.PaidAt,
		arg.InvoicePdf,
		arg.HostedInvoiceUrl,
		arg.ChargeID,
		arg.PaymentIntentID,
		arg.LineItems,
		arg.TaxAmount,
		arg.TotalTaxAmounts,
		arg.BillingReason,
		arg.PaidOutOfBand,
		arg.AttemptCount,
		arg.NextPaymentAttempt,
		arg.Metadata,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvoiceNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.PaymentLinkID,
		&i.DelegationAddress,
		&i.QrCodeData,
		&i.TaxAmountCents,
		&i.TaxDetails,
		&i.CustomerTaxID,
		&i.CustomerJurisdictionID,
		&i.ReverseChargeApplies,
	)
	return i, err
}

const updateInvoiceDetails = `-- name: UpdateInvoiceDetails :one
UPDATE invoices SET
    subtotal_cents = $3,
    discount_cents = $4,
    tax_amount_cents = $5,
    tax_details = $6,
    amount_due = $7,
    customer_tax_id = $8,
    customer_jurisdiction_id = $9,
    reverse_charge_applies = $10,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
RETURNING id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies
`

type UpdateInvoiceDetailsParams struct {
	ID                     uuid.UUID   `json:"id"`
	WorkspaceID            uuid.UUID   `json:"workspace_id"`
	SubtotalCents          pgtype.Int8 `json:"subtotal_cents"`
	DiscountCents          pgtype.Int8 `json:"discount_cents"`
	TaxAmountCents         int64       `json:"tax_amount_cents"`
	TaxDetails             []byte      `json:"tax_details"`
	AmountDue              int32       `json:"amount_due"`
	CustomerTaxID          pgtype.Text `json:"customer_tax_id"`
	CustomerJurisdictionID pgtype.UUID `json:"customer_jurisdiction_id"`
	ReverseChargeApplies   pgtype.Bool `json:"reverse_charge_applies"`
}

func (q *Queries) UpdateInvoiceDetails(ctx context.Context, arg UpdateInvoiceDetailsParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoiceDetails,
		arg.ID,
		arg.WorkspaceID,
		arg.SubtotalCents,
		arg.DiscountCents,
		arg.TaxAmountCents,
		arg.TaxDetails,
		arg.AmountDue,
		arg.CustomerTaxID,
		arg.CustomerJurisdictionID,
		arg.ReverseChargeApplies,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvoiceNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.PaymentLinkID,
		&i.DelegationAddress,
		&i.QrCodeData,
		&i.TaxAmountCents,
		&i.TaxDetails,
		&i.CustomerTaxID,
		&i.CustomerJurisdictionID,
		&i.ReverseChargeApplies,
	)
	return i, err
}

const updateInvoiceNumber = `-- name: UpdateInvoiceNumber :one
UPDATE invoices SET
    invoice_number = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
RETURNING id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies
`

type UpdateInvoiceNumberParams struct {
	ID            uuid.UUID   `json:"id"`
	WorkspaceID   uuid.UUID   `json:"workspace_id"`
	InvoiceNumber pgtype.Text `json:"invoice_number"`
}

func (q *Queries) UpdateInvoiceNumber(ctx context.Context, arg UpdateInvoiceNumberParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoiceNumber, arg.ID, arg.WorkspaceID, arg.InvoiceNumber)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvoiceNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.PaymentLinkID,
		&i.DelegationAddress,
		&i.QrCodeData,
		&i.TaxAmountCents,
		&i.TaxDetails,
		&i.CustomerTaxID,
		&i.CustomerJurisdictionID,
		&i.ReverseChargeApplies,
	)
	return i, err
}

const updateInvoiceQRCode = `-- name: UpdateInvoiceQRCode :one
UPDATE invoices SET
    qr_code_data = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
RETURNING id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies
`

type UpdateInvoiceQRCodeParams struct {
	ID          uuid.UUID   `json:"id"`
	WorkspaceID uuid.UUID   `json:"workspace_id"`
	QrCodeData  pgtype.Text `json:"qr_code_data"`
}

func (q *Queries) UpdateInvoiceQRCode(ctx context.Context, arg UpdateInvoiceQRCodeParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoiceQRCode, arg.ID, arg.WorkspaceID, arg.QrCodeData)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvoiceNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.PaymentLinkID,
		&i.DelegationAddress,
		&i.QrCodeData,
		&i.TaxAmountCents,
		&i.TaxDetails,
		&i.CustomerTaxID,
		&i.CustomerJurisdictionID,
		&i.ReverseChargeApplies,
	)
	return i, err
}

const updateInvoiceStatus = `-- name: UpdateInvoiceStatus :one
UPDATE invoices SET
    status = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
RETURNING id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies
`

type UpdateInvoiceStatusParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Status      string    `json:"status"`
}

func (q *Queries) UpdateInvoiceStatus(ctx context.Context, arg UpdateInvoiceStatusParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoiceStatus, arg.ID, arg.WorkspaceID, arg.Status)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvoiceNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.PaymentLinkID,
		&i.DelegationAddress,
		&i.QrCodeData,
		&i.TaxAmountCents,
		&i.TaxDetails,
		&i.CustomerTaxID,
		&i.CustomerJurisdictionID,
		&i.ReverseChargeApplies,
	)
	return i, err
}

const updateInvoiceSyncStatus = `-- name: UpdateInvoiceSyncStatus :one
UPDATE invoices SET
    payment_sync_status = $3,
    payment_synced_at = CASE 
        WHEN $3 = 'synced' THEN CURRENT_TIMESTAMP 
        ELSE payment_synced_at 
    END,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
RETURNING id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies
`

type UpdateInvoiceSyncStatusParams struct {
	ID                uuid.UUID   `json:"id"`
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	PaymentSyncStatus pgtype.Text `json:"payment_sync_status"`
}

func (q *Queries) UpdateInvoiceSyncStatus(ctx context.Context, arg UpdateInvoiceSyncStatusParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoiceSyncStatus, arg.ID, arg.WorkspaceID, arg.PaymentSyncStatus)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvoiceNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.PaymentLinkID,
		&i.DelegationAddress,
		&i.QrCodeData,
		&i.TaxAmountCents,
		&i.TaxDetails,
		&i.CustomerTaxID,
		&i.CustomerJurisdictionID,
		&i.ReverseChargeApplies,
	)
	return i, err
}

const upsertInvoice = `-- name: UpsertInvoice :one
INSERT INTO invoices (
    workspace_id,
    customer_id,
    subscription_id,
    external_id,
    external_customer_id,
    external_subscription_id,
    status,
    collection_method,
    amount_due,
    amount_paid,
    amount_remaining,
    currency,
    due_date,
    paid_at,
    created_date,
    invoice_pdf,
    hosted_invoice_url,
    charge_id,
    payment_intent_id,
    line_items,
    tax_amount,
    total_tax_amounts,
    billing_reason,
    paid_out_of_band,
    payment_provider,
    payment_sync_status,
    payment_synced_at,
    attempt_count,
    next_payment_attempt,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
    $21, $22, $23, $24, $25, $26, $27, $28, $29, $30
)
ON CONFLICT (workspace_id, external_id, payment_provider)
DO UPDATE SET
    customer_id = EXCLUDED.customer_id,
    subscription_id = EXCLUDED.subscription_id,
    status = EXCLUDED.status,
    collection_method = EXCLUDED.collection_method,
    amount_due = EXCLUDED.amount_due,
    amount_paid = EXCLUDED.amount_paid,
    amount_remaining = EXCLUDED.amount_remaining,
    currency = EXCLUDED.currency,
    due_date = EXCLUDED.due_date,
    paid_at = EXCLUDED.paid_at,
    created_date = EXCLUDED.created_date,
    invoice_pdf = EXCLUDED.invoice_pdf,
    hosted_invoice_url = EXCLUDED.hosted_invoice_url,
    charge_id = EXCLUDED.charge_id,
    payment_intent_id = EXCLUDED.payment_intent_id,
    line_items = EXCLUDED.line_items,
    tax_amount = EXCLUDED.tax_amount,
    total_tax_amounts = EXCLUDED.total_tax_amounts,
    billing_reason = EXCLUDED.billing_reason,
    paid_out_of_band = EXCLUDED.paid_out_of_band,
    payment_sync_status = EXCLUDED.payment_sync_status,
    payment_synced_at = EXCLUDED.payment_synced_at,
    attempt_count = EXCLUDED.attempt_count,
    next_payment_attempt = EXCLUDED.next_payment_attempt,
    metadata = EXCLUDED.metadata,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies
`

type UpsertInvoiceParams struct {
	WorkspaceID            uuid.UUID          `json:"workspace_id"`
	CustomerID             pgtype.UUID        `json:"customer_id"`
	SubscriptionID         pgtype.UUID        `json:"subscription_id"`
	ExternalID             string             `json:"external_id"`
	ExternalCustomerID     pgtype.Text        `json:"external_customer_id"`
	ExternalSubscriptionID pgtype.Text        `json:"external_subscription_id"`
	Status                 string             `json:"status"`
	CollectionMethod       pgtype.Text        `json:"collection_method"`
	AmountDue              int32              `json:"amount_due"`
	AmountPaid             int32              `json:"amount_paid"`
	AmountRemaining        int32              `json:"amount_remaining"`
	Currency               string             `json:"currency"`
	DueDate                pgtype.Timestamptz `json:"due_date"`
	PaidAt                 pgtype.Timestamptz `json:"paid_at"`
	CreatedDate            pgtype.Timestamptz `json:"created_date"`
	InvoicePdf             pgtype.Text        `json:"invoice_pdf"`
	HostedInvoiceUrl       pgtype.Text        `json:"hosted_invoice_url"`
	ChargeID               pgtype.Text        `json:"charge_id"`
	PaymentIntentID        pgtype.Text        `json:"payment_intent_id"`
	LineItems              []byte             `json:"line_items"`
	TaxAmount              pgtype.Int4        `json:"tax_amount"`
	TotalTaxAmounts        []byte             `json:"total_tax_amounts"`
	BillingReason          pgtype.Text        `json:"billing_reason"`
	PaidOutOfBand          pgtype.Bool        `json:"paid_out_of_band"`
	PaymentProvider        pgtype.Text        `json:"payment_provider"`
	PaymentSyncStatus      pgtype.Text        `json:"payment_sync_status"`
	PaymentSyncedAt        pgtype.Timestamptz `json:"payment_synced_at"`
	AttemptCount           pgtype.Int4        `json:"attempt_count"`
	NextPaymentAttempt     pgtype.Timestamptz `json:"next_payment_attempt"`
	Metadata               []byte             `json:"metadata"`
}

func (q *Queries) UpsertInvoice(ctx context.Context, arg UpsertInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, upsertInvoice,
		arg.WorkspaceID,
		arg.CustomerID,
		arg.SubscriptionID,
		arg.ExternalID,
		arg.ExternalCustomerID,
		arg.ExternalSubscriptionID,
		arg.Status,
		arg.CollectionMethod,
		arg.AmountDue,
		arg.AmountPaid,
		arg.AmountRemaining,
		arg.Currency,
		arg.DueDate,
		arg.PaidAt,
		arg.CreatedDate,
		arg.InvoicePdf,
		arg.HostedInvoiceUrl,
		arg.ChargeID,
		arg.PaymentIntentID,
		arg.LineItems,
		arg.TaxAmount,
		arg.TotalTaxAmounts,
		arg.BillingReason,
		arg.PaidOutOfBand,
		arg.PaymentProvider,
		arg.PaymentSyncStatus,
		arg.PaymentSyncedAt,
		arg.AttemptCount,
		arg.NextPaymentAttempt,
		arg.Metadata,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvoiceNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.PaymentLinkID,
		&i.DelegationAddress,
		&i.QrCodeData,
		&i.TaxAmountCents,
		&i.TaxDetails,
		&i.CustomerTaxID,
		&i.CustomerJurisdictionID,
		&i.ReverseChargeApplies,
	)
	return i, err
}

const voidInvoice = `-- name: VoidInvoice :one
UPDATE invoices SET
    status = 'void',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 
AND status IN ('draft', 'open')
AND deleted_at IS NULL
RETURNING id, workspace_id, customer_id, subscription_id, external_id, external_customer_id, external_subscription_id, status, collection_method, amount_due, amount_paid, amount_remaining, currency, due_date, paid_at, created_date, invoice_pdf, hosted_invoice_url, charge_id, payment_intent_id, line_items, tax_amount, total_tax_amounts, billing_reason, paid_out_of_band, payment_provider, payment_sync_status, payment_synced_at, attempt_count, next_payment_attempt, metadata, created_at, updated_at, deleted_at, invoice_number, subtotal_cents, discount_cents, payment_link_id, delegation_address, qr_code_data, tax_amount_cents, tax_details, customer_tax_id, customer_jurisdiction_id, reverse_charge_applies
`

type VoidInvoiceParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) VoidInvoice(ctx context.Context, arg VoidInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, voidInvoice, arg.ID, arg.WorkspaceID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.ExternalID,
		&i.ExternalCustomerID,
		&i.ExternalSubscriptionID,
		&i.Status,
		&i.CollectionMethod,
		&i.AmountDue,
		&i.AmountPaid,
		&i.AmountRemaining,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedDate,
		&i.InvoicePdf,
		&i.HostedInvoiceUrl,
		&i.ChargeID,
		&i.PaymentIntentID,
		&i.LineItems,
		&i.TaxAmount,
		&i.TotalTaxAmounts,
		&i.BillingReason,
		&i.PaidOutOfBand,
		&i.PaymentProvider,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.AttemptCount,
		&i.NextPaymentAttempt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.InvoiceNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.PaymentLinkID,
		&i.DelegationAddress,
		&i.QrCodeData,
		&i.TaxAmountCents,
		&i.TaxDetails,
		&i.CustomerTaxID,
		&i.CustomerJurisdictionID,
		&i.ReverseChargeApplies,
	)
	return i, err
}
