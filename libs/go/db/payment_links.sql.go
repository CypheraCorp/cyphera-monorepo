// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: payment_links.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkSlugExists = `-- name: CheckSlugExists :one
SELECT EXISTS(
    SELECT 1 FROM payment_links 
    WHERE slug = $1 AND deleted_at IS NULL
) as exists
`

func (q *Queries) CheckSlugExists(ctx context.Context, slug string) (bool, error) {
	row := q.db.QueryRow(ctx, checkSlugExists, slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createPaymentLink = `-- name: CreatePaymentLink :one
INSERT INTO payment_links (
    workspace_id,
    slug,
    status,
    product_id,
    price_id,
    amount_in_cents,
    currency,
    payment_type,
    collect_email,
    collect_shipping,
    collect_name,
    expires_at,
    max_uses,
    redirect_url,
    qr_code_url,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
)
RETURNING id, workspace_id, slug, status, product_id, price_id, amount_in_cents, currency, payment_type, collect_email, collect_shipping, collect_name, expires_at, max_uses, used_count, redirect_url, qr_code_url, metadata, created_at, updated_at, deleted_at
`

type CreatePaymentLinkParams struct {
	WorkspaceID     uuid.UUID          `json:"workspace_id"`
	Slug            string             `json:"slug"`
	Status          string             `json:"status"`
	ProductID       pgtype.UUID        `json:"product_id"`
	PriceID         pgtype.UUID        `json:"price_id"`
	AmountInCents   pgtype.Int8        `json:"amount_in_cents"`
	Currency        pgtype.Text        `json:"currency"`
	PaymentType     pgtype.Text        `json:"payment_type"`
	CollectEmail    pgtype.Bool        `json:"collect_email"`
	CollectShipping pgtype.Bool        `json:"collect_shipping"`
	CollectName     pgtype.Bool        `json:"collect_name"`
	ExpiresAt       pgtype.Timestamptz `json:"expires_at"`
	MaxUses         pgtype.Int4        `json:"max_uses"`
	RedirectUrl     pgtype.Text        `json:"redirect_url"`
	QrCodeUrl       pgtype.Text        `json:"qr_code_url"`
	Metadata        []byte             `json:"metadata"`
}

func (q *Queries) CreatePaymentLink(ctx context.Context, arg CreatePaymentLinkParams) (PaymentLink, error) {
	row := q.db.QueryRow(ctx, createPaymentLink,
		arg.WorkspaceID,
		arg.Slug,
		arg.Status,
		arg.ProductID,
		arg.PriceID,
		arg.AmountInCents,
		arg.Currency,
		arg.PaymentType,
		arg.CollectEmail,
		arg.CollectShipping,
		arg.CollectName,
		arg.ExpiresAt,
		arg.MaxUses,
		arg.RedirectUrl,
		arg.QrCodeUrl,
		arg.Metadata,
	)
	var i PaymentLink
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Slug,
		&i.Status,
		&i.ProductID,
		&i.PriceID,
		&i.AmountInCents,
		&i.Currency,
		&i.PaymentType,
		&i.CollectEmail,
		&i.CollectShipping,
		&i.CollectName,
		&i.ExpiresAt,
		&i.MaxUses,
		&i.UsedCount,
		&i.RedirectUrl,
		&i.QrCodeUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deactivatePaymentLink = `-- name: DeactivatePaymentLink :one
UPDATE payment_links
SET 
    status = 'inactive',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
RETURNING id, workspace_id, slug, status, product_id, price_id, amount_in_cents, currency, payment_type, collect_email, collect_shipping, collect_name, expires_at, max_uses, used_count, redirect_url, qr_code_url, metadata, created_at, updated_at, deleted_at
`

type DeactivatePaymentLinkParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) DeactivatePaymentLink(ctx context.Context, arg DeactivatePaymentLinkParams) (PaymentLink, error) {
	row := q.db.QueryRow(ctx, deactivatePaymentLink, arg.ID, arg.WorkspaceID)
	var i PaymentLink
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Slug,
		&i.Status,
		&i.ProductID,
		&i.PriceID,
		&i.AmountInCents,
		&i.Currency,
		&i.PaymentType,
		&i.CollectEmail,
		&i.CollectShipping,
		&i.CollectName,
		&i.ExpiresAt,
		&i.MaxUses,
		&i.UsedCount,
		&i.RedirectUrl,
		&i.QrCodeUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deletePaymentLink = `-- name: DeletePaymentLink :one
UPDATE payment_links
SET 
    deleted_at = CURRENT_TIMESTAMP,
    status = 'inactive'
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
RETURNING id, workspace_id, slug, status, product_id, price_id, amount_in_cents, currency, payment_type, collect_email, collect_shipping, collect_name, expires_at, max_uses, used_count, redirect_url, qr_code_url, metadata, created_at, updated_at, deleted_at
`

type DeletePaymentLinkParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) DeletePaymentLink(ctx context.Context, arg DeletePaymentLinkParams) (PaymentLink, error) {
	row := q.db.QueryRow(ctx, deletePaymentLink, arg.ID, arg.WorkspaceID)
	var i PaymentLink
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Slug,
		&i.Status,
		&i.ProductID,
		&i.PriceID,
		&i.AmountInCents,
		&i.Currency,
		&i.PaymentType,
		&i.CollectEmail,
		&i.CollectShipping,
		&i.CollectName,
		&i.ExpiresAt,
		&i.MaxUses,
		&i.UsedCount,
		&i.RedirectUrl,
		&i.QrCodeUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const expirePaymentLinks = `-- name: ExpirePaymentLinks :exec
UPDATE payment_links
SET 
    status = 'expired',
    updated_at = CURRENT_TIMESTAMP
WHERE status = 'active' 
    AND expires_at IS NOT NULL 
    AND expires_at <= CURRENT_TIMESTAMP
    AND deleted_at IS NULL
`

func (q *Queries) ExpirePaymentLinks(ctx context.Context) error {
	_, err := q.db.Exec(ctx, expirePaymentLinks)
	return err
}

const getActivePaymentLinkBySlug = `-- name: GetActivePaymentLinkBySlug :one
SELECT id, workspace_id, slug, status, product_id, price_id, amount_in_cents, currency, payment_type, collect_email, collect_shipping, collect_name, expires_at, max_uses, used_count, redirect_url, qr_code_url, metadata, created_at, updated_at, deleted_at FROM payment_links
WHERE slug = $1 
    AND status = 'active'
    AND deleted_at IS NULL
    AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
    AND (max_uses IS NULL OR used_count < max_uses)
`

func (q *Queries) GetActivePaymentLinkBySlug(ctx context.Context, slug string) (PaymentLink, error) {
	row := q.db.QueryRow(ctx, getActivePaymentLinkBySlug, slug)
	var i PaymentLink
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Slug,
		&i.Status,
		&i.ProductID,
		&i.PriceID,
		&i.AmountInCents,
		&i.Currency,
		&i.PaymentType,
		&i.CollectEmail,
		&i.CollectShipping,
		&i.CollectName,
		&i.ExpiresAt,
		&i.MaxUses,
		&i.UsedCount,
		&i.RedirectUrl,
		&i.QrCodeUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPaymentLink = `-- name: GetPaymentLink :one
SELECT id, workspace_id, slug, status, product_id, price_id, amount_in_cents, currency, payment_type, collect_email, collect_shipping, collect_name, expires_at, max_uses, used_count, redirect_url, qr_code_url, metadata, created_at, updated_at, deleted_at FROM payment_links
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
`

type GetPaymentLinkParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) GetPaymentLink(ctx context.Context, arg GetPaymentLinkParams) (PaymentLink, error) {
	row := q.db.QueryRow(ctx, getPaymentLink, arg.ID, arg.WorkspaceID)
	var i PaymentLink
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Slug,
		&i.Status,
		&i.ProductID,
		&i.PriceID,
		&i.AmountInCents,
		&i.Currency,
		&i.PaymentType,
		&i.CollectEmail,
		&i.CollectShipping,
		&i.CollectName,
		&i.ExpiresAt,
		&i.MaxUses,
		&i.UsedCount,
		&i.RedirectUrl,
		&i.QrCodeUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPaymentLinkBySlug = `-- name: GetPaymentLinkBySlug :one
SELECT id, workspace_id, slug, status, product_id, price_id, amount_in_cents, currency, payment_type, collect_email, collect_shipping, collect_name, expires_at, max_uses, used_count, redirect_url, qr_code_url, metadata, created_at, updated_at, deleted_at FROM payment_links
WHERE slug = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPaymentLinkBySlug(ctx context.Context, slug string) (PaymentLink, error) {
	row := q.db.QueryRow(ctx, getPaymentLinkBySlug, slug)
	var i PaymentLink
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Slug,
		&i.Status,
		&i.ProductID,
		&i.PriceID,
		&i.AmountInCents,
		&i.Currency,
		&i.PaymentType,
		&i.CollectEmail,
		&i.CollectShipping,
		&i.CollectName,
		&i.ExpiresAt,
		&i.MaxUses,
		&i.UsedCount,
		&i.RedirectUrl,
		&i.QrCodeUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPaymentLinkStats = `-- name: GetPaymentLinkStats :one
SELECT 
    COUNT(*) as total_links,
    COUNT(*) FILTER (WHERE status = 'active') as active_links,
    COUNT(*) FILTER (WHERE status = 'inactive') as inactive_links,
    COUNT(*) FILTER (WHERE status = 'expired') as expired_links,
    SUM(used_count) as total_uses
FROM payment_links
WHERE workspace_id = $1 AND deleted_at IS NULL
`

type GetPaymentLinkStatsRow struct {
	TotalLinks    int64 `json:"total_links"`
	ActiveLinks   int64 `json:"active_links"`
	InactiveLinks int64 `json:"inactive_links"`
	ExpiredLinks  int64 `json:"expired_links"`
	TotalUses     int64 `json:"total_uses"`
}

func (q *Queries) GetPaymentLinkStats(ctx context.Context, workspaceID uuid.UUID) (GetPaymentLinkStatsRow, error) {
	row := q.db.QueryRow(ctx, getPaymentLinkStats, workspaceID)
	var i GetPaymentLinkStatsRow
	err := row.Scan(
		&i.TotalLinks,
		&i.ActiveLinks,
		&i.InactiveLinks,
		&i.ExpiredLinks,
		&i.TotalUses,
	)
	return i, err
}

const getPaymentLinksByProduct = `-- name: GetPaymentLinksByProduct :many
SELECT id, workspace_id, slug, status, product_id, price_id, amount_in_cents, currency, payment_type, collect_email, collect_shipping, collect_name, expires_at, max_uses, used_count, redirect_url, qr_code_url, metadata, created_at, updated_at, deleted_at FROM payment_links
WHERE workspace_id = $1 
    AND product_id = $2
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

type GetPaymentLinksByProductParams struct {
	WorkspaceID uuid.UUID   `json:"workspace_id"`
	ProductID   pgtype.UUID `json:"product_id"`
}

func (q *Queries) GetPaymentLinksByProduct(ctx context.Context, arg GetPaymentLinksByProductParams) ([]PaymentLink, error) {
	rows, err := q.db.Query(ctx, getPaymentLinksByProduct, arg.WorkspaceID, arg.ProductID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentLink{}
	for rows.Next() {
		var i PaymentLink
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Slug,
			&i.Status,
			&i.ProductID,
			&i.PriceID,
			&i.AmountInCents,
			&i.Currency,
			&i.PaymentType,
			&i.CollectEmail,
			&i.CollectShipping,
			&i.CollectName,
			&i.ExpiresAt,
			&i.MaxUses,
			&i.UsedCount,
			&i.RedirectUrl,
			&i.QrCodeUrl,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentLinksByWorkspace = `-- name: GetPaymentLinksByWorkspace :many
SELECT id, workspace_id, slug, status, product_id, price_id, amount_in_cents, currency, payment_type, collect_email, collect_shipping, collect_name, expires_at, max_uses, used_count, redirect_url, qr_code_url, metadata, created_at, updated_at, deleted_at FROM payment_links
WHERE workspace_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetPaymentLinksByWorkspaceParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) GetPaymentLinksByWorkspace(ctx context.Context, arg GetPaymentLinksByWorkspaceParams) ([]PaymentLink, error) {
	rows, err := q.db.Query(ctx, getPaymentLinksByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentLink{}
	for rows.Next() {
		var i PaymentLink
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Slug,
			&i.Status,
			&i.ProductID,
			&i.PriceID,
			&i.AmountInCents,
			&i.Currency,
			&i.PaymentType,
			&i.CollectEmail,
			&i.CollectShipping,
			&i.CollectName,
			&i.ExpiresAt,
			&i.MaxUses,
			&i.UsedCount,
			&i.RedirectUrl,
			&i.QrCodeUrl,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopPaymentLinks = `-- name: GetTopPaymentLinks :many
SELECT 
    pl.id, pl.workspace_id, pl.slug, pl.status, pl.product_id, pl.price_id, pl.amount_in_cents, pl.currency, pl.payment_type, pl.collect_email, pl.collect_shipping, pl.collect_name, pl.expires_at, pl.max_uses, pl.used_count, pl.redirect_url, pl.qr_code_url, pl.metadata, pl.created_at, pl.updated_at, pl.deleted_at,
    p.name as product_name,
    pr.unit_amount_in_pennies as price_amount
FROM payment_links pl
LEFT JOIN products p ON pl.product_id = p.id
LEFT JOIN prices pr ON pl.price_id = pr.id
WHERE pl.workspace_id = $1 
    AND pl.deleted_at IS NULL
ORDER BY pl.used_count DESC
LIMIT $2
`

type GetTopPaymentLinksParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
}

type GetTopPaymentLinksRow struct {
	ID              uuid.UUID          `json:"id"`
	WorkspaceID     uuid.UUID          `json:"workspace_id"`
	Slug            string             `json:"slug"`
	Status          string             `json:"status"`
	ProductID       pgtype.UUID        `json:"product_id"`
	PriceID         pgtype.UUID        `json:"price_id"`
	AmountInCents   pgtype.Int8        `json:"amount_in_cents"`
	Currency        pgtype.Text        `json:"currency"`
	PaymentType     pgtype.Text        `json:"payment_type"`
	CollectEmail    pgtype.Bool        `json:"collect_email"`
	CollectShipping pgtype.Bool        `json:"collect_shipping"`
	CollectName     pgtype.Bool        `json:"collect_name"`
	ExpiresAt       pgtype.Timestamptz `json:"expires_at"`
	MaxUses         pgtype.Int4        `json:"max_uses"`
	UsedCount       pgtype.Int4        `json:"used_count"`
	RedirectUrl     pgtype.Text        `json:"redirect_url"`
	QrCodeUrl       pgtype.Text        `json:"qr_code_url"`
	Metadata        []byte             `json:"metadata"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	ProductName     pgtype.Text        `json:"product_name"`
	PriceAmount     pgtype.Int4        `json:"price_amount"`
}

func (q *Queries) GetTopPaymentLinks(ctx context.Context, arg GetTopPaymentLinksParams) ([]GetTopPaymentLinksRow, error) {
	rows, err := q.db.Query(ctx, getTopPaymentLinks, arg.WorkspaceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopPaymentLinksRow{}
	for rows.Next() {
		var i GetTopPaymentLinksRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Slug,
			&i.Status,
			&i.ProductID,
			&i.PriceID,
			&i.AmountInCents,
			&i.Currency,
			&i.PaymentType,
			&i.CollectEmail,
			&i.CollectShipping,
			&i.CollectName,
			&i.ExpiresAt,
			&i.MaxUses,
			&i.UsedCount,
			&i.RedirectUrl,
			&i.QrCodeUrl,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProductName,
			&i.PriceAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementPaymentLinkUsage = `-- name: IncrementPaymentLinkUsage :one
UPDATE payment_links
SET 
    used_count = used_count + 1,
    status = CASE 
        WHEN max_uses IS NOT NULL AND used_count + 1 >= max_uses THEN 'inactive'
        ELSE status
    END,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2
RETURNING id, workspace_id, slug, status, product_id, price_id, amount_in_cents, currency, payment_type, collect_email, collect_shipping, collect_name, expires_at, max_uses, used_count, redirect_url, qr_code_url, metadata, created_at, updated_at, deleted_at
`

type IncrementPaymentLinkUsageParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) IncrementPaymentLinkUsage(ctx context.Context, arg IncrementPaymentLinkUsageParams) (PaymentLink, error) {
	row := q.db.QueryRow(ctx, incrementPaymentLinkUsage, arg.ID, arg.WorkspaceID)
	var i PaymentLink
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Slug,
		&i.Status,
		&i.ProductID,
		&i.PriceID,
		&i.AmountInCents,
		&i.Currency,
		&i.PaymentType,
		&i.CollectEmail,
		&i.CollectShipping,
		&i.CollectName,
		&i.ExpiresAt,
		&i.MaxUses,
		&i.UsedCount,
		&i.RedirectUrl,
		&i.QrCodeUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updatePaymentLink = `-- name: UpdatePaymentLink :one
UPDATE payment_links
SET 
    status = COALESCE($3, status),
    expires_at = COALESCE($4, expires_at),
    max_uses = COALESCE($5, max_uses),
    redirect_url = COALESCE($6, redirect_url),
    metadata = COALESCE($7, metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
RETURNING id, workspace_id, slug, status, product_id, price_id, amount_in_cents, currency, payment_type, collect_email, collect_shipping, collect_name, expires_at, max_uses, used_count, redirect_url, qr_code_url, metadata, created_at, updated_at, deleted_at
`

type UpdatePaymentLinkParams struct {
	ID          uuid.UUID          `json:"id"`
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	Status      string             `json:"status"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	MaxUses     pgtype.Int4        `json:"max_uses"`
	RedirectUrl pgtype.Text        `json:"redirect_url"`
	Metadata    []byte             `json:"metadata"`
}

func (q *Queries) UpdatePaymentLink(ctx context.Context, arg UpdatePaymentLinkParams) (PaymentLink, error) {
	row := q.db.QueryRow(ctx, updatePaymentLink,
		arg.ID,
		arg.WorkspaceID,
		arg.Status,
		arg.ExpiresAt,
		arg.MaxUses,
		arg.RedirectUrl,
		arg.Metadata,
	)
	var i PaymentLink
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Slug,
		&i.Status,
		&i.ProductID,
		&i.PriceID,
		&i.AmountInCents,
		&i.Currency,
		&i.PaymentType,
		&i.CollectEmail,
		&i.CollectShipping,
		&i.CollectName,
		&i.ExpiresAt,
		&i.MaxUses,
		&i.UsedCount,
		&i.RedirectUrl,
		&i.QrCodeUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updatePaymentLinkQRCode = `-- name: UpdatePaymentLinkQRCode :one
UPDATE payment_links
SET 
    qr_code_url = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND deleted_at IS NULL
RETURNING id, workspace_id, slug, status, product_id, price_id, amount_in_cents, currency, payment_type, collect_email, collect_shipping, collect_name, expires_at, max_uses, used_count, redirect_url, qr_code_url, metadata, created_at, updated_at, deleted_at
`

type UpdatePaymentLinkQRCodeParams struct {
	ID          uuid.UUID   `json:"id"`
	WorkspaceID uuid.UUID   `json:"workspace_id"`
	QrCodeUrl   pgtype.Text `json:"qr_code_url"`
}

func (q *Queries) UpdatePaymentLinkQRCode(ctx context.Context, arg UpdatePaymentLinkQRCodeParams) (PaymentLink, error) {
	row := q.db.QueryRow(ctx, updatePaymentLinkQRCode, arg.ID, arg.WorkspaceID, arg.QrCodeUrl)
	var i PaymentLink
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Slug,
		&i.Status,
		&i.ProductID,
		&i.PriceID,
		&i.AmountInCents,
		&i.Currency,
		&i.PaymentType,
		&i.CollectEmail,
		&i.CollectShipping,
		&i.CollectName,
		&i.ExpiresAt,
		&i.MaxUses,
		&i.UsedCount,
		&i.RedirectUrl,
		&i.QrCodeUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
