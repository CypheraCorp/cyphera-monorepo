// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: payments.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countPaymentsByWorkspace = `-- name: CountPaymentsByWorkspace :one
SELECT COUNT(*) FROM payments
WHERE workspace_id = $1
`

func (q *Queries) CountPaymentsByWorkspace(ctx context.Context, workspaceID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPaymentsByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (
    workspace_id,
    invoice_id,
    subscription_id,
    subscription_event,
    customer_id,
    amount_in_cents,
    currency,
    status,
    payment_method,
    transaction_hash,
    network_id,
    token_id,
    crypto_amount,
    exchange_rate,
    has_gas_fee,
    gas_fee_usd_cents,
    gas_sponsored,
    external_payment_id,
    payment_provider,
    product_amount_cents,
    tax_amount_cents,
    gas_amount_cents,
    discount_amount_cents,
    error_message,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25
)
RETURNING id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at
`

type CreatePaymentParams struct {
	WorkspaceID         uuid.UUID      `json:"workspace_id"`
	InvoiceID           pgtype.UUID    `json:"invoice_id"`
	SubscriptionID      pgtype.UUID    `json:"subscription_id"`
	SubscriptionEvent   pgtype.UUID    `json:"subscription_event"`
	CustomerID          uuid.UUID      `json:"customer_id"`
	AmountInCents       int64          `json:"amount_in_cents"`
	Currency            string         `json:"currency"`
	Status              string         `json:"status"`
	PaymentMethod       string         `json:"payment_method"`
	TransactionHash     pgtype.Text    `json:"transaction_hash"`
	NetworkID           pgtype.UUID    `json:"network_id"`
	TokenID             pgtype.UUID    `json:"token_id"`
	CryptoAmount        pgtype.Numeric `json:"crypto_amount"`
	ExchangeRate        pgtype.Numeric `json:"exchange_rate"`
	HasGasFee           pgtype.Bool    `json:"has_gas_fee"`
	GasFeeUsdCents      pgtype.Int8    `json:"gas_fee_usd_cents"`
	GasSponsored        pgtype.Bool    `json:"gas_sponsored"`
	ExternalPaymentID   pgtype.Text    `json:"external_payment_id"`
	PaymentProvider     pgtype.Text    `json:"payment_provider"`
	ProductAmountCents  int64          `json:"product_amount_cents"`
	TaxAmountCents      pgtype.Int8    `json:"tax_amount_cents"`
	GasAmountCents      pgtype.Int8    `json:"gas_amount_cents"`
	DiscountAmountCents pgtype.Int8    `json:"discount_amount_cents"`
	ErrorMessage        pgtype.Text    `json:"error_message"`
	Metadata            []byte         `json:"metadata"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.WorkspaceID,
		arg.InvoiceID,
		arg.SubscriptionID,
		arg.SubscriptionEvent,
		arg.CustomerID,
		arg.AmountInCents,
		arg.Currency,
		arg.Status,
		arg.PaymentMethod,
		arg.TransactionHash,
		arg.NetworkID,
		arg.TokenID,
		arg.CryptoAmount,
		arg.ExchangeRate,
		arg.HasGasFee,
		arg.GasFeeUsdCents,
		arg.GasSponsored,
		arg.ExternalPaymentID,
		arg.PaymentProvider,
		arg.ProductAmountCents,
		arg.TaxAmountCents,
		arg.GasAmountCents,
		arg.DiscountAmountCents,
		arg.ErrorMessage,
		arg.Metadata,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InvoiceID,
		&i.SubscriptionID,
		&i.SubscriptionEvent,
		&i.CustomerID,
		&i.AmountInCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionHash,
		&i.NetworkID,
		&i.TokenID,
		&i.CryptoAmount,
		&i.ExchangeRate,
		&i.HasGasFee,
		&i.GasFeeUsdCents,
		&i.GasSponsored,
		&i.ExternalPaymentID,
		&i.PaymentProvider,
		&i.ProductAmountCents,
		&i.TaxAmountCents,
		&i.GasAmountCents,
		&i.DiscountAmountCents,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

type CreatePaymentBatchParams struct {
	WorkspaceID   uuid.UUID `json:"workspace_id"`
	CustomerID    uuid.UUID `json:"customer_id"`
	AmountInCents int64     `json:"amount_in_cents"`
	Currency      string    `json:"currency"`
	Status        string    `json:"status"`
	PaymentMethod string    `json:"payment_method"`
	Metadata      []byte    `json:"metadata"`
}

const getPayment = `-- name: GetPayment :one
SELECT id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at FROM payments
WHERE id = $1 AND workspace_id = $2
`

type GetPaymentParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) GetPayment(ctx context.Context, arg GetPaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, getPayment, arg.ID, arg.WorkspaceID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InvoiceID,
		&i.SubscriptionID,
		&i.SubscriptionEvent,
		&i.CustomerID,
		&i.AmountInCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionHash,
		&i.NetworkID,
		&i.TokenID,
		&i.CryptoAmount,
		&i.ExchangeRate,
		&i.HasGasFee,
		&i.GasFeeUsdCents,
		&i.GasSponsored,
		&i.ExternalPaymentID,
		&i.PaymentProvider,
		&i.ProductAmountCents,
		&i.TaxAmountCents,
		&i.GasAmountCents,
		&i.DiscountAmountCents,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentBySubscriptionEvent = `-- name: GetPaymentBySubscriptionEvent :one
SELECT id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at FROM payments
WHERE subscription_event = $1
LIMIT 1
`

func (q *Queries) GetPaymentBySubscriptionEvent(ctx context.Context, subscriptionEvent pgtype.UUID) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentBySubscriptionEvent, subscriptionEvent)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InvoiceID,
		&i.SubscriptionID,
		&i.SubscriptionEvent,
		&i.CustomerID,
		&i.AmountInCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionHash,
		&i.NetworkID,
		&i.TokenID,
		&i.CryptoAmount,
		&i.ExchangeRate,
		&i.HasGasFee,
		&i.GasFeeUsdCents,
		&i.GasSponsored,
		&i.ExternalPaymentID,
		&i.PaymentProvider,
		&i.ProductAmountCents,
		&i.TaxAmountCents,
		&i.GasAmountCents,
		&i.DiscountAmountCents,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentByTransactionHash = `-- name: GetPaymentByTransactionHash :one
SELECT id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at FROM payments
WHERE transaction_hash = $1
`

func (q *Queries) GetPaymentByTransactionHash(ctx context.Context, transactionHash pgtype.Text) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByTransactionHash, transactionHash)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InvoiceID,
		&i.SubscriptionID,
		&i.SubscriptionEvent,
		&i.CustomerID,
		&i.AmountInCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionHash,
		&i.NetworkID,
		&i.TokenID,
		&i.CryptoAmount,
		&i.ExchangeRate,
		&i.HasGasFee,
		&i.GasFeeUsdCents,
		&i.GasSponsored,
		&i.ExternalPaymentID,
		&i.PaymentProvider,
		&i.ProductAmountCents,
		&i.TaxAmountCents,
		&i.GasAmountCents,
		&i.DiscountAmountCents,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentMetrics = `-- name: GetPaymentMetrics :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'completed') as completed_count,
    COUNT(*) FILTER (WHERE status = 'failed') as failed_count,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_count,
    SUM(amount_in_cents) FILTER (WHERE status = 'completed') as total_completed_cents,
    SUM(gas_fee_usd_cents) FILTER (WHERE status = 'completed' AND has_gas_fee = true) as total_gas_fees_cents,
    SUM(gas_fee_usd_cents) FILTER (WHERE status = 'completed' AND gas_sponsored = true) as sponsored_gas_fees_cents
FROM payments
WHERE workspace_id = $1
    AND created_at >= $2
    AND created_at < $3
    AND currency = $4
`

type GetPaymentMetricsParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Currency    string             `json:"currency"`
}

type GetPaymentMetricsRow struct {
	CompletedCount        int64 `json:"completed_count"`
	FailedCount           int64 `json:"failed_count"`
	PendingCount          int64 `json:"pending_count"`
	TotalCompletedCents   int64 `json:"total_completed_cents"`
	TotalGasFeesCents     int64 `json:"total_gas_fees_cents"`
	SponsoredGasFeesCents int64 `json:"sponsored_gas_fees_cents"`
}

func (q *Queries) GetPaymentMetrics(ctx context.Context, arg GetPaymentMetricsParams) (GetPaymentMetricsRow, error) {
	row := q.db.QueryRow(ctx, getPaymentMetrics,
		arg.WorkspaceID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Currency,
	)
	var i GetPaymentMetricsRow
	err := row.Scan(
		&i.CompletedCount,
		&i.FailedCount,
		&i.PendingCount,
		&i.TotalCompletedCents,
		&i.TotalGasFeesCents,
		&i.SponsoredGasFeesCents,
	)
	return i, err
}

const getPaymentVolume = `-- name: GetPaymentVolume :one
SELECT 
    SUM(amount_in_cents) as total_volume_cents,
    COUNT(*) as payment_count
FROM payments
WHERE workspace_id = $1
    AND status = 'completed'
    AND completed_at >= $2
    AND completed_at < $3
    AND currency = $4
`

type GetPaymentVolumeParams struct {
	WorkspaceID   uuid.UUID          `json:"workspace_id"`
	CompletedAt   pgtype.Timestamptz `json:"completed_at"`
	CompletedAt_2 pgtype.Timestamptz `json:"completed_at_2"`
	Currency      string             `json:"currency"`
}

type GetPaymentVolumeRow struct {
	TotalVolumeCents int64 `json:"total_volume_cents"`
	PaymentCount     int64 `json:"payment_count"`
}

func (q *Queries) GetPaymentVolume(ctx context.Context, arg GetPaymentVolumeParams) (GetPaymentVolumeRow, error) {
	row := q.db.QueryRow(ctx, getPaymentVolume,
		arg.WorkspaceID,
		arg.CompletedAt,
		arg.CompletedAt_2,
		arg.Currency,
	)
	var i GetPaymentVolumeRow
	err := row.Scan(&i.TotalVolumeCents, &i.PaymentCount)
	return i, err
}

const getPaymentWithGasDetails = `-- name: GetPaymentWithGasDetails :one
SELECT 
    p.id, p.workspace_id, p.invoice_id, p.subscription_id, p.subscription_event, p.customer_id, p.amount_in_cents, p.currency, p.status, p.payment_method, p.transaction_hash, p.network_id, p.token_id, p.crypto_amount, p.exchange_rate, p.has_gas_fee, p.gas_fee_usd_cents, p.gas_sponsored, p.external_payment_id, p.payment_provider, p.product_amount_cents, p.tax_amount_cents, p.gas_amount_cents, p.discount_amount_cents, p.initiated_at, p.completed_at, p.failed_at, p.error_message, p.metadata, p.created_at, p.updated_at,
    gfp.id as gas_fee_payment_id,
    gfp.gas_fee_wei,
    gfp.gas_price_gwei,
    gfp.gas_units_used,
    gfp.max_gas_units,
    gfp.base_fee_gwei,
    gfp.priority_fee_gwei,
    gfp.payment_token_id as gas_payment_token_id,
    gfp.payment_token_amount as gas_payment_token_amount,
    gfp.payment_method as gas_payment_method,
    gfp.sponsor_type,
    gfp.sponsor_id,
    gfp.sponsor_workspace_id,
    gfp.block_number,
    gfp.block_timestamp
FROM payments p
LEFT JOIN gas_fee_payments gfp ON gfp.payment_id = p.id
WHERE p.id = $1 AND p.workspace_id = $2
`

type GetPaymentWithGasDetailsParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

type GetPaymentWithGasDetailsRow struct {
	ID                    uuid.UUID          `json:"id"`
	WorkspaceID           uuid.UUID          `json:"workspace_id"`
	InvoiceID             pgtype.UUID        `json:"invoice_id"`
	SubscriptionID        pgtype.UUID        `json:"subscription_id"`
	SubscriptionEvent     pgtype.UUID        `json:"subscription_event"`
	CustomerID            uuid.UUID          `json:"customer_id"`
	AmountInCents         int64              `json:"amount_in_cents"`
	Currency              string             `json:"currency"`
	Status                string             `json:"status"`
	PaymentMethod         string             `json:"payment_method"`
	TransactionHash       pgtype.Text        `json:"transaction_hash"`
	NetworkID             pgtype.UUID        `json:"network_id"`
	TokenID               pgtype.UUID        `json:"token_id"`
	CryptoAmount          pgtype.Numeric     `json:"crypto_amount"`
	ExchangeRate          pgtype.Numeric     `json:"exchange_rate"`
	HasGasFee             pgtype.Bool        `json:"has_gas_fee"`
	GasFeeUsdCents        pgtype.Int8        `json:"gas_fee_usd_cents"`
	GasSponsored          pgtype.Bool        `json:"gas_sponsored"`
	ExternalPaymentID     pgtype.Text        `json:"external_payment_id"`
	PaymentProvider       pgtype.Text        `json:"payment_provider"`
	ProductAmountCents    int64              `json:"product_amount_cents"`
	TaxAmountCents        pgtype.Int8        `json:"tax_amount_cents"`
	GasAmountCents        pgtype.Int8        `json:"gas_amount_cents"`
	DiscountAmountCents   pgtype.Int8        `json:"discount_amount_cents"`
	InitiatedAt           pgtype.Timestamptz `json:"initiated_at"`
	CompletedAt           pgtype.Timestamptz `json:"completed_at"`
	FailedAt              pgtype.Timestamptz `json:"failed_at"`
	ErrorMessage          pgtype.Text        `json:"error_message"`
	Metadata              []byte             `json:"metadata"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	GasFeePaymentID       pgtype.UUID        `json:"gas_fee_payment_id"`
	GasFeeWei             pgtype.Text        `json:"gas_fee_wei"`
	GasPriceGwei          pgtype.Text        `json:"gas_price_gwei"`
	GasUnitsUsed          pgtype.Int8        `json:"gas_units_used"`
	MaxGasUnits           pgtype.Int8        `json:"max_gas_units"`
	BaseFeeGwei           pgtype.Text        `json:"base_fee_gwei"`
	PriorityFeeGwei       pgtype.Text        `json:"priority_fee_gwei"`
	GasPaymentTokenID     pgtype.UUID        `json:"gas_payment_token_id"`
	GasPaymentTokenAmount pgtype.Text        `json:"gas_payment_token_amount"`
	GasPaymentMethod      pgtype.Text        `json:"gas_payment_method"`
	SponsorType           pgtype.Text        `json:"sponsor_type"`
	SponsorID             pgtype.UUID        `json:"sponsor_id"`
	SponsorWorkspaceID    pgtype.UUID        `json:"sponsor_workspace_id"`
	BlockNumber           pgtype.Int8        `json:"block_number"`
	BlockTimestamp        pgtype.Timestamptz `json:"block_timestamp"`
}

func (q *Queries) GetPaymentWithGasDetails(ctx context.Context, arg GetPaymentWithGasDetailsParams) (GetPaymentWithGasDetailsRow, error) {
	row := q.db.QueryRow(ctx, getPaymentWithGasDetails, arg.ID, arg.WorkspaceID)
	var i GetPaymentWithGasDetailsRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InvoiceID,
		&i.SubscriptionID,
		&i.SubscriptionEvent,
		&i.CustomerID,
		&i.AmountInCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionHash,
		&i.NetworkID,
		&i.TokenID,
		&i.CryptoAmount,
		&i.ExchangeRate,
		&i.HasGasFee,
		&i.GasFeeUsdCents,
		&i.GasSponsored,
		&i.ExternalPaymentID,
		&i.PaymentProvider,
		&i.ProductAmountCents,
		&i.TaxAmountCents,
		&i.GasAmountCents,
		&i.DiscountAmountCents,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GasFeePaymentID,
		&i.GasFeeWei,
		&i.GasPriceGwei,
		&i.GasUnitsUsed,
		&i.MaxGasUnits,
		&i.BaseFeeGwei,
		&i.PriorityFeeGwei,
		&i.GasPaymentTokenID,
		&i.GasPaymentTokenAmount,
		&i.GasPaymentMethod,
		&i.SponsorType,
		&i.SponsorID,
		&i.SponsorWorkspaceID,
		&i.BlockNumber,
		&i.BlockTimestamp,
	)
	return i, err
}

const getPaymentsByCustomer = `-- name: GetPaymentsByCustomer :many
SELECT id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at FROM payments
WHERE customer_id = $1 AND workspace_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetPaymentsByCustomerParams struct {
	CustomerID  uuid.UUID `json:"customer_id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) GetPaymentsByCustomer(ctx context.Context, arg GetPaymentsByCustomerParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByCustomer,
		arg.CustomerID,
		arg.WorkspaceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InvoiceID,
			&i.SubscriptionID,
			&i.SubscriptionEvent,
			&i.CustomerID,
			&i.AmountInCents,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.TransactionHash,
			&i.NetworkID,
			&i.TokenID,
			&i.CryptoAmount,
			&i.ExchangeRate,
			&i.HasGasFee,
			&i.GasFeeUsdCents,
			&i.GasSponsored,
			&i.ExternalPaymentID,
			&i.PaymentProvider,
			&i.ProductAmountCents,
			&i.TaxAmountCents,
			&i.GasAmountCents,
			&i.DiscountAmountCents,
			&i.InitiatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByCustomerWithGas = `-- name: GetPaymentsByCustomerWithGas :many
SELECT 
    p.id, p.workspace_id, p.invoice_id, p.subscription_id, p.subscription_event, p.customer_id, p.amount_in_cents, p.currency, p.status, p.payment_method, p.transaction_hash, p.network_id, p.token_id, p.crypto_amount, p.exchange_rate, p.has_gas_fee, p.gas_fee_usd_cents, p.gas_sponsored, p.external_payment_id, p.payment_provider, p.product_amount_cents, p.tax_amount_cents, p.gas_amount_cents, p.discount_amount_cents, p.initiated_at, p.completed_at, p.failed_at, p.error_message, p.metadata, p.created_at, p.updated_at,
    CASE 
        WHEN p.has_gas_fee THEN gfp.gas_fee_wei
        ELSE NULL
    END as gas_fee_wei,
    CASE 
        WHEN p.has_gas_fee THEN gfp.sponsor_type
        ELSE NULL
    END as gas_sponsor_type
FROM payments p
LEFT JOIN gas_fee_payments gfp ON gfp.payment_id = p.id
WHERE p.customer_id = $1 AND p.workspace_id = $2
ORDER BY p.created_at DESC
LIMIT $3 OFFSET $4
`

type GetPaymentsByCustomerWithGasParams struct {
	CustomerID  uuid.UUID `json:"customer_id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type GetPaymentsByCustomerWithGasRow struct {
	ID                  uuid.UUID          `json:"id"`
	WorkspaceID         uuid.UUID          `json:"workspace_id"`
	InvoiceID           pgtype.UUID        `json:"invoice_id"`
	SubscriptionID      pgtype.UUID        `json:"subscription_id"`
	SubscriptionEvent   pgtype.UUID        `json:"subscription_event"`
	CustomerID          uuid.UUID          `json:"customer_id"`
	AmountInCents       int64              `json:"amount_in_cents"`
	Currency            string             `json:"currency"`
	Status              string             `json:"status"`
	PaymentMethod       string             `json:"payment_method"`
	TransactionHash     pgtype.Text        `json:"transaction_hash"`
	NetworkID           pgtype.UUID        `json:"network_id"`
	TokenID             pgtype.UUID        `json:"token_id"`
	CryptoAmount        pgtype.Numeric     `json:"crypto_amount"`
	ExchangeRate        pgtype.Numeric     `json:"exchange_rate"`
	HasGasFee           pgtype.Bool        `json:"has_gas_fee"`
	GasFeeUsdCents      pgtype.Int8        `json:"gas_fee_usd_cents"`
	GasSponsored        pgtype.Bool        `json:"gas_sponsored"`
	ExternalPaymentID   pgtype.Text        `json:"external_payment_id"`
	PaymentProvider     pgtype.Text        `json:"payment_provider"`
	ProductAmountCents  int64              `json:"product_amount_cents"`
	TaxAmountCents      pgtype.Int8        `json:"tax_amount_cents"`
	GasAmountCents      pgtype.Int8        `json:"gas_amount_cents"`
	DiscountAmountCents pgtype.Int8        `json:"discount_amount_cents"`
	InitiatedAt         pgtype.Timestamptz `json:"initiated_at"`
	CompletedAt         pgtype.Timestamptz `json:"completed_at"`
	FailedAt            pgtype.Timestamptz `json:"failed_at"`
	ErrorMessage        pgtype.Text        `json:"error_message"`
	Metadata            []byte             `json:"metadata"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	GasFeeWei           interface{}        `json:"gas_fee_wei"`
	GasSponsorType      interface{}        `json:"gas_sponsor_type"`
}

func (q *Queries) GetPaymentsByCustomerWithGas(ctx context.Context, arg GetPaymentsByCustomerWithGasParams) ([]GetPaymentsByCustomerWithGasRow, error) {
	rows, err := q.db.Query(ctx, getPaymentsByCustomerWithGas,
		arg.CustomerID,
		arg.WorkspaceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaymentsByCustomerWithGasRow{}
	for rows.Next() {
		var i GetPaymentsByCustomerWithGasRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InvoiceID,
			&i.SubscriptionID,
			&i.SubscriptionEvent,
			&i.CustomerID,
			&i.AmountInCents,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.TransactionHash,
			&i.NetworkID,
			&i.TokenID,
			&i.CryptoAmount,
			&i.ExchangeRate,
			&i.HasGasFee,
			&i.GasFeeUsdCents,
			&i.GasSponsored,
			&i.ExternalPaymentID,
			&i.PaymentProvider,
			&i.ProductAmountCents,
			&i.TaxAmountCents,
			&i.GasAmountCents,
			&i.DiscountAmountCents,
			&i.InitiatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GasFeeWei,
			&i.GasSponsorType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByDateRange = `-- name: GetPaymentsByDateRange :many
SELECT id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at FROM payments
WHERE workspace_id = $1
    AND created_at >= $2
    AND created_at < $3
    AND currency = $4
ORDER BY created_at DESC
`

type GetPaymentsByDateRangeParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Currency    string             `json:"currency"`
}

func (q *Queries) GetPaymentsByDateRange(ctx context.Context, arg GetPaymentsByDateRangeParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByDateRange,
		arg.WorkspaceID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Currency,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InvoiceID,
			&i.SubscriptionID,
			&i.SubscriptionEvent,
			&i.CustomerID,
			&i.AmountInCents,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.TransactionHash,
			&i.NetworkID,
			&i.TokenID,
			&i.CryptoAmount,
			&i.ExchangeRate,
			&i.HasGasFee,
			&i.GasFeeUsdCents,
			&i.GasSponsored,
			&i.ExternalPaymentID,
			&i.PaymentProvider,
			&i.ProductAmountCents,
			&i.TaxAmountCents,
			&i.GasAmountCents,
			&i.DiscountAmountCents,
			&i.InitiatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByExternalId = `-- name: GetPaymentsByExternalId :one
SELECT id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at FROM payments
WHERE workspace_id = $1
    AND external_payment_id = $2
    AND payment_provider = $3
`

type GetPaymentsByExternalIdParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	ExternalPaymentID pgtype.Text `json:"external_payment_id"`
	PaymentProvider   pgtype.Text `json:"payment_provider"`
}

func (q *Queries) GetPaymentsByExternalId(ctx context.Context, arg GetPaymentsByExternalIdParams) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentsByExternalId, arg.WorkspaceID, arg.ExternalPaymentID, arg.PaymentProvider)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InvoiceID,
		&i.SubscriptionID,
		&i.SubscriptionEvent,
		&i.CustomerID,
		&i.AmountInCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionHash,
		&i.NetworkID,
		&i.TokenID,
		&i.CryptoAmount,
		&i.ExchangeRate,
		&i.HasGasFee,
		&i.GasFeeUsdCents,
		&i.GasSponsored,
		&i.ExternalPaymentID,
		&i.PaymentProvider,
		&i.ProductAmountCents,
		&i.TaxAmountCents,
		&i.GasAmountCents,
		&i.DiscountAmountCents,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentsByInvoice = `-- name: GetPaymentsByInvoice :many
SELECT id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at FROM payments
WHERE invoice_id = $1 AND workspace_id = $2
ORDER BY created_at DESC
`

type GetPaymentsByInvoiceParams struct {
	InvoiceID   pgtype.UUID `json:"invoice_id"`
	WorkspaceID uuid.UUID   `json:"workspace_id"`
}

func (q *Queries) GetPaymentsByInvoice(ctx context.Context, arg GetPaymentsByInvoiceParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByInvoice, arg.InvoiceID, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InvoiceID,
			&i.SubscriptionID,
			&i.SubscriptionEvent,
			&i.CustomerID,
			&i.AmountInCents,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.TransactionHash,
			&i.NetworkID,
			&i.TokenID,
			&i.CryptoAmount,
			&i.ExchangeRate,
			&i.HasGasFee,
			&i.GasFeeUsdCents,
			&i.GasSponsored,
			&i.ExternalPaymentID,
			&i.PaymentProvider,
			&i.ProductAmountCents,
			&i.TaxAmountCents,
			&i.GasAmountCents,
			&i.DiscountAmountCents,
			&i.InitiatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByStatus = `-- name: GetPaymentsByStatus :many
SELECT id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at FROM payments
WHERE workspace_id = $1 AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetPaymentsByStatusParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Status      string    `json:"status"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) GetPaymentsByStatus(ctx context.Context, arg GetPaymentsByStatusParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByStatus,
		arg.WorkspaceID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InvoiceID,
			&i.SubscriptionID,
			&i.SubscriptionEvent,
			&i.CustomerID,
			&i.AmountInCents,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.TransactionHash,
			&i.NetworkID,
			&i.TokenID,
			&i.CryptoAmount,
			&i.ExchangeRate,
			&i.HasGasFee,
			&i.GasFeeUsdCents,
			&i.GasSponsored,
			&i.ExternalPaymentID,
			&i.PaymentProvider,
			&i.ProductAmountCents,
			&i.TaxAmountCents,
			&i.GasAmountCents,
			&i.DiscountAmountCents,
			&i.InitiatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsBySubscription = `-- name: GetPaymentsBySubscription :many
SELECT id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at FROM payments
WHERE subscription_id = $1 AND workspace_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetPaymentsBySubscriptionParams struct {
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	WorkspaceID    uuid.UUID   `json:"workspace_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

func (q *Queries) GetPaymentsBySubscription(ctx context.Context, arg GetPaymentsBySubscriptionParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsBySubscription,
		arg.SubscriptionID,
		arg.WorkspaceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InvoiceID,
			&i.SubscriptionID,
			&i.SubscriptionEvent,
			&i.CustomerID,
			&i.AmountInCents,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.TransactionHash,
			&i.NetworkID,
			&i.TokenID,
			&i.CryptoAmount,
			&i.ExchangeRate,
			&i.HasGasFee,
			&i.GasFeeUsdCents,
			&i.GasSponsored,
			&i.ExternalPaymentID,
			&i.PaymentProvider,
			&i.ProductAmountCents,
			&i.TaxAmountCents,
			&i.GasAmountCents,
			&i.DiscountAmountCents,
			&i.InitiatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByWorkspace = `-- name: GetPaymentsByWorkspace :many
SELECT id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at FROM payments
WHERE workspace_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetPaymentsByWorkspaceParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) GetPaymentsByWorkspace(ctx context.Context, arg GetPaymentsByWorkspaceParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InvoiceID,
			&i.SubscriptionID,
			&i.SubscriptionEvent,
			&i.CustomerID,
			&i.AmountInCents,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.TransactionHash,
			&i.NetworkID,
			&i.TokenID,
			&i.CryptoAmount,
			&i.ExchangeRate,
			&i.HasGasFee,
			&i.GasFeeUsdCents,
			&i.GasSponsored,
			&i.ExternalPaymentID,
			&i.PaymentProvider,
			&i.ProductAmountCents,
			&i.TaxAmountCents,
			&i.GasAmountCents,
			&i.DiscountAmountCents,
			&i.InitiatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreconciledPayments = `-- name: GetUnreconciledPayments :many
SELECT id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at FROM payments
WHERE workspace_id = $1
    AND status = 'completed'
    AND invoice_id IS NULL
    AND created_at >= $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetUnreconciledPaymentsParams struct {
	WorkspaceID uuid.UUID          `json:"workspace_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

func (q *Queries) GetUnreconciledPayments(ctx context.Context, arg GetUnreconciledPaymentsParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getUnreconciledPayments,
		arg.WorkspaceID,
		arg.CreatedAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.InvoiceID,
			&i.SubscriptionID,
			&i.SubscriptionEvent,
			&i.CustomerID,
			&i.AmountInCents,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.TransactionHash,
			&i.NetworkID,
			&i.TokenID,
			&i.CryptoAmount,
			&i.ExchangeRate,
			&i.HasGasFee,
			&i.GasFeeUsdCents,
			&i.GasSponsored,
			&i.ExternalPaymentID,
			&i.PaymentProvider,
			&i.ProductAmountCents,
			&i.TaxAmountCents,
			&i.GasAmountCents,
			&i.DiscountAmountCents,
			&i.InitiatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkPaymentToInvoice = `-- name: LinkPaymentToInvoice :one
UPDATE payments
SET 
    invoice_id = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2
RETURNING id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at
`

type LinkPaymentToInvoiceParams struct {
	ID          uuid.UUID   `json:"id"`
	WorkspaceID uuid.UUID   `json:"workspace_id"`
	InvoiceID   pgtype.UUID `json:"invoice_id"`
}

func (q *Queries) LinkPaymentToInvoice(ctx context.Context, arg LinkPaymentToInvoiceParams) (Payment, error) {
	row := q.db.QueryRow(ctx, linkPaymentToInvoice, arg.ID, arg.WorkspaceID, arg.InvoiceID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InvoiceID,
		&i.SubscriptionID,
		&i.SubscriptionEvent,
		&i.CustomerID,
		&i.AmountInCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionHash,
		&i.NetworkID,
		&i.TokenID,
		&i.CryptoAmount,
		&i.ExchangeRate,
		&i.HasGasFee,
		&i.GasFeeUsdCents,
		&i.GasSponsored,
		&i.ExternalPaymentID,
		&i.PaymentProvider,
		&i.ProductAmountCents,
		&i.TaxAmountCents,
		&i.GasAmountCents,
		&i.DiscountAmountCents,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const refundPayment = `-- name: RefundPayment :one
UPDATE payments
SET 
    status = 'refunded',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2 AND status = 'completed'
RETURNING id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at
`

type RefundPaymentParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) RefundPayment(ctx context.Context, arg RefundPaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, refundPayment, arg.ID, arg.WorkspaceID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InvoiceID,
		&i.SubscriptionID,
		&i.SubscriptionEvent,
		&i.CustomerID,
		&i.AmountInCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionHash,
		&i.NetworkID,
		&i.TokenID,
		&i.CryptoAmount,
		&i.ExchangeRate,
		&i.HasGasFee,
		&i.GasFeeUsdCents,
		&i.GasSponsored,
		&i.ExternalPaymentID,
		&i.PaymentProvider,
		&i.ProductAmountCents,
		&i.TaxAmountCents,
		&i.GasAmountCents,
		&i.DiscountAmountCents,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentGasDetails = `-- name: UpdatePaymentGasDetails :one
UPDATE payments
SET 
    has_gas_fee = $3,
    gas_fee_usd_cents = $4,
    gas_sponsored = $5,
    gas_amount_cents = CASE WHEN $5 = false THEN $4 ELSE 0 END,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2
RETURNING id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at
`

type UpdatePaymentGasDetailsParams struct {
	ID             uuid.UUID   `json:"id"`
	WorkspaceID    uuid.UUID   `json:"workspace_id"`
	HasGasFee      pgtype.Bool `json:"has_gas_fee"`
	GasFeeUsdCents pgtype.Int8 `json:"gas_fee_usd_cents"`
	GasSponsored   pgtype.Bool `json:"gas_sponsored"`
}

func (q *Queries) UpdatePaymentGasDetails(ctx context.Context, arg UpdatePaymentGasDetailsParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentGasDetails,
		arg.ID,
		arg.WorkspaceID,
		arg.HasGasFee,
		arg.GasFeeUsdCents,
		arg.GasSponsored,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InvoiceID,
		&i.SubscriptionID,
		&i.SubscriptionEvent,
		&i.CustomerID,
		&i.AmountInCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionHash,
		&i.NetworkID,
		&i.TokenID,
		&i.CryptoAmount,
		&i.ExchangeRate,
		&i.HasGasFee,
		&i.GasFeeUsdCents,
		&i.GasSponsored,
		&i.ExternalPaymentID,
		&i.PaymentProvider,
		&i.ProductAmountCents,
		&i.TaxAmountCents,
		&i.GasAmountCents,
		&i.DiscountAmountCents,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentGasSponsorship = `-- name: UpdatePaymentGasSponsorship :one
UPDATE payments
SET 
    gas_sponsored = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2
RETURNING id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at
`

type UpdatePaymentGasSponsorshipParams struct {
	ID           uuid.UUID   `json:"id"`
	WorkspaceID  uuid.UUID   `json:"workspace_id"`
	GasSponsored pgtype.Bool `json:"gas_sponsored"`
}

func (q *Queries) UpdatePaymentGasSponsorship(ctx context.Context, arg UpdatePaymentGasSponsorshipParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentGasSponsorship, arg.ID, arg.WorkspaceID, arg.GasSponsored)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InvoiceID,
		&i.SubscriptionID,
		&i.SubscriptionEvent,
		&i.CustomerID,
		&i.AmountInCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionHash,
		&i.NetworkID,
		&i.TokenID,
		&i.CryptoAmount,
		&i.ExchangeRate,
		&i.HasGasFee,
		&i.GasFeeUsdCents,
		&i.GasSponsored,
		&i.ExternalPaymentID,
		&i.PaymentProvider,
		&i.ProductAmountCents,
		&i.TaxAmountCents,
		&i.GasAmountCents,
		&i.DiscountAmountCents,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :one
UPDATE payments
SET 
    status = $3,
    completed_at = CASE WHEN $3 = 'completed' THEN CURRENT_TIMESTAMP ELSE completed_at END,
    failed_at = CASE WHEN $3 = 'failed' THEN CURRENT_TIMESTAMP ELSE failed_at END,
    error_message = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND workspace_id = $2
RETURNING id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at
`

type UpdatePaymentStatusParams struct {
	ID           uuid.UUID   `json:"id"`
	WorkspaceID  uuid.UUID   `json:"workspace_id"`
	Status       string      `json:"status"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentStatus,
		arg.ID,
		arg.WorkspaceID,
		arg.Status,
		arg.ErrorMessage,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InvoiceID,
		&i.SubscriptionID,
		&i.SubscriptionEvent,
		&i.CustomerID,
		&i.AmountInCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionHash,
		&i.NetworkID,
		&i.TokenID,
		&i.CryptoAmount,
		&i.ExchangeRate,
		&i.HasGasFee,
		&i.GasFeeUsdCents,
		&i.GasSponsored,
		&i.ExternalPaymentID,
		&i.PaymentProvider,
		&i.ProductAmountCents,
		&i.TaxAmountCents,
		&i.GasAmountCents,
		&i.DiscountAmountCents,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentWithBlockchainData = `-- name: UpdatePaymentWithBlockchainData :one
UPDATE payments
SET 
    status = $3,
    gas_fee_usd_cents = $4,
    updated_at = COALESCE($5, CURRENT_TIMESTAMP)
WHERE id = $1 AND workspace_id = $2
RETURNING id, workspace_id, invoice_id, subscription_id, subscription_event, customer_id, amount_in_cents, currency, status, payment_method, transaction_hash, network_id, token_id, crypto_amount, exchange_rate, has_gas_fee, gas_fee_usd_cents, gas_sponsored, external_payment_id, payment_provider, product_amount_cents, tax_amount_cents, gas_amount_cents, discount_amount_cents, initiated_at, completed_at, failed_at, error_message, metadata, created_at, updated_at
`

type UpdatePaymentWithBlockchainDataParams struct {
	ID             uuid.UUID          `json:"id"`
	WorkspaceID    uuid.UUID          `json:"workspace_id"`
	Status         string             `json:"status"`
	GasFeeUsdCents pgtype.Int8        `json:"gas_fee_usd_cents"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdatePaymentWithBlockchainData(ctx context.Context, arg UpdatePaymentWithBlockchainDataParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentWithBlockchainData,
		arg.ID,
		arg.WorkspaceID,
		arg.Status,
		arg.GasFeeUsdCents,
		arg.UpdatedAt,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InvoiceID,
		&i.SubscriptionID,
		&i.SubscriptionEvent,
		&i.CustomerID,
		&i.AmountInCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionHash,
		&i.NetworkID,
		&i.TokenID,
		&i.CryptoAmount,
		&i.ExchangeRate,
		&i.HasGasFee,
		&i.GasFeeUsdCents,
		&i.GasSponsored,
		&i.ExternalPaymentID,
		&i.PaymentProvider,
		&i.ProductAmountCents,
		&i.TaxAmountCents,
		&i.GasAmountCents,
		&i.DiscountAmountCents,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
