// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: product_addon_relationships.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countProductAddons = `-- name: CountProductAddons :one
SELECT COUNT(*) FROM product_addon_relationships
WHERE base_product_id = $1
`

func (q *Queries) CountProductAddons(ctx context.Context, baseProductID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProductAddons, baseProductID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProductAddonRelationship = `-- name: CreateProductAddonRelationship :one
INSERT INTO product_addon_relationships (
    base_product_id,
    addon_product_id,
    is_required,
    max_quantity,
    min_quantity,
    display_order,
    metadata
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, base_product_id, addon_product_id, is_required, max_quantity, min_quantity, display_order, metadata, created_at, updated_at
`

type CreateProductAddonRelationshipParams struct {
	BaseProductID  uuid.UUID   `json:"base_product_id"`
	AddonProductID uuid.UUID   `json:"addon_product_id"`
	IsRequired     pgtype.Bool `json:"is_required"`
	MaxQuantity    pgtype.Int4 `json:"max_quantity"`
	MinQuantity    pgtype.Int4 `json:"min_quantity"`
	DisplayOrder   pgtype.Int4 `json:"display_order"`
	Metadata       []byte      `json:"metadata"`
}

func (q *Queries) CreateProductAddonRelationship(ctx context.Context, arg CreateProductAddonRelationshipParams) (ProductAddonRelationship, error) {
	row := q.db.QueryRow(ctx, createProductAddonRelationship,
		arg.BaseProductID,
		arg.AddonProductID,
		arg.IsRequired,
		arg.MaxQuantity,
		arg.MinQuantity,
		arg.DisplayOrder,
		arg.Metadata,
	)
	var i ProductAddonRelationship
	err := row.Scan(
		&i.ID,
		&i.BaseProductID,
		&i.AddonProductID,
		&i.IsRequired,
		&i.MaxQuantity,
		&i.MinQuantity,
		&i.DisplayOrder,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllAddonsForProduct = `-- name: DeleteAllAddonsForProduct :exec
DELETE FROM product_addon_relationships
WHERE base_product_id = $1
`

func (q *Queries) DeleteAllAddonsForProduct(ctx context.Context, baseProductID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllAddonsForProduct, baseProductID)
	return err
}

const deleteProductAddonRelationship = `-- name: DeleteProductAddonRelationship :exec
DELETE FROM product_addon_relationships
WHERE id = $1
`

func (q *Queries) DeleteProductAddonRelationship(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductAddonRelationship, id)
	return err
}

const deleteProductAddonRelationshipByProducts = `-- name: DeleteProductAddonRelationshipByProducts :exec
DELETE FROM product_addon_relationships
WHERE base_product_id = $1 AND addon_product_id = $2
`

type DeleteProductAddonRelationshipByProductsParams struct {
	BaseProductID  uuid.UUID `json:"base_product_id"`
	AddonProductID uuid.UUID `json:"addon_product_id"`
}

func (q *Queries) DeleteProductAddonRelationshipByProducts(ctx context.Context, arg DeleteProductAddonRelationshipByProductsParams) error {
	_, err := q.db.Exec(ctx, deleteProductAddonRelationshipByProducts, arg.BaseProductID, arg.AddonProductID)
	return err
}

const getProductAddonRelationship = `-- name: GetProductAddonRelationship :one
SELECT id, base_product_id, addon_product_id, is_required, max_quantity, min_quantity, display_order, metadata, created_at, updated_at FROM product_addon_relationships
WHERE id = $1
`

func (q *Queries) GetProductAddonRelationship(ctx context.Context, id uuid.UUID) (ProductAddonRelationship, error) {
	row := q.db.QueryRow(ctx, getProductAddonRelationship, id)
	var i ProductAddonRelationship
	err := row.Scan(
		&i.ID,
		&i.BaseProductID,
		&i.AddonProductID,
		&i.IsRequired,
		&i.MaxQuantity,
		&i.MinQuantity,
		&i.DisplayOrder,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductAddonRelationshipByProducts = `-- name: GetProductAddonRelationshipByProducts :one
SELECT id, base_product_id, addon_product_id, is_required, max_quantity, min_quantity, display_order, metadata, created_at, updated_at FROM product_addon_relationships
WHERE base_product_id = $1 AND addon_product_id = $2
`

type GetProductAddonRelationshipByProductsParams struct {
	BaseProductID  uuid.UUID `json:"base_product_id"`
	AddonProductID uuid.UUID `json:"addon_product_id"`
}

func (q *Queries) GetProductAddonRelationshipByProducts(ctx context.Context, arg GetProductAddonRelationshipByProductsParams) (ProductAddonRelationship, error) {
	row := q.db.QueryRow(ctx, getProductAddonRelationshipByProducts, arg.BaseProductID, arg.AddonProductID)
	var i ProductAddonRelationship
	err := row.Scan(
		&i.ID,
		&i.BaseProductID,
		&i.AddonProductID,
		&i.IsRequired,
		&i.MaxQuantity,
		&i.MinQuantity,
		&i.DisplayOrder,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listBaseProductsForAddon = `-- name: ListBaseProductsForAddon :many
SELECT 
    par.id, par.base_product_id, par.addon_product_id, par.is_required, par.max_quantity, par.min_quantity, par.display_order, par.metadata, par.created_at, par.updated_at,
    p.id as base_id,
    p.name as base_name,
    p.description as base_description,
    p.image_url as base_image_url,
    p.price_type as base_price_type,
    p.currency as base_currency,
    p.unit_amount_in_pennies as base_unit_amount,
    p.interval_type as base_interval_type,
    p.term_length as base_term_length,
    p.active as base_active
FROM product_addon_relationships par
JOIN products p ON par.base_product_id = p.id
WHERE par.addon_product_id = $1
  AND p.deleted_at IS NULL
ORDER BY p.name
`

type ListBaseProductsForAddonRow struct {
	ID               uuid.UUID          `json:"id"`
	BaseProductID    uuid.UUID          `json:"base_product_id"`
	AddonProductID   uuid.UUID          `json:"addon_product_id"`
	IsRequired       pgtype.Bool        `json:"is_required"`
	MaxQuantity      pgtype.Int4        `json:"max_quantity"`
	MinQuantity      pgtype.Int4        `json:"min_quantity"`
	DisplayOrder     pgtype.Int4        `json:"display_order"`
	Metadata         []byte             `json:"metadata"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	BaseID           uuid.UUID          `json:"base_id"`
	BaseName         string             `json:"base_name"`
	BaseDescription  pgtype.Text        `json:"base_description"`
	BaseImageUrl     pgtype.Text        `json:"base_image_url"`
	BasePriceType    PriceType          `json:"base_price_type"`
	BaseCurrency     string             `json:"base_currency"`
	BaseUnitAmount   int32              `json:"base_unit_amount"`
	BaseIntervalType NullIntervalType   `json:"base_interval_type"`
	BaseTermLength   pgtype.Int4        `json:"base_term_length"`
	BaseActive       bool               `json:"base_active"`
}

func (q *Queries) ListBaseProductsForAddon(ctx context.Context, addonProductID uuid.UUID) ([]ListBaseProductsForAddonRow, error) {
	rows, err := q.db.Query(ctx, listBaseProductsForAddon, addonProductID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBaseProductsForAddonRow{}
	for rows.Next() {
		var i ListBaseProductsForAddonRow
		if err := rows.Scan(
			&i.ID,
			&i.BaseProductID,
			&i.AddonProductID,
			&i.IsRequired,
			&i.MaxQuantity,
			&i.MinQuantity,
			&i.DisplayOrder,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BaseID,
			&i.BaseName,
			&i.BaseDescription,
			&i.BaseImageUrl,
			&i.BasePriceType,
			&i.BaseCurrency,
			&i.BaseUnitAmount,
			&i.BaseIntervalType,
			&i.BaseTermLength,
			&i.BaseActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductAddons = `-- name: ListProductAddons :many
SELECT 
    par.id, par.base_product_id, par.addon_product_id, par.is_required, par.max_quantity, par.min_quantity, par.display_order, par.metadata, par.created_at, par.updated_at,
    p.id as addon_id,
    p.name as addon_name,
    p.description as addon_description,
    p.image_url as addon_image_url,
    p.price_type as addon_price_type,
    p.currency as addon_currency,
    p.unit_amount_in_pennies as addon_unit_amount,
    p.interval_type as addon_interval_type,
    p.term_length as addon_term_length,
    p.active as addon_active
FROM product_addon_relationships par
JOIN products p ON par.addon_product_id = p.id
WHERE par.base_product_id = $1
  AND p.deleted_at IS NULL
ORDER BY par.display_order, p.name
`

type ListProductAddonsRow struct {
	ID                uuid.UUID          `json:"id"`
	BaseProductID     uuid.UUID          `json:"base_product_id"`
	AddonProductID    uuid.UUID          `json:"addon_product_id"`
	IsRequired        pgtype.Bool        `json:"is_required"`
	MaxQuantity       pgtype.Int4        `json:"max_quantity"`
	MinQuantity       pgtype.Int4        `json:"min_quantity"`
	DisplayOrder      pgtype.Int4        `json:"display_order"`
	Metadata          []byte             `json:"metadata"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	AddonID           uuid.UUID          `json:"addon_id"`
	AddonName         string             `json:"addon_name"`
	AddonDescription  pgtype.Text        `json:"addon_description"`
	AddonImageUrl     pgtype.Text        `json:"addon_image_url"`
	AddonPriceType    PriceType          `json:"addon_price_type"`
	AddonCurrency     string             `json:"addon_currency"`
	AddonUnitAmount   int32              `json:"addon_unit_amount"`
	AddonIntervalType NullIntervalType   `json:"addon_interval_type"`
	AddonTermLength   pgtype.Int4        `json:"addon_term_length"`
	AddonActive       bool               `json:"addon_active"`
}

func (q *Queries) ListProductAddons(ctx context.Context, baseProductID uuid.UUID) ([]ListProductAddonsRow, error) {
	rows, err := q.db.Query(ctx, listProductAddons, baseProductID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProductAddonsRow{}
	for rows.Next() {
		var i ListProductAddonsRow
		if err := rows.Scan(
			&i.ID,
			&i.BaseProductID,
			&i.AddonProductID,
			&i.IsRequired,
			&i.MaxQuantity,
			&i.MinQuantity,
			&i.DisplayOrder,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AddonID,
			&i.AddonName,
			&i.AddonDescription,
			&i.AddonImageUrl,
			&i.AddonPriceType,
			&i.AddonCurrency,
			&i.AddonUnitAmount,
			&i.AddonIntervalType,
			&i.AddonTermLength,
			&i.AddonActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequiredProductAddons = `-- name: ListRequiredProductAddons :many
SELECT 
    par.id, par.base_product_id, par.addon_product_id, par.is_required, par.max_quantity, par.min_quantity, par.display_order, par.metadata, par.created_at, par.updated_at,
    p.id as addon_id,
    p.name as addon_name,
    p.description as addon_description,
    p.image_url as addon_image_url,
    p.price_type as addon_price_type,
    p.currency as addon_currency,
    p.unit_amount_in_pennies as addon_unit_amount,
    p.interval_type as addon_interval_type,
    p.term_length as addon_term_length,
    p.active as addon_active
FROM product_addon_relationships par
JOIN products p ON par.addon_product_id = p.id
WHERE par.base_product_id = $1
  AND par.is_required = true
  AND p.deleted_at IS NULL
ORDER BY par.display_order, p.name
`

type ListRequiredProductAddonsRow struct {
	ID                uuid.UUID          `json:"id"`
	BaseProductID     uuid.UUID          `json:"base_product_id"`
	AddonProductID    uuid.UUID          `json:"addon_product_id"`
	IsRequired        pgtype.Bool        `json:"is_required"`
	MaxQuantity       pgtype.Int4        `json:"max_quantity"`
	MinQuantity       pgtype.Int4        `json:"min_quantity"`
	DisplayOrder      pgtype.Int4        `json:"display_order"`
	Metadata          []byte             `json:"metadata"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	AddonID           uuid.UUID          `json:"addon_id"`
	AddonName         string             `json:"addon_name"`
	AddonDescription  pgtype.Text        `json:"addon_description"`
	AddonImageUrl     pgtype.Text        `json:"addon_image_url"`
	AddonPriceType    PriceType          `json:"addon_price_type"`
	AddonCurrency     string             `json:"addon_currency"`
	AddonUnitAmount   int32              `json:"addon_unit_amount"`
	AddonIntervalType NullIntervalType   `json:"addon_interval_type"`
	AddonTermLength   pgtype.Int4        `json:"addon_term_length"`
	AddonActive       bool               `json:"addon_active"`
}

func (q *Queries) ListRequiredProductAddons(ctx context.Context, baseProductID uuid.UUID) ([]ListRequiredProductAddonsRow, error) {
	rows, err := q.db.Query(ctx, listRequiredProductAddons, baseProductID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRequiredProductAddonsRow{}
	for rows.Next() {
		var i ListRequiredProductAddonsRow
		if err := rows.Scan(
			&i.ID,
			&i.BaseProductID,
			&i.AddonProductID,
			&i.IsRequired,
			&i.MaxQuantity,
			&i.MinQuantity,
			&i.DisplayOrder,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AddonID,
			&i.AddonName,
			&i.AddonDescription,
			&i.AddonImageUrl,
			&i.AddonPriceType,
			&i.AddonCurrency,
			&i.AddonUnitAmount,
			&i.AddonIntervalType,
			&i.AddonTermLength,
			&i.AddonActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductAddonRelationship = `-- name: UpdateProductAddonRelationship :one
UPDATE product_addon_relationships
SET
    is_required = COALESCE($2, is_required),
    max_quantity = COALESCE($3, max_quantity),
    min_quantity = COALESCE($4, min_quantity),
    display_order = COALESCE($5, display_order),
    metadata = COALESCE($6, metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, base_product_id, addon_product_id, is_required, max_quantity, min_quantity, display_order, metadata, created_at, updated_at
`

type UpdateProductAddonRelationshipParams struct {
	ID           uuid.UUID   `json:"id"`
	IsRequired   pgtype.Bool `json:"is_required"`
	MaxQuantity  pgtype.Int4 `json:"max_quantity"`
	MinQuantity  pgtype.Int4 `json:"min_quantity"`
	DisplayOrder pgtype.Int4 `json:"display_order"`
	Metadata     []byte      `json:"metadata"`
}

func (q *Queries) UpdateProductAddonRelationship(ctx context.Context, arg UpdateProductAddonRelationshipParams) (ProductAddonRelationship, error) {
	row := q.db.QueryRow(ctx, updateProductAddonRelationship,
		arg.ID,
		arg.IsRequired,
		arg.MaxQuantity,
		arg.MinQuantity,
		arg.DisplayOrder,
		arg.Metadata,
	)
	var i ProductAddonRelationship
	err := row.Scan(
		&i.ID,
		&i.BaseProductID,
		&i.AddonProductID,
		&i.IsRequired,
		&i.MaxQuantity,
		&i.MinQuantity,
		&i.DisplayOrder,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const validateAddonForProduct = `-- name: ValidateAddonForProduct :one
SELECT EXISTS(
    SELECT 1 FROM product_addon_relationships
    WHERE base_product_id = $1 AND addon_product_id = $2
) as is_valid
`

type ValidateAddonForProductParams struct {
	BaseProductID  uuid.UUID `json:"base_product_id"`
	AddonProductID uuid.UUID `json:"addon_product_id"`
}

func (q *Queries) ValidateAddonForProduct(ctx context.Context, arg ValidateAddonForProductParams) (bool, error) {
	row := q.db.QueryRow(ctx, validateAddonForProduct, arg.BaseProductID, arg.AddonProductID)
	var is_valid bool
	err := row.Scan(&is_valid)
	return is_valid, err
}
