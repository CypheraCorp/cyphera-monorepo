// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: subscription_changes.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelScheduledChange = `-- name: CancelScheduledChange :one
UPDATE subscription_schedule_changes
SET 
    status = 'cancelled',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
AND status = 'scheduled'
RETURNING id, subscription_id, change_type, scheduled_for, from_line_items, to_line_items, proration_amount_cents, proration_calculation, status, processed_at, error_message, reason, initiated_by, metadata, created_at, updated_at
`

func (q *Queries) CancelScheduledChange(ctx context.Context, id uuid.UUID) (SubscriptionScheduleChange, error) {
	row := q.db.QueryRow(ctx, cancelScheduledChange, id)
	var i SubscriptionScheduleChange
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ChangeType,
		&i.ScheduledFor,
		&i.FromLineItems,
		&i.ToLineItems,
		&i.ProrationAmountCents,
		&i.ProrationCalculation,
		&i.Status,
		&i.ProcessedAt,
		&i.ErrorMessage,
		&i.Reason,
		&i.InitiatedBy,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const cancelSubscriptionImmediately = `-- name: CancelSubscriptionImmediately :one
UPDATE subscriptions
SET 
    status = 'canceled',
    cancelled_at = CURRENT_TIMESTAMP,
    cancellation_reason = COALESCE($2, cancellation_reason),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, num_id, customer_id, product_id, workspace_id, product_token_id, external_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at, cancel_at, cancelled_at, cancellation_reason, paused_at, pause_ends_at, trial_start, trial_end
`

type CancelSubscriptionImmediatelyParams struct {
	ID                 uuid.UUID   `json:"id"`
	CancellationReason pgtype.Text `json:"cancellation_reason"`
}

func (q *Queries) CancelSubscriptionImmediately(ctx context.Context, arg CancelSubscriptionImmediatelyParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, cancelSubscriptionImmediately, arg.ID, arg.CancellationReason)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.NumID,
		&i.CustomerID,
		&i.ProductID,
		&i.WorkspaceID,
		&i.ProductTokenID,
		&i.ExternalID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.PaymentSyncVersion,
		&i.PaymentProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CancelAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.PausedAt,
		&i.PauseEndsAt,
		&i.TrialStart,
		&i.TrialEnd,
	)
	return i, err
}

const createScheduleChange = `-- name: CreateScheduleChange :one
INSERT INTO subscription_schedule_changes (
    subscription_id,
    change_type,
    scheduled_for,
    from_line_items,
    to_line_items,
    proration_amount_cents,
    proration_calculation,
    status,
    reason,
    initiated_by,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, subscription_id, change_type, scheduled_for, from_line_items, to_line_items, proration_amount_cents, proration_calculation, status, processed_at, error_message, reason, initiated_by, metadata, created_at, updated_at
`

type CreateScheduleChangeParams struct {
	SubscriptionID       uuid.UUID          `json:"subscription_id"`
	ChangeType           string             `json:"change_type"`
	ScheduledFor         pgtype.Timestamptz `json:"scheduled_for"`
	FromLineItems        []byte             `json:"from_line_items"`
	ToLineItems          []byte             `json:"to_line_items"`
	ProrationAmountCents pgtype.Int8        `json:"proration_amount_cents"`
	ProrationCalculation []byte             `json:"proration_calculation"`
	Status               string             `json:"status"`
	Reason               pgtype.Text        `json:"reason"`
	InitiatedBy          pgtype.Text        `json:"initiated_by"`
	Metadata             []byte             `json:"metadata"`
}

func (q *Queries) CreateScheduleChange(ctx context.Context, arg CreateScheduleChangeParams) (SubscriptionScheduleChange, error) {
	row := q.db.QueryRow(ctx, createScheduleChange,
		arg.SubscriptionID,
		arg.ChangeType,
		arg.ScheduledFor,
		arg.FromLineItems,
		arg.ToLineItems,
		arg.ProrationAmountCents,
		arg.ProrationCalculation,
		arg.Status,
		arg.Reason,
		arg.InitiatedBy,
		arg.Metadata,
	)
	var i SubscriptionScheduleChange
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ChangeType,
		&i.ScheduledFor,
		&i.FromLineItems,
		&i.ToLineItems,
		&i.ProrationAmountCents,
		&i.ProrationCalculation,
		&i.Status,
		&i.ProcessedAt,
		&i.ErrorMessage,
		&i.Reason,
		&i.InitiatedBy,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDueScheduledChanges = `-- name: GetDueScheduledChanges :many
SELECT id, subscription_id, change_type, scheduled_for, from_line_items, to_line_items, proration_amount_cents, proration_calculation, status, processed_at, error_message, reason, initiated_by, metadata, created_at, updated_at FROM subscription_schedule_changes
WHERE status = 'scheduled' 
AND scheduled_for <= $1
ORDER BY scheduled_for ASC
`

func (q *Queries) GetDueScheduledChanges(ctx context.Context, scheduledFor pgtype.Timestamptz) ([]SubscriptionScheduleChange, error) {
	rows, err := q.db.Query(ctx, getDueScheduledChanges, scheduledFor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubscriptionScheduleChange{}
	for rows.Next() {
		var i SubscriptionScheduleChange
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.ChangeType,
			&i.ScheduledFor,
			&i.FromLineItems,
			&i.ToLineItems,
			&i.ProrationAmountCents,
			&i.ProrationCalculation,
			&i.Status,
			&i.ProcessedAt,
			&i.ErrorMessage,
			&i.Reason,
			&i.InitiatedBy,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduleChange = `-- name: GetScheduleChange :one
SELECT id, subscription_id, change_type, scheduled_for, from_line_items, to_line_items, proration_amount_cents, proration_calculation, status, processed_at, error_message, reason, initiated_by, metadata, created_at, updated_at FROM subscription_schedule_changes
WHERE id = $1
`

func (q *Queries) GetScheduleChange(ctx context.Context, id uuid.UUID) (SubscriptionScheduleChange, error) {
	row := q.db.QueryRow(ctx, getScheduleChange, id)
	var i SubscriptionScheduleChange
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ChangeType,
		&i.ScheduledFor,
		&i.FromLineItems,
		&i.ToLineItems,
		&i.ProrationAmountCents,
		&i.ProrationCalculation,
		&i.Status,
		&i.ProcessedAt,
		&i.ErrorMessage,
		&i.Reason,
		&i.InitiatedBy,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubscriptionScheduledChanges = `-- name: GetSubscriptionScheduledChanges :many
SELECT id, subscription_id, change_type, scheduled_for, from_line_items, to_line_items, proration_amount_cents, proration_calculation, status, processed_at, error_message, reason, initiated_by, metadata, created_at, updated_at FROM subscription_schedule_changes
WHERE subscription_id = $1
AND status IN ('scheduled', 'processing')
ORDER BY scheduled_for ASC
`

func (q *Queries) GetSubscriptionScheduledChanges(ctx context.Context, subscriptionID uuid.UUID) ([]SubscriptionScheduleChange, error) {
	rows, err := q.db.Query(ctx, getSubscriptionScheduledChanges, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubscriptionScheduleChange{}
	for rows.Next() {
		var i SubscriptionScheduleChange
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.ChangeType,
			&i.ScheduledFor,
			&i.FromLineItems,
			&i.ToLineItems,
			&i.ProrationAmountCents,
			&i.ProrationCalculation,
			&i.Status,
			&i.ProcessedAt,
			&i.ErrorMessage,
			&i.Reason,
			&i.InitiatedBy,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionWithCustomerDetails = `-- name: GetSubscriptionWithCustomerDetails :one
SELECT 
    s.id, s.num_id, s.customer_id, s.product_id, s.workspace_id, s.product_token_id, s.external_id, s.token_amount, s.delegation_id, s.customer_wallet_id, s.status, s.current_period_start, s.current_period_end, s.next_redemption_date, s.total_redemptions, s.total_amount_in_cents, s.metadata, s.payment_sync_status, s.payment_synced_at, s.payment_sync_version, s.payment_provider, s.created_at, s.updated_at, s.deleted_at, s.cancel_at, s.cancelled_at, s.cancellation_reason, s.paused_at, s.pause_ends_at, s.trial_start, s.trial_end,
    c.name as customer_name,
    c.email as customer_email,
    p.name as product_name,
    p.unit_amount_in_pennies as price_amount
FROM subscriptions s
JOIN customers c ON s.customer_id = c.id
JOIN products p ON s.product_id = p.id
WHERE s.id = $1
`

type GetSubscriptionWithCustomerDetailsRow struct {
	ID                 uuid.UUID          `json:"id"`
	NumID              int64              `json:"num_id"`
	CustomerID         uuid.UUID          `json:"customer_id"`
	ProductID          uuid.UUID          `json:"product_id"`
	WorkspaceID        uuid.UUID          `json:"workspace_id"`
	ProductTokenID     uuid.UUID          `json:"product_token_id"`
	ExternalID         pgtype.Text        `json:"external_id"`
	TokenAmount        int32              `json:"token_amount"`
	DelegationID       uuid.UUID          `json:"delegation_id"`
	CustomerWalletID   pgtype.UUID        `json:"customer_wallet_id"`
	Status             SubscriptionStatus `json:"status"`
	CurrentPeriodStart pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamptz `json:"current_period_end"`
	NextRedemptionDate pgtype.Timestamptz `json:"next_redemption_date"`
	TotalRedemptions   int32              `json:"total_redemptions"`
	TotalAmountInCents int32              `json:"total_amount_in_cents"`
	Metadata           []byte             `json:"metadata"`
	PaymentSyncStatus  pgtype.Text        `json:"payment_sync_status"`
	PaymentSyncedAt    pgtype.Timestamptz `json:"payment_synced_at"`
	PaymentSyncVersion pgtype.Int4        `json:"payment_sync_version"`
	PaymentProvider    pgtype.Text        `json:"payment_provider"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	DeletedAt          pgtype.Timestamptz `json:"deleted_at"`
	CancelAt           pgtype.Timestamptz `json:"cancel_at"`
	CancelledAt        pgtype.Timestamptz `json:"cancelled_at"`
	CancellationReason pgtype.Text        `json:"cancellation_reason"`
	PausedAt           pgtype.Timestamptz `json:"paused_at"`
	PauseEndsAt        pgtype.Timestamptz `json:"pause_ends_at"`
	TrialStart         pgtype.Timestamptz `json:"trial_start"`
	TrialEnd           pgtype.Timestamptz `json:"trial_end"`
	CustomerName       pgtype.Text        `json:"customer_name"`
	CustomerEmail      pgtype.Text        `json:"customer_email"`
	ProductName        string             `json:"product_name"`
	PriceAmount        int32              `json:"price_amount"`
}

func (q *Queries) GetSubscriptionWithCustomerDetails(ctx context.Context, id uuid.UUID) (GetSubscriptionWithCustomerDetailsRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionWithCustomerDetails, id)
	var i GetSubscriptionWithCustomerDetailsRow
	err := row.Scan(
		&i.ID,
		&i.NumID,
		&i.CustomerID,
		&i.ProductID,
		&i.WorkspaceID,
		&i.ProductTokenID,
		&i.ExternalID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.PaymentSyncVersion,
		&i.PaymentProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CancelAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.PausedAt,
		&i.PauseEndsAt,
		&i.TrialStart,
		&i.TrialEnd,
		&i.CustomerName,
		&i.CustomerEmail,
		&i.ProductName,
		&i.PriceAmount,
	)
	return i, err
}

const getSubscriptionsDueForCancellation = `-- name: GetSubscriptionsDueForCancellation :many
SELECT id, num_id, customer_id, product_id, workspace_id, product_token_id, external_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at, cancel_at, cancelled_at, cancellation_reason, paused_at, pause_ends_at, trial_start, trial_end FROM subscriptions
WHERE status = 'active'
AND cancel_at IS NOT NULL
AND cancel_at <= $1
ORDER BY cancel_at ASC
`

func (q *Queries) GetSubscriptionsDueForCancellation(ctx context.Context, cancelAt pgtype.Timestamptz) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsDueForCancellation, cancelAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.NumID,
			&i.CustomerID,
			&i.ProductID,
			&i.WorkspaceID,
			&i.ProductTokenID,
			&i.ExternalID,
			&i.TokenAmount,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CancelAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.PausedAt,
			&i.PauseEndsAt,
			&i.TrialStart,
			&i.TrialEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionsDueForResumption = `-- name: GetSubscriptionsDueForResumption :many
SELECT id, num_id, customer_id, product_id, workspace_id, product_token_id, external_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at, cancel_at, cancelled_at, cancellation_reason, paused_at, pause_ends_at, trial_start, trial_end FROM subscriptions
WHERE status = 'suspended'
AND pause_ends_at IS NOT NULL
AND pause_ends_at <= $1
ORDER BY pause_ends_at ASC
`

func (q *Queries) GetSubscriptionsDueForResumption(ctx context.Context, pauseEndsAt pgtype.Timestamptz) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsDueForResumption, pauseEndsAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.NumID,
			&i.CustomerID,
			&i.ProductID,
			&i.WorkspaceID,
			&i.ProductTokenID,
			&i.ExternalID,
			&i.TokenAmount,
			&i.DelegationID,
			&i.CustomerWalletID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextRedemptionDate,
			&i.TotalRedemptions,
			&i.TotalAmountInCents,
			&i.Metadata,
			&i.PaymentSyncStatus,
			&i.PaymentSyncedAt,
			&i.PaymentSyncVersion,
			&i.PaymentProvider,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CancelAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.PausedAt,
			&i.PauseEndsAt,
			&i.TrialStart,
			&i.TrialEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pauseSubscription = `-- name: PauseSubscription :one
UPDATE subscriptions
SET 
    status = 'suspended',
    paused_at = CURRENT_TIMESTAMP,
    pause_ends_at = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, num_id, customer_id, product_id, workspace_id, product_token_id, external_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at, cancel_at, cancelled_at, cancellation_reason, paused_at, pause_ends_at, trial_start, trial_end
`

type PauseSubscriptionParams struct {
	ID          uuid.UUID          `json:"id"`
	PauseEndsAt pgtype.Timestamptz `json:"pause_ends_at"`
}

func (q *Queries) PauseSubscription(ctx context.Context, arg PauseSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, pauseSubscription, arg.ID, arg.PauseEndsAt)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.NumID,
		&i.CustomerID,
		&i.ProductID,
		&i.WorkspaceID,
		&i.ProductTokenID,
		&i.ExternalID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.PaymentSyncVersion,
		&i.PaymentProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CancelAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.PausedAt,
		&i.PauseEndsAt,
		&i.TrialStart,
		&i.TrialEnd,
	)
	return i, err
}

const reactivateScheduledCancellation = `-- name: ReactivateScheduledCancellation :one
UPDATE subscriptions
SET 
    cancel_at = NULL,
    cancellation_reason = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
AND cancel_at IS NOT NULL
AND status = 'active'
RETURNING id, num_id, customer_id, product_id, workspace_id, product_token_id, external_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at, cancel_at, cancelled_at, cancellation_reason, paused_at, pause_ends_at, trial_start, trial_end
`

func (q *Queries) ReactivateScheduledCancellation(ctx context.Context, id uuid.UUID) (Subscription, error) {
	row := q.db.QueryRow(ctx, reactivateScheduledCancellation, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.NumID,
		&i.CustomerID,
		&i.ProductID,
		&i.WorkspaceID,
		&i.ProductTokenID,
		&i.ExternalID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.PaymentSyncVersion,
		&i.PaymentProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CancelAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.PausedAt,
		&i.PauseEndsAt,
		&i.TrialStart,
		&i.TrialEnd,
	)
	return i, err
}

const resumeSubscription = `-- name: ResumeSubscription :one
UPDATE subscriptions
SET 
    status = 'active',
    paused_at = NULL,
    pause_ends_at = NULL,
    current_period_start = $2,
    current_period_end = $3,
    next_redemption_date = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, num_id, customer_id, product_id, workspace_id, product_token_id, external_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at, cancel_at, cancelled_at, cancellation_reason, paused_at, pause_ends_at, trial_start, trial_end
`

type ResumeSubscriptionParams struct {
	ID                 uuid.UUID          `json:"id"`
	CurrentPeriodStart pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamptz `json:"current_period_end"`
}

func (q *Queries) ResumeSubscription(ctx context.Context, arg ResumeSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, resumeSubscription, arg.ID, arg.CurrentPeriodStart, arg.CurrentPeriodEnd)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.NumID,
		&i.CustomerID,
		&i.ProductID,
		&i.WorkspaceID,
		&i.ProductTokenID,
		&i.ExternalID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.PaymentSyncVersion,
		&i.PaymentProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CancelAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.PausedAt,
		&i.PauseEndsAt,
		&i.TrialStart,
		&i.TrialEnd,
	)
	return i, err
}

const scheduleSubscriptionCancellation = `-- name: ScheduleSubscriptionCancellation :one
UPDATE subscriptions
SET 
    cancel_at = $2,
    cancellation_reason = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, num_id, customer_id, product_id, workspace_id, product_token_id, external_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at, cancel_at, cancelled_at, cancellation_reason, paused_at, pause_ends_at, trial_start, trial_end
`

type ScheduleSubscriptionCancellationParams struct {
	ID                 uuid.UUID          `json:"id"`
	CancelAt           pgtype.Timestamptz `json:"cancel_at"`
	CancellationReason pgtype.Text        `json:"cancellation_reason"`
}

func (q *Queries) ScheduleSubscriptionCancellation(ctx context.Context, arg ScheduleSubscriptionCancellationParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, scheduleSubscriptionCancellation, arg.ID, arg.CancelAt, arg.CancellationReason)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.NumID,
		&i.CustomerID,
		&i.ProductID,
		&i.WorkspaceID,
		&i.ProductTokenID,
		&i.ExternalID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.PaymentSyncVersion,
		&i.PaymentProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CancelAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.PausedAt,
		&i.PauseEndsAt,
		&i.TrialStart,
		&i.TrialEnd,
	)
	return i, err
}

const updateScheduleChangeStatus = `-- name: UpdateScheduleChangeStatus :one
UPDATE subscription_schedule_changes
SET 
    status = $2,
    processed_at = CASE WHEN $2 IN ('completed', 'failed') THEN CURRENT_TIMESTAMP ELSE processed_at END,
    error_message = COALESCE($3, error_message),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, subscription_id, change_type, scheduled_for, from_line_items, to_line_items, proration_amount_cents, proration_calculation, status, processed_at, error_message, reason, initiated_by, metadata, created_at, updated_at
`

type UpdateScheduleChangeStatusParams struct {
	ID           uuid.UUID   `json:"id"`
	Status       string      `json:"status"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) UpdateScheduleChangeStatus(ctx context.Context, arg UpdateScheduleChangeStatusParams) (SubscriptionScheduleChange, error) {
	row := q.db.QueryRow(ctx, updateScheduleChangeStatus, arg.ID, arg.Status, arg.ErrorMessage)
	var i SubscriptionScheduleChange
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ChangeType,
		&i.ScheduledFor,
		&i.FromLineItems,
		&i.ToLineItems,
		&i.ProrationAmountCents,
		&i.ProrationCalculation,
		&i.Status,
		&i.ProcessedAt,
		&i.ErrorMessage,
		&i.Reason,
		&i.InitiatedBy,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubscriptionForUpgrade = `-- name: UpdateSubscriptionForUpgrade :one
UPDATE subscriptions
SET 
    product_id = COALESCE($2, product_id),
    total_amount_in_cents = COALESCE($3, total_amount_in_cents),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, num_id, customer_id, product_id, workspace_id, product_token_id, external_id, token_amount, delegation_id, customer_wallet_id, status, current_period_start, current_period_end, next_redemption_date, total_redemptions, total_amount_in_cents, metadata, payment_sync_status, payment_synced_at, payment_sync_version, payment_provider, created_at, updated_at, deleted_at, cancel_at, cancelled_at, cancellation_reason, paused_at, pause_ends_at, trial_start, trial_end
`

type UpdateSubscriptionForUpgradeParams struct {
	ID                 uuid.UUID `json:"id"`
	ProductID          uuid.UUID `json:"product_id"`
	TotalAmountInCents int32     `json:"total_amount_in_cents"`
}

func (q *Queries) UpdateSubscriptionForUpgrade(ctx context.Context, arg UpdateSubscriptionForUpgradeParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionForUpgrade, arg.ID, arg.ProductID, arg.TotalAmountInCents)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.NumID,
		&i.CustomerID,
		&i.ProductID,
		&i.WorkspaceID,
		&i.ProductTokenID,
		&i.ExternalID,
		&i.TokenAmount,
		&i.DelegationID,
		&i.CustomerWalletID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextRedemptionDate,
		&i.TotalRedemptions,
		&i.TotalAmountInCents,
		&i.Metadata,
		&i.PaymentSyncStatus,
		&i.PaymentSyncedAt,
		&i.PaymentSyncVersion,
		&i.PaymentProvider,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CancelAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.PausedAt,
		&i.PauseEndsAt,
		&i.TrialStart,
		&i.TrialEnd,
	)
	return i, err
}
