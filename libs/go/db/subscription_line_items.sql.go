// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: subscription_line_items.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const activateSubscriptionLineItem = `-- name: ActivateSubscriptionLineItem :one
UPDATE subscription_line_items
SET
    is_active = true,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, subscription_id, product_id, line_item_type, quantity, unit_amount_in_pennies, currency, price_type, interval_type, total_amount_in_pennies, is_active, metadata, created_at, updated_at
`

func (q *Queries) ActivateSubscriptionLineItem(ctx context.Context, id uuid.UUID) (SubscriptionLineItem, error) {
	row := q.db.QueryRow(ctx, activateSubscriptionLineItem, id)
	var i SubscriptionLineItem
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ProductID,
		&i.LineItemType,
		&i.Quantity,
		&i.UnitAmountInPennies,
		&i.Currency,
		&i.PriceType,
		&i.IntervalType,
		&i.TotalAmountInPennies,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

type BatchCreateSubscriptionLineItemsParams struct {
	SubscriptionID       uuid.UUID        `json:"subscription_id"`
	ProductID            uuid.UUID        `json:"product_id"`
	LineItemType         string           `json:"line_item_type"`
	Quantity             int32            `json:"quantity"`
	UnitAmountInPennies  int32            `json:"unit_amount_in_pennies"`
	Currency             string           `json:"currency"`
	PriceType            PriceType        `json:"price_type"`
	IntervalType         NullIntervalType `json:"interval_type"`
	TotalAmountInPennies int32            `json:"total_amount_in_pennies"`
	IsActive             pgtype.Bool      `json:"is_active"`
	Metadata             []byte           `json:"metadata"`
}

const calculateSubscriptionTotal = `-- name: CalculateSubscriptionTotal :one
SELECT 
    COALESCE(SUM(total_amount_in_pennies), 0) as total_amount
FROM subscription_line_items
WHERE subscription_id = $1
  AND is_active = true
`

func (q *Queries) CalculateSubscriptionTotal(ctx context.Context, subscriptionID uuid.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, calculateSubscriptionTotal, subscriptionID)
	var total_amount interface{}
	err := row.Scan(&total_amount)
	return total_amount, err
}

const countSubscriptionLineItems = `-- name: CountSubscriptionLineItems :one
SELECT COUNT(*) FROM subscription_line_items
WHERE subscription_id = $1
  AND is_active = true
`

func (q *Queries) CountSubscriptionLineItems(ctx context.Context, subscriptionID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSubscriptionLineItems, subscriptionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSubscriptionLineItem = `-- name: CreateSubscriptionLineItem :one
INSERT INTO subscription_line_items (
    subscription_id,
    product_id,
    line_item_type,
    quantity,
    unit_amount_in_pennies,
    currency,
    price_type,
    interval_type,
    total_amount_in_pennies,
    is_active,
    metadata
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, subscription_id, product_id, line_item_type, quantity, unit_amount_in_pennies, currency, price_type, interval_type, total_amount_in_pennies, is_active, metadata, created_at, updated_at
`

type CreateSubscriptionLineItemParams struct {
	SubscriptionID       uuid.UUID        `json:"subscription_id"`
	ProductID            uuid.UUID        `json:"product_id"`
	LineItemType         string           `json:"line_item_type"`
	Quantity             int32            `json:"quantity"`
	UnitAmountInPennies  int32            `json:"unit_amount_in_pennies"`
	Currency             string           `json:"currency"`
	PriceType            PriceType        `json:"price_type"`
	IntervalType         NullIntervalType `json:"interval_type"`
	TotalAmountInPennies int32            `json:"total_amount_in_pennies"`
	IsActive             pgtype.Bool      `json:"is_active"`
	Metadata             []byte           `json:"metadata"`
}

func (q *Queries) CreateSubscriptionLineItem(ctx context.Context, arg CreateSubscriptionLineItemParams) (SubscriptionLineItem, error) {
	row := q.db.QueryRow(ctx, createSubscriptionLineItem,
		arg.SubscriptionID,
		arg.ProductID,
		arg.LineItemType,
		arg.Quantity,
		arg.UnitAmountInPennies,
		arg.Currency,
		arg.PriceType,
		arg.IntervalType,
		arg.TotalAmountInPennies,
		arg.IsActive,
		arg.Metadata,
	)
	var i SubscriptionLineItem
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ProductID,
		&i.LineItemType,
		&i.Quantity,
		&i.UnitAmountInPennies,
		&i.Currency,
		&i.PriceType,
		&i.IntervalType,
		&i.TotalAmountInPennies,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateSubscriptionLineItem = `-- name: DeactivateSubscriptionLineItem :one
UPDATE subscription_line_items
SET
    is_active = false,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, subscription_id, product_id, line_item_type, quantity, unit_amount_in_pennies, currency, price_type, interval_type, total_amount_in_pennies, is_active, metadata, created_at, updated_at
`

func (q *Queries) DeactivateSubscriptionLineItem(ctx context.Context, id uuid.UUID) (SubscriptionLineItem, error) {
	row := q.db.QueryRow(ctx, deactivateSubscriptionLineItem, id)
	var i SubscriptionLineItem
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ProductID,
		&i.LineItemType,
		&i.Quantity,
		&i.UnitAmountInPennies,
		&i.Currency,
		&i.PriceType,
		&i.IntervalType,
		&i.TotalAmountInPennies,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllSubscriptionLineItems = `-- name: DeleteAllSubscriptionLineItems :exec
DELETE FROM subscription_line_items
WHERE subscription_id = $1
`

func (q *Queries) DeleteAllSubscriptionLineItems(ctx context.Context, subscriptionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllSubscriptionLineItems, subscriptionID)
	return err
}

const deleteSubscriptionLineItem = `-- name: DeleteSubscriptionLineItem :exec
DELETE FROM subscription_line_items
WHERE id = $1
`

func (q *Queries) DeleteSubscriptionLineItem(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSubscriptionLineItem, id)
	return err
}

const getSubscriptionBaseLineItem = `-- name: GetSubscriptionBaseLineItem :one
SELECT 
    sli.id, sli.subscription_id, sli.product_id, sli.line_item_type, sli.quantity, sli.unit_amount_in_pennies, sli.currency, sli.price_type, sli.interval_type, sli.total_amount_in_pennies, sli.is_active, sli.metadata, sli.created_at, sli.updated_at,
    p.name as product_name,
    p.description as product_description,
    p.image_url as product_image_url
FROM subscription_line_items sli
JOIN products p ON sli.product_id = p.id
WHERE sli.subscription_id = $1
  AND sli.line_item_type = 'base'
  AND sli.is_active = true
LIMIT 1
`

type GetSubscriptionBaseLineItemRow struct {
	ID                   uuid.UUID          `json:"id"`
	SubscriptionID       uuid.UUID          `json:"subscription_id"`
	ProductID            uuid.UUID          `json:"product_id"`
	LineItemType         string             `json:"line_item_type"`
	Quantity             int32              `json:"quantity"`
	UnitAmountInPennies  int32              `json:"unit_amount_in_pennies"`
	Currency             string             `json:"currency"`
	PriceType            PriceType          `json:"price_type"`
	IntervalType         NullIntervalType   `json:"interval_type"`
	TotalAmountInPennies int32              `json:"total_amount_in_pennies"`
	IsActive             pgtype.Bool        `json:"is_active"`
	Metadata             []byte             `json:"metadata"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	ProductName          string             `json:"product_name"`
	ProductDescription   pgtype.Text        `json:"product_description"`
	ProductImageUrl      pgtype.Text        `json:"product_image_url"`
}

func (q *Queries) GetSubscriptionBaseLineItem(ctx context.Context, subscriptionID uuid.UUID) (GetSubscriptionBaseLineItemRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionBaseLineItem, subscriptionID)
	var i GetSubscriptionBaseLineItemRow
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ProductID,
		&i.LineItemType,
		&i.Quantity,
		&i.UnitAmountInPennies,
		&i.Currency,
		&i.PriceType,
		&i.IntervalType,
		&i.TotalAmountInPennies,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductName,
		&i.ProductDescription,
		&i.ProductImageUrl,
	)
	return i, err
}

const getSubscriptionLineItem = `-- name: GetSubscriptionLineItem :one
SELECT id, subscription_id, product_id, line_item_type, quantity, unit_amount_in_pennies, currency, price_type, interval_type, total_amount_in_pennies, is_active, metadata, created_at, updated_at FROM subscription_line_items
WHERE id = $1
`

func (q *Queries) GetSubscriptionLineItem(ctx context.Context, id uuid.UUID) (SubscriptionLineItem, error) {
	row := q.db.QueryRow(ctx, getSubscriptionLineItem, id)
	var i SubscriptionLineItem
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ProductID,
		&i.LineItemType,
		&i.Quantity,
		&i.UnitAmountInPennies,
		&i.Currency,
		&i.PriceType,
		&i.IntervalType,
		&i.TotalAmountInPennies,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubscriptionLineItemByProduct = `-- name: GetSubscriptionLineItemByProduct :one
SELECT id, subscription_id, product_id, line_item_type, quantity, unit_amount_in_pennies, currency, price_type, interval_type, total_amount_in_pennies, is_active, metadata, created_at, updated_at FROM subscription_line_items
WHERE subscription_id = $1
  AND product_id = $2
  AND is_active = true
LIMIT 1
`

type GetSubscriptionLineItemByProductParams struct {
	SubscriptionID uuid.UUID `json:"subscription_id"`
	ProductID      uuid.UUID `json:"product_id"`
}

func (q *Queries) GetSubscriptionLineItemByProduct(ctx context.Context, arg GetSubscriptionLineItemByProductParams) (SubscriptionLineItem, error) {
	row := q.db.QueryRow(ctx, getSubscriptionLineItemByProduct, arg.SubscriptionID, arg.ProductID)
	var i SubscriptionLineItem
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ProductID,
		&i.LineItemType,
		&i.Quantity,
		&i.UnitAmountInPennies,
		&i.Currency,
		&i.PriceType,
		&i.IntervalType,
		&i.TotalAmountInPennies,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveSubscriptionLineItems = `-- name: ListActiveSubscriptionLineItems :many
SELECT 
    sli.id, sli.subscription_id, sli.product_id, sli.line_item_type, sli.quantity, sli.unit_amount_in_pennies, sli.currency, sli.price_type, sli.interval_type, sli.total_amount_in_pennies, sli.is_active, sli.metadata, sli.created_at, sli.updated_at,
    p.name as product_name,
    p.description as product_description,
    p.image_url as product_image_url,
    p.product_type as product_type
FROM subscription_line_items sli
JOIN products p ON sli.product_id = p.id
WHERE sli.subscription_id = $1
  AND sli.is_active = true
ORDER BY 
    CASE WHEN sli.line_item_type = 'base' THEN 0 ELSE 1 END,
    p.name
`

type ListActiveSubscriptionLineItemsRow struct {
	ID                   uuid.UUID          `json:"id"`
	SubscriptionID       uuid.UUID          `json:"subscription_id"`
	ProductID            uuid.UUID          `json:"product_id"`
	LineItemType         string             `json:"line_item_type"`
	Quantity             int32              `json:"quantity"`
	UnitAmountInPennies  int32              `json:"unit_amount_in_pennies"`
	Currency             string             `json:"currency"`
	PriceType            PriceType          `json:"price_type"`
	IntervalType         NullIntervalType   `json:"interval_type"`
	TotalAmountInPennies int32              `json:"total_amount_in_pennies"`
	IsActive             pgtype.Bool        `json:"is_active"`
	Metadata             []byte             `json:"metadata"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	ProductName          string             `json:"product_name"`
	ProductDescription   pgtype.Text        `json:"product_description"`
	ProductImageUrl      pgtype.Text        `json:"product_image_url"`
	ProductType          pgtype.Text        `json:"product_type"`
}

func (q *Queries) ListActiveSubscriptionLineItems(ctx context.Context, subscriptionID uuid.UUID) ([]ListActiveSubscriptionLineItemsRow, error) {
	rows, err := q.db.Query(ctx, listActiveSubscriptionLineItems, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveSubscriptionLineItemsRow{}
	for rows.Next() {
		var i ListActiveSubscriptionLineItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.ProductID,
			&i.LineItemType,
			&i.Quantity,
			&i.UnitAmountInPennies,
			&i.Currency,
			&i.PriceType,
			&i.IntervalType,
			&i.TotalAmountInPennies,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductDescription,
			&i.ProductImageUrl,
			&i.ProductType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionAddonLineItems = `-- name: ListSubscriptionAddonLineItems :many
SELECT 
    sli.id, sli.subscription_id, sli.product_id, sli.line_item_type, sli.quantity, sli.unit_amount_in_pennies, sli.currency, sli.price_type, sli.interval_type, sli.total_amount_in_pennies, sli.is_active, sli.metadata, sli.created_at, sli.updated_at,
    p.name as product_name,
    p.description as product_description,
    p.image_url as product_image_url
FROM subscription_line_items sli
JOIN products p ON sli.product_id = p.id
WHERE sli.subscription_id = $1
  AND sli.line_item_type = 'addon'
  AND sli.is_active = true
ORDER BY p.name
`

type ListSubscriptionAddonLineItemsRow struct {
	ID                   uuid.UUID          `json:"id"`
	SubscriptionID       uuid.UUID          `json:"subscription_id"`
	ProductID            uuid.UUID          `json:"product_id"`
	LineItemType         string             `json:"line_item_type"`
	Quantity             int32              `json:"quantity"`
	UnitAmountInPennies  int32              `json:"unit_amount_in_pennies"`
	Currency             string             `json:"currency"`
	PriceType            PriceType          `json:"price_type"`
	IntervalType         NullIntervalType   `json:"interval_type"`
	TotalAmountInPennies int32              `json:"total_amount_in_pennies"`
	IsActive             pgtype.Bool        `json:"is_active"`
	Metadata             []byte             `json:"metadata"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	ProductName          string             `json:"product_name"`
	ProductDescription   pgtype.Text        `json:"product_description"`
	ProductImageUrl      pgtype.Text        `json:"product_image_url"`
}

func (q *Queries) ListSubscriptionAddonLineItems(ctx context.Context, subscriptionID uuid.UUID) ([]ListSubscriptionAddonLineItemsRow, error) {
	rows, err := q.db.Query(ctx, listSubscriptionAddonLineItems, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionAddonLineItemsRow{}
	for rows.Next() {
		var i ListSubscriptionAddonLineItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.ProductID,
			&i.LineItemType,
			&i.Quantity,
			&i.UnitAmountInPennies,
			&i.Currency,
			&i.PriceType,
			&i.IntervalType,
			&i.TotalAmountInPennies,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductDescription,
			&i.ProductImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionLineItems = `-- name: ListSubscriptionLineItems :many
SELECT 
    sli.id, sli.subscription_id, sli.product_id, sli.line_item_type, sli.quantity, sli.unit_amount_in_pennies, sli.currency, sli.price_type, sli.interval_type, sli.total_amount_in_pennies, sli.is_active, sli.metadata, sli.created_at, sli.updated_at,
    p.name as product_name,
    p.description as product_description,
    p.image_url as product_image_url,
    p.product_type as product_type
FROM subscription_line_items sli
JOIN products p ON sli.product_id = p.id
WHERE sli.subscription_id = $1
ORDER BY 
    CASE WHEN sli.line_item_type = 'base' THEN 0 ELSE 1 END,
    p.name
`

type ListSubscriptionLineItemsRow struct {
	ID                   uuid.UUID          `json:"id"`
	SubscriptionID       uuid.UUID          `json:"subscription_id"`
	ProductID            uuid.UUID          `json:"product_id"`
	LineItemType         string             `json:"line_item_type"`
	Quantity             int32              `json:"quantity"`
	UnitAmountInPennies  int32              `json:"unit_amount_in_pennies"`
	Currency             string             `json:"currency"`
	PriceType            PriceType          `json:"price_type"`
	IntervalType         NullIntervalType   `json:"interval_type"`
	TotalAmountInPennies int32              `json:"total_amount_in_pennies"`
	IsActive             pgtype.Bool        `json:"is_active"`
	Metadata             []byte             `json:"metadata"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	ProductName          string             `json:"product_name"`
	ProductDescription   pgtype.Text        `json:"product_description"`
	ProductImageUrl      pgtype.Text        `json:"product_image_url"`
	ProductType          pgtype.Text        `json:"product_type"`
}

func (q *Queries) ListSubscriptionLineItems(ctx context.Context, subscriptionID uuid.UUID) ([]ListSubscriptionLineItemsRow, error) {
	rows, err := q.db.Query(ctx, listSubscriptionLineItems, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionLineItemsRow{}
	for rows.Next() {
		var i ListSubscriptionLineItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.ProductID,
			&i.LineItemType,
			&i.Quantity,
			&i.UnitAmountInPennies,
			&i.Currency,
			&i.PriceType,
			&i.IntervalType,
			&i.TotalAmountInPennies,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductDescription,
			&i.ProductImageUrl,
			&i.ProductType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscriptionLineItemQuantity = `-- name: UpdateSubscriptionLineItemQuantity :one
UPDATE subscription_line_items
SET
    quantity = $2,
    total_amount_in_pennies = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, subscription_id, product_id, line_item_type, quantity, unit_amount_in_pennies, currency, price_type, interval_type, total_amount_in_pennies, is_active, metadata, created_at, updated_at
`

type UpdateSubscriptionLineItemQuantityParams struct {
	ID                   uuid.UUID `json:"id"`
	Quantity             int32     `json:"quantity"`
	TotalAmountInPennies int32     `json:"total_amount_in_pennies"`
}

func (q *Queries) UpdateSubscriptionLineItemQuantity(ctx context.Context, arg UpdateSubscriptionLineItemQuantityParams) (SubscriptionLineItem, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionLineItemQuantity, arg.ID, arg.Quantity, arg.TotalAmountInPennies)
	var i SubscriptionLineItem
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ProductID,
		&i.LineItemType,
		&i.Quantity,
		&i.UnitAmountInPennies,
		&i.Currency,
		&i.PriceType,
		&i.IntervalType,
		&i.TotalAmountInPennies,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
