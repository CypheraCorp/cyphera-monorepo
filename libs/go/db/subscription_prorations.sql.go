// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: subscription_prorations.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const applyProrationToInvoice = `-- name: ApplyProrationToInvoice :one
UPDATE subscription_prorations
SET applied_to_invoice_id = $2
WHERE id = $1
AND applied_to_invoice_id IS NULL
AND applied_to_payment_id IS NULL
RETURNING id, subscription_id, schedule_change_id, proration_type, period_start, period_end, days_total, days_used, days_remaining, original_amount_cents, used_amount_cents, credit_amount_cents, applied_to_invoice_id, applied_to_payment_id, created_at
`

type ApplyProrationToInvoiceParams struct {
	ID                 uuid.UUID   `json:"id"`
	AppliedToInvoiceID pgtype.UUID `json:"applied_to_invoice_id"`
}

func (q *Queries) ApplyProrationToInvoice(ctx context.Context, arg ApplyProrationToInvoiceParams) (SubscriptionProration, error) {
	row := q.db.QueryRow(ctx, applyProrationToInvoice, arg.ID, arg.AppliedToInvoiceID)
	var i SubscriptionProration
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ScheduleChangeID,
		&i.ProrationType,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.DaysTotal,
		&i.DaysUsed,
		&i.DaysRemaining,
		&i.OriginalAmountCents,
		&i.UsedAmountCents,
		&i.CreditAmountCents,
		&i.AppliedToInvoiceID,
		&i.AppliedToPaymentID,
		&i.CreatedAt,
	)
	return i, err
}

const applyProrationToPayment = `-- name: ApplyProrationToPayment :one
UPDATE subscription_prorations
SET applied_to_payment_id = $2
WHERE id = $1
AND applied_to_invoice_id IS NULL
AND applied_to_payment_id IS NULL
RETURNING id, subscription_id, schedule_change_id, proration_type, period_start, period_end, days_total, days_used, days_remaining, original_amount_cents, used_amount_cents, credit_amount_cents, applied_to_invoice_id, applied_to_payment_id, created_at
`

type ApplyProrationToPaymentParams struct {
	ID                 uuid.UUID   `json:"id"`
	AppliedToPaymentID pgtype.UUID `json:"applied_to_payment_id"`
}

func (q *Queries) ApplyProrationToPayment(ctx context.Context, arg ApplyProrationToPaymentParams) (SubscriptionProration, error) {
	row := q.db.QueryRow(ctx, applyProrationToPayment, arg.ID, arg.AppliedToPaymentID)
	var i SubscriptionProration
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ScheduleChangeID,
		&i.ProrationType,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.DaysTotal,
		&i.DaysUsed,
		&i.DaysRemaining,
		&i.OriginalAmountCents,
		&i.UsedAmountCents,
		&i.CreditAmountCents,
		&i.AppliedToInvoiceID,
		&i.AppliedToPaymentID,
		&i.CreatedAt,
	)
	return i, err
}

const createProrationRecord = `-- name: CreateProrationRecord :one
INSERT INTO subscription_prorations (
    subscription_id,
    schedule_change_id,
    proration_type,
    period_start,
    period_end,
    days_total,
    days_used,
    days_remaining,
    original_amount_cents,
    used_amount_cents,
    credit_amount_cents,
    applied_to_invoice_id,
    applied_to_payment_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, subscription_id, schedule_change_id, proration_type, period_start, period_end, days_total, days_used, days_remaining, original_amount_cents, used_amount_cents, credit_amount_cents, applied_to_invoice_id, applied_to_payment_id, created_at
`

type CreateProrationRecordParams struct {
	SubscriptionID      uuid.UUID          `json:"subscription_id"`
	ScheduleChangeID    pgtype.UUID        `json:"schedule_change_id"`
	ProrationType       string             `json:"proration_type"`
	PeriodStart         pgtype.Timestamptz `json:"period_start"`
	PeriodEnd           pgtype.Timestamptz `json:"period_end"`
	DaysTotal           int32              `json:"days_total"`
	DaysUsed            int32              `json:"days_used"`
	DaysRemaining       int32              `json:"days_remaining"`
	OriginalAmountCents int64              `json:"original_amount_cents"`
	UsedAmountCents     int64              `json:"used_amount_cents"`
	CreditAmountCents   int64              `json:"credit_amount_cents"`
	AppliedToInvoiceID  pgtype.UUID        `json:"applied_to_invoice_id"`
	AppliedToPaymentID  pgtype.UUID        `json:"applied_to_payment_id"`
}

func (q *Queries) CreateProrationRecord(ctx context.Context, arg CreateProrationRecordParams) (SubscriptionProration, error) {
	row := q.db.QueryRow(ctx, createProrationRecord,
		arg.SubscriptionID,
		arg.ScheduleChangeID,
		arg.ProrationType,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.DaysTotal,
		arg.DaysUsed,
		arg.DaysRemaining,
		arg.OriginalAmountCents,
		arg.UsedAmountCents,
		arg.CreditAmountCents,
		arg.AppliedToInvoiceID,
		arg.AppliedToPaymentID,
	)
	var i SubscriptionProration
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ScheduleChangeID,
		&i.ProrationType,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.DaysTotal,
		&i.DaysUsed,
		&i.DaysRemaining,
		&i.OriginalAmountCents,
		&i.UsedAmountCents,
		&i.CreditAmountCents,
		&i.AppliedToInvoiceID,
		&i.AppliedToPaymentID,
		&i.CreatedAt,
	)
	return i, err
}

const getProrationSummaryBySubscription = `-- name: GetProrationSummaryBySubscription :one
SELECT 
    subscription_id,
    COUNT(*) as total_prorations,
    SUM(credit_amount_cents) as total_credits,
    SUM(CASE WHEN applied_to_invoice_id IS NOT NULL OR applied_to_payment_id IS NOT NULL THEN credit_amount_cents ELSE 0 END) as applied_credits,
    SUM(CASE WHEN applied_to_invoice_id IS NULL AND applied_to_payment_id IS NULL THEN credit_amount_cents ELSE 0 END) as unapplied_credits
FROM subscription_prorations
WHERE subscription_id = $1
GROUP BY subscription_id
`

type GetProrationSummaryBySubscriptionRow struct {
	SubscriptionID   uuid.UUID `json:"subscription_id"`
	TotalProrations  int64     `json:"total_prorations"`
	TotalCredits     int64     `json:"total_credits"`
	AppliedCredits   int64     `json:"applied_credits"`
	UnappliedCredits int64     `json:"unapplied_credits"`
}

func (q *Queries) GetProrationSummaryBySubscription(ctx context.Context, subscriptionID uuid.UUID) (GetProrationSummaryBySubscriptionRow, error) {
	row := q.db.QueryRow(ctx, getProrationSummaryBySubscription, subscriptionID)
	var i GetProrationSummaryBySubscriptionRow
	err := row.Scan(
		&i.SubscriptionID,
		&i.TotalProrations,
		&i.TotalCredits,
		&i.AppliedCredits,
		&i.UnappliedCredits,
	)
	return i, err
}

const getProrationsByScheduleChange = `-- name: GetProrationsByScheduleChange :many
SELECT id, subscription_id, schedule_change_id, proration_type, period_start, period_end, days_total, days_used, days_remaining, original_amount_cents, used_amount_cents, credit_amount_cents, applied_to_invoice_id, applied_to_payment_id, created_at FROM subscription_prorations
WHERE schedule_change_id = $1
`

func (q *Queries) GetProrationsByScheduleChange(ctx context.Context, scheduleChangeID pgtype.UUID) ([]SubscriptionProration, error) {
	rows, err := q.db.Query(ctx, getProrationsByScheduleChange, scheduleChangeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubscriptionProration{}
	for rows.Next() {
		var i SubscriptionProration
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.ScheduleChangeID,
			&i.ProrationType,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.DaysTotal,
			&i.DaysUsed,
			&i.DaysRemaining,
			&i.OriginalAmountCents,
			&i.UsedAmountCents,
			&i.CreditAmountCents,
			&i.AppliedToInvoiceID,
			&i.AppliedToPaymentID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionProrations = `-- name: GetSubscriptionProrations :many
SELECT id, subscription_id, schedule_change_id, proration_type, period_start, period_end, days_total, days_used, days_remaining, original_amount_cents, used_amount_cents, credit_amount_cents, applied_to_invoice_id, applied_to_payment_id, created_at FROM subscription_prorations
WHERE subscription_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetSubscriptionProrations(ctx context.Context, subscriptionID uuid.UUID) ([]SubscriptionProration, error) {
	rows, err := q.db.Query(ctx, getSubscriptionProrations, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubscriptionProration{}
	for rows.Next() {
		var i SubscriptionProration
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.ScheduleChangeID,
			&i.ProrationType,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.DaysTotal,
			&i.DaysUsed,
			&i.DaysRemaining,
			&i.OriginalAmountCents,
			&i.UsedAmountCents,
			&i.CreditAmountCents,
			&i.AppliedToInvoiceID,
			&i.AppliedToPaymentID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnappliedProrations = `-- name: GetUnappliedProrations :many
SELECT id, subscription_id, schedule_change_id, proration_type, period_start, period_end, days_total, days_used, days_remaining, original_amount_cents, used_amount_cents, credit_amount_cents, applied_to_invoice_id, applied_to_payment_id, created_at FROM subscription_prorations
WHERE subscription_id = $1
AND applied_to_invoice_id IS NULL
AND applied_to_payment_id IS NULL
ORDER BY created_at ASC
`

func (q *Queries) GetUnappliedProrations(ctx context.Context, subscriptionID uuid.UUID) ([]SubscriptionProration, error) {
	rows, err := q.db.Query(ctx, getUnappliedProrations, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubscriptionProration{}
	for rows.Next() {
		var i SubscriptionProration
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.ScheduleChangeID,
			&i.ProrationType,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.DaysTotal,
			&i.DaysUsed,
			&i.DaysRemaining,
			&i.OriginalAmountCents,
			&i.UsedAmountCents,
			&i.CreditAmountCents,
			&i.AppliedToInvoiceID,
			&i.AppliedToPaymentID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
