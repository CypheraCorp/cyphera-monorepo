// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: subscription_state_history.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getLatestStateChange = `-- name: GetLatestStateChange :one
SELECT id, subscription_id, from_status, to_status, from_amount_cents, to_amount_cents, line_items_snapshot, change_reason, schedule_change_id, initiated_by, occurred_at FROM subscription_state_history
WHERE subscription_id = $1
ORDER BY occurred_at DESC
LIMIT 1
`

func (q *Queries) GetLatestStateChange(ctx context.Context, subscriptionID uuid.UUID) (SubscriptionStateHistory, error) {
	row := q.db.QueryRow(ctx, getLatestStateChange, subscriptionID)
	var i SubscriptionStateHistory
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.FromStatus,
		&i.ToStatus,
		&i.FromAmountCents,
		&i.ToAmountCents,
		&i.LineItemsSnapshot,
		&i.ChangeReason,
		&i.ScheduleChangeID,
		&i.InitiatedBy,
		&i.OccurredAt,
	)
	return i, err
}

const getStateChangesByDateRange = `-- name: GetStateChangesByDateRange :many
SELECT id, subscription_id, from_status, to_status, from_amount_cents, to_amount_cents, line_items_snapshot, change_reason, schedule_change_id, initiated_by, occurred_at FROM subscription_state_history
WHERE subscription_id = $1
AND occurred_at >= $2
AND occurred_at <= $3
ORDER BY occurred_at DESC
`

type GetStateChangesByDateRangeParams struct {
	SubscriptionID uuid.UUID          `json:"subscription_id"`
	OccurredAt     pgtype.Timestamptz `json:"occurred_at"`
	OccurredAt_2   pgtype.Timestamptz `json:"occurred_at_2"`
}

func (q *Queries) GetStateChangesByDateRange(ctx context.Context, arg GetStateChangesByDateRangeParams) ([]SubscriptionStateHistory, error) {
	rows, err := q.db.Query(ctx, getStateChangesByDateRange, arg.SubscriptionID, arg.OccurredAt, arg.OccurredAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubscriptionStateHistory{}
	for rows.Next() {
		var i SubscriptionStateHistory
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.FromStatus,
			&i.ToStatus,
			&i.FromAmountCents,
			&i.ToAmountCents,
			&i.LineItemsSnapshot,
			&i.ChangeReason,
			&i.ScheduleChangeID,
			&i.InitiatedBy,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStateChangesByScheduleChange = `-- name: GetStateChangesByScheduleChange :many
SELECT id, subscription_id, from_status, to_status, from_amount_cents, to_amount_cents, line_items_snapshot, change_reason, schedule_change_id, initiated_by, occurred_at FROM subscription_state_history
WHERE schedule_change_id = $1
ORDER BY occurred_at DESC
`

func (q *Queries) GetStateChangesByScheduleChange(ctx context.Context, scheduleChangeID pgtype.UUID) ([]SubscriptionStateHistory, error) {
	rows, err := q.db.Query(ctx, getStateChangesByScheduleChange, scheduleChangeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubscriptionStateHistory{}
	for rows.Next() {
		var i SubscriptionStateHistory
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.FromStatus,
			&i.ToStatus,
			&i.FromAmountCents,
			&i.ToAmountCents,
			&i.LineItemsSnapshot,
			&i.ChangeReason,
			&i.ScheduleChangeID,
			&i.InitiatedBy,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionLifecycleEvents = `-- name: GetSubscriptionLifecycleEvents :many
SELECT 
    ssh.id, ssh.subscription_id, ssh.from_status, ssh.to_status, ssh.from_amount_cents, ssh.to_amount_cents, ssh.line_items_snapshot, ssh.change_reason, ssh.schedule_change_id, ssh.initiated_by, ssh.occurred_at,
    ssc.change_type as schedule_change_type,
    ssc.proration_amount_cents
FROM subscription_state_history ssh
LEFT JOIN subscription_schedule_changes ssc ON ssh.schedule_change_id = ssc.id
WHERE ssh.subscription_id = $1
ORDER BY ssh.occurred_at DESC
`

type GetSubscriptionLifecycleEventsRow struct {
	ID                   uuid.UUID                  `json:"id"`
	SubscriptionID       uuid.UUID                  `json:"subscription_id"`
	FromStatus           NullSubscriptionStatus     `json:"from_status"`
	ToStatus             SubscriptionStatus         `json:"to_status"`
	FromAmountCents      pgtype.Int8                `json:"from_amount_cents"`
	ToAmountCents        pgtype.Int8                `json:"to_amount_cents"`
	LineItemsSnapshot    []byte                     `json:"line_items_snapshot"`
	ChangeReason         pgtype.Text                `json:"change_reason"`
	ScheduleChangeID     pgtype.UUID                `json:"schedule_change_id"`
	InitiatedBy          pgtype.Text                `json:"initiated_by"`
	OccurredAt           pgtype.Timestamptz         `json:"occurred_at"`
	ScheduleChangeType   NullSubscriptionChangeType `json:"schedule_change_type"`
	ProrationAmountCents pgtype.Int8                `json:"proration_amount_cents"`
}

func (q *Queries) GetSubscriptionLifecycleEvents(ctx context.Context, subscriptionID uuid.UUID) ([]GetSubscriptionLifecycleEventsRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionLifecycleEvents, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSubscriptionLifecycleEventsRow{}
	for rows.Next() {
		var i GetSubscriptionLifecycleEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.FromStatus,
			&i.ToStatus,
			&i.FromAmountCents,
			&i.ToAmountCents,
			&i.LineItemsSnapshot,
			&i.ChangeReason,
			&i.ScheduleChangeID,
			&i.InitiatedBy,
			&i.OccurredAt,
			&i.ScheduleChangeType,
			&i.ProrationAmountCents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionStateHistory = `-- name: GetSubscriptionStateHistory :many
SELECT id, subscription_id, from_status, to_status, from_amount_cents, to_amount_cents, line_items_snapshot, change_reason, schedule_change_id, initiated_by, occurred_at FROM subscription_state_history
WHERE subscription_id = $1
ORDER BY occurred_at DESC
LIMIT $2
`

type GetSubscriptionStateHistoryParams struct {
	SubscriptionID uuid.UUID `json:"subscription_id"`
	Limit          int32     `json:"limit"`
}

func (q *Queries) GetSubscriptionStateHistory(ctx context.Context, arg GetSubscriptionStateHistoryParams) ([]SubscriptionStateHistory, error) {
	rows, err := q.db.Query(ctx, getSubscriptionStateHistory, arg.SubscriptionID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubscriptionStateHistory{}
	for rows.Next() {
		var i SubscriptionStateHistory
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.FromStatus,
			&i.ToStatus,
			&i.FromAmountCents,
			&i.ToAmountCents,
			&i.LineItemsSnapshot,
			&i.ChangeReason,
			&i.ScheduleChangeID,
			&i.InitiatedBy,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordStateChange = `-- name: RecordStateChange :one
INSERT INTO subscription_state_history (
    subscription_id,
    from_status,
    to_status,
    from_amount_cents,
    to_amount_cents,
    line_items_snapshot,
    change_reason,
    schedule_change_id,
    initiated_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, subscription_id, from_status, to_status, from_amount_cents, to_amount_cents, line_items_snapshot, change_reason, schedule_change_id, initiated_by, occurred_at
`

type RecordStateChangeParams struct {
	SubscriptionID    uuid.UUID              `json:"subscription_id"`
	FromStatus        NullSubscriptionStatus `json:"from_status"`
	ToStatus          SubscriptionStatus     `json:"to_status"`
	FromAmountCents   pgtype.Int8            `json:"from_amount_cents"`
	ToAmountCents     pgtype.Int8            `json:"to_amount_cents"`
	LineItemsSnapshot []byte                 `json:"line_items_snapshot"`
	ChangeReason      pgtype.Text            `json:"change_reason"`
	ScheduleChangeID  pgtype.UUID            `json:"schedule_change_id"`
	InitiatedBy       pgtype.Text            `json:"initiated_by"`
}

func (q *Queries) RecordStateChange(ctx context.Context, arg RecordStateChangeParams) (SubscriptionStateHistory, error) {
	row := q.db.QueryRow(ctx, recordStateChange,
		arg.SubscriptionID,
		arg.FromStatus,
		arg.ToStatus,
		arg.FromAmountCents,
		arg.ToAmountCents,
		arg.LineItemsSnapshot,
		arg.ChangeReason,
		arg.ScheduleChangeID,
		arg.InitiatedBy,
	)
	var i SubscriptionStateHistory
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.FromStatus,
		&i.ToStatus,
		&i.FromAmountCents,
		&i.ToAmountCents,
		&i.LineItemsSnapshot,
		&i.ChangeReason,
		&i.ScheduleChangeID,
		&i.InitiatedBy,
		&i.OccurredAt,
	)
	return i, err
}
