// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: webhook_management.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getDLQProcessingStats = `-- name: GetDLQProcessingStats :one
SELECT 
    COUNT(*) as total_dlq_messages,
    COUNT(CASE WHEN event_type = 'dlq_processing_success' THEN 1 END) as successfully_processed,
    COUNT(CASE WHEN event_type = 'dlq_processing_failed' THEN 1 END) as processing_failed,
    COUNT(CASE WHEN processing_attempts >= 5 THEN 1 END) as max_retries_exceeded,
    MAX(occurred_at) as last_processed_at
FROM payment_sync_events
WHERE event_type LIKE 'dlq_%'
  AND workspace_id = $1
  AND provider_name = $2
  AND occurred_at >= $3
`

type GetDLQProcessingStatsParams struct {
	WorkspaceID  uuid.UUID          `json:"workspace_id"`
	ProviderName string             `json:"provider_name"`
	OccurredAt   pgtype.Timestamptz `json:"occurred_at"`
}

type GetDLQProcessingStatsRow struct {
	TotalDlqMessages      int64       `json:"total_dlq_messages"`
	SuccessfullyProcessed int64       `json:"successfully_processed"`
	ProcessingFailed      int64       `json:"processing_failed"`
	MaxRetriesExceeded    int64       `json:"max_retries_exceeded"`
	LastProcessedAt       interface{} `json:"last_processed_at"`
}

// Get statistics about DLQ processing for monitoring
func (q *Queries) GetDLQProcessingStats(ctx context.Context, arg GetDLQProcessingStatsParams) (GetDLQProcessingStatsRow, error) {
	row := q.db.QueryRow(ctx, getDLQProcessingStats, arg.WorkspaceID, arg.ProviderName, arg.OccurredAt)
	var i GetDLQProcessingStatsRow
	err := row.Scan(
		&i.TotalDlqMessages,
		&i.SuccessfullyProcessed,
		&i.ProcessingFailed,
		&i.MaxRetriesExceeded,
		&i.LastProcessedAt,
	)
	return i, err
}

const getDuplicateWebhookEvents = `-- name: GetDuplicateWebhookEvents :many
SELECT 
    webhook_event_id,
    COUNT(*) as duplicate_count,
    array_agg(id ORDER BY occurred_at) as event_ids,
    MIN(occurred_at) as first_received,
    MAX(occurred_at) as last_received
FROM payment_sync_events
WHERE workspace_id = $1
  AND provider_name = $2
  AND webhook_event_id IS NOT NULL
  AND occurred_at >= NOW() - INTERVAL '7 days'
GROUP BY webhook_event_id
HAVING COUNT(*) > 1
ORDER BY duplicate_count DESC
LIMIT $3
`

type GetDuplicateWebhookEventsParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
	Limit        int32     `json:"limit"`
}

type GetDuplicateWebhookEventsRow struct {
	WebhookEventID pgtype.Text `json:"webhook_event_id"`
	DuplicateCount int64       `json:"duplicate_count"`
	EventIds       interface{} `json:"event_ids"`
	FirstReceived  interface{} `json:"first_received"`
	LastReceived   interface{} `json:"last_received"`
}

// Find duplicate webhook events for debugging
func (q *Queries) GetDuplicateWebhookEvents(ctx context.Context, arg GetDuplicateWebhookEventsParams) ([]GetDuplicateWebhookEventsRow, error) {
	rows, err := q.db.Query(ctx, getDuplicateWebhookEvents, arg.WorkspaceID, arg.ProviderName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDuplicateWebhookEventsRow{}
	for rows.Next() {
		var i GetDuplicateWebhookEventsRow
		if err := rows.Scan(
			&i.WebhookEventID,
			&i.DuplicateCount,
			&i.EventIds,
			&i.FirstReceived,
			&i.LastReceived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailedSyncSessionsForRecovery = `-- name: GetFailedSyncSessionsForRecovery :many
SELECT 
    id,
    workspace_id,
    provider_name,
    session_type,
    status,
    entity_types,
    config,
    progress,
    error_summary,
    started_at,
    created_at
FROM payment_sync_sessions
WHERE workspace_id = $1
  AND (status = 'failed' OR status = 'running')
  AND created_at >= NOW() - INTERVAL '7 days'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetFailedSyncSessionsForRecoveryParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type GetFailedSyncSessionsForRecoveryRow struct {
	ID           uuid.UUID          `json:"id"`
	WorkspaceID  uuid.UUID          `json:"workspace_id"`
	ProviderName string             `json:"provider_name"`
	SessionType  string             `json:"session_type"`
	Status       string             `json:"status"`
	EntityTypes  []string           `json:"entity_types"`
	Config       []byte             `json:"config"`
	Progress     []byte             `json:"progress"`
	ErrorSummary []byte             `json:"error_summary"`
	StartedAt    pgtype.Timestamptz `json:"started_at"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

// Get failed or incomplete sync sessions that can be resumed
func (q *Queries) GetFailedSyncSessionsForRecovery(ctx context.Context, arg GetFailedSyncSessionsForRecoveryParams) ([]GetFailedSyncSessionsForRecoveryRow, error) {
	rows, err := q.db.Query(ctx, getFailedSyncSessionsForRecovery, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFailedSyncSessionsForRecoveryRow{}
	for rows.Next() {
		var i GetFailedSyncSessionsForRecoveryRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ProviderName,
			&i.SessionType,
			&i.Status,
			&i.EntityTypes,
			&i.Config,
			&i.Progress,
			&i.ErrorSummary,
			&i.StartedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailedWebhooksForRetry = `-- name: GetFailedWebhooksForRetry :many
SELECT 
    id,
    webhook_event_id,
    provider_account_id,
    event_details,
    processing_attempts,
    occurred_at
FROM payment_sync_events
WHERE workspace_id = $1
  AND provider_name = $2
  AND event_type = 'webhook_processing_failed'
  AND processing_attempts < $3
  AND occurred_at >= NOW() - INTERVAL '24 hours'
ORDER BY occurred_at ASC
LIMIT $4
`

type GetFailedWebhooksForRetryParams struct {
	WorkspaceID        uuid.UUID   `json:"workspace_id"`
	ProviderName       string      `json:"provider_name"`
	ProcessingAttempts pgtype.Int4 `json:"processing_attempts"`
	Limit              int32       `json:"limit"`
}

type GetFailedWebhooksForRetryRow struct {
	ID                 uuid.UUID          `json:"id"`
	WebhookEventID     pgtype.Text        `json:"webhook_event_id"`
	ProviderAccountID  pgtype.Text        `json:"provider_account_id"`
	EventDetails       []byte             `json:"event_details"`
	ProcessingAttempts pgtype.Int4        `json:"processing_attempts"`
	OccurredAt         pgtype.Timestamptz `json:"occurred_at"`
}

// Get failed webhook events that are eligible for retry
func (q *Queries) GetFailedWebhooksForRetry(ctx context.Context, arg GetFailedWebhooksForRetryParams) ([]GetFailedWebhooksForRetryRow, error) {
	rows, err := q.db.Query(ctx, getFailedWebhooksForRetry,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.ProcessingAttempts,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFailedWebhooksForRetryRow{}
	for rows.Next() {
		var i GetFailedWebhooksForRetryRow
		if err := rows.Scan(
			&i.ID,
			&i.WebhookEventID,
			&i.ProviderAccountID,
			&i.EventDetails,
			&i.ProcessingAttempts,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentWebhookErrors = `-- name: GetRecentWebhookErrors :many
SELECT 
    webhook_event_id,
    provider_name,
    provider_account_id,
    event_message,
    event_details,
    processing_attempts,
    occurred_at
FROM payment_sync_events
WHERE workspace_id = $1
  AND provider_name = $2
  AND event_type = 'webhook_processing_failed'
  AND occurred_at >= NOW() - INTERVAL '24 hours'
ORDER BY occurred_at DESC
LIMIT $3
`

type GetRecentWebhookErrorsParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
	Limit        int32     `json:"limit"`
}

type GetRecentWebhookErrorsRow struct {
	WebhookEventID     pgtype.Text        `json:"webhook_event_id"`
	ProviderName       string             `json:"provider_name"`
	ProviderAccountID  pgtype.Text        `json:"provider_account_id"`
	EventMessage       pgtype.Text        `json:"event_message"`
	EventDetails       []byte             `json:"event_details"`
	ProcessingAttempts pgtype.Int4        `json:"processing_attempts"`
	OccurredAt         pgtype.Timestamptz `json:"occurred_at"`
}

// Get recent webhook processing errors for monitoring
func (q *Queries) GetRecentWebhookErrors(ctx context.Context, arg GetRecentWebhookErrorsParams) ([]GetRecentWebhookErrorsRow, error) {
	rows, err := q.db.Query(ctx, getRecentWebhookErrors, arg.WorkspaceID, arg.ProviderName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentWebhookErrorsRow{}
	for rows.Next() {
		var i GetRecentWebhookErrorsRow
		if err := rows.Scan(
			&i.WebhookEventID,
			&i.ProviderName,
			&i.ProviderAccountID,
			&i.EventMessage,
			&i.EventDetails,
			&i.ProcessingAttempts,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSyncProgressByEntityType = `-- name: GetSyncProgressByEntityType :many
SELECT 
    entity_type,
    COUNT(*) as total_events,
    COUNT(CASE WHEN event_type LIKE '%success%' OR event_type LIKE '%completed%' THEN 1 END) as successful_events,
    COUNT(CASE WHEN event_type LIKE '%failed%' OR event_type LIKE '%error%' THEN 1 END) as failed_events,
    MAX(occurred_at) as last_processed_at
FROM payment_sync_events
WHERE session_id = $1
  AND entity_type != 'webhook'
GROUP BY entity_type
ORDER BY entity_type
`

type GetSyncProgressByEntityTypeRow struct {
	EntityType       string      `json:"entity_type"`
	TotalEvents      int64       `json:"total_events"`
	SuccessfulEvents int64       `json:"successful_events"`
	FailedEvents     int64       `json:"failed_events"`
	LastProcessedAt  interface{} `json:"last_processed_at"`
}

// Get detailed progress for a sync session by entity type
func (q *Queries) GetSyncProgressByEntityType(ctx context.Context, sessionID uuid.UUID) ([]GetSyncProgressByEntityTypeRow, error) {
	rows, err := q.db.Query(ctx, getSyncProgressByEntityType, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSyncProgressByEntityTypeRow{}
	for rows.Next() {
		var i GetSyncProgressByEntityTypeRow
		if err := rows.Scan(
			&i.EntityType,
			&i.TotalEvents,
			&i.SuccessfulEvents,
			&i.FailedEvents,
			&i.LastProcessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhookEventForReplay = `-- name: GetWebhookEventForReplay :one
SELECT 
    id,
    workspace_id,
    provider_name,
    webhook_event_id,
    provider_account_id,
    event_details,
    processing_attempts,
    signature_valid,
    occurred_at
FROM payment_sync_events
WHERE workspace_id = $1
  AND provider_name = $2
  AND webhook_event_id = $3
  AND webhook_event_id IS NOT NULL
ORDER BY occurred_at DESC
LIMIT 1
`

type GetWebhookEventForReplayParams struct {
	WorkspaceID    uuid.UUID   `json:"workspace_id"`
	ProviderName   string      `json:"provider_name"`
	WebhookEventID pgtype.Text `json:"webhook_event_id"`
}

type GetWebhookEventForReplayRow struct {
	ID                 uuid.UUID          `json:"id"`
	WorkspaceID        uuid.UUID          `json:"workspace_id"`
	ProviderName       string             `json:"provider_name"`
	WebhookEventID     pgtype.Text        `json:"webhook_event_id"`
	ProviderAccountID  pgtype.Text        `json:"provider_account_id"`
	EventDetails       []byte             `json:"event_details"`
	ProcessingAttempts pgtype.Int4        `json:"processing_attempts"`
	SignatureValid     pgtype.Bool        `json:"signature_valid"`
	OccurredAt         pgtype.Timestamptz `json:"occurred_at"`
}

// Get full webhook event details for replay functionality
func (q *Queries) GetWebhookEventForReplay(ctx context.Context, arg GetWebhookEventForReplayParams) (GetWebhookEventForReplayRow, error) {
	row := q.db.QueryRow(ctx, getWebhookEventForReplay, arg.WorkspaceID, arg.ProviderName, arg.WebhookEventID)
	var i GetWebhookEventForReplayRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.WebhookEventID,
		&i.ProviderAccountID,
		&i.EventDetails,
		&i.ProcessingAttempts,
		&i.SignatureValid,
		&i.OccurredAt,
	)
	return i, err
}

const getWebhookEventsByTimeRange = `-- name: GetWebhookEventsByTimeRange :many
SELECT 
    webhook_event_id,
    entity_type,
    event_type,
    signature_valid,
    processing_attempts,
    occurred_at,
    event_details->'event_data'->'type' as webhook_type
FROM payment_sync_events
WHERE workspace_id = $1
  AND provider_name = $2
  AND webhook_event_id IS NOT NULL
  AND occurred_at BETWEEN $3 AND $4
ORDER BY occurred_at DESC
LIMIT $5 OFFSET $6
`

type GetWebhookEventsByTimeRangeParams struct {
	WorkspaceID  uuid.UUID          `json:"workspace_id"`
	ProviderName string             `json:"provider_name"`
	OccurredAt   pgtype.Timestamptz `json:"occurred_at"`
	OccurredAt_2 pgtype.Timestamptz `json:"occurred_at_2"`
	Limit        int32              `json:"limit"`
	Offset       int32              `json:"offset"`
}

type GetWebhookEventsByTimeRangeRow struct {
	WebhookEventID     pgtype.Text        `json:"webhook_event_id"`
	EntityType         string             `json:"entity_type"`
	EventType          string             `json:"event_type"`
	SignatureValid     pgtype.Bool        `json:"signature_valid"`
	ProcessingAttempts pgtype.Int4        `json:"processing_attempts"`
	OccurredAt         pgtype.Timestamptz `json:"occurred_at"`
	WebhookType        interface{}        `json:"webhook_type"`
}

// Get webhook events within a specific time range for analysis
func (q *Queries) GetWebhookEventsByTimeRange(ctx context.Context, arg GetWebhookEventsByTimeRangeParams) ([]GetWebhookEventsByTimeRangeRow, error) {
	rows, err := q.db.Query(ctx, getWebhookEventsByTimeRange,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.OccurredAt,
		arg.OccurredAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWebhookEventsByTimeRangeRow{}
	for rows.Next() {
		var i GetWebhookEventsByTimeRangeRow
		if err := rows.Scan(
			&i.WebhookEventID,
			&i.EntityType,
			&i.EventType,
			&i.SignatureValid,
			&i.ProcessingAttempts,
			&i.OccurredAt,
			&i.WebhookType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhookHealthStatus = `-- name: GetWebhookHealthStatus :one
SELECT 
    wpc.provider_name,
    wpc.last_webhook_at,
    wpc.is_active as config_active,
    COUNT(pse.id) as recent_events,
    COUNT(CASE WHEN pse.event_type = 'webhook_processing_failed' THEN 1 END) as recent_failures,
    MAX(pse.occurred_at) as last_event_time
FROM workspace_payment_configurations wpc
LEFT JOIN payment_sync_events pse ON wpc.workspace_id = pse.workspace_id 
    AND wpc.provider_name = pse.provider_name
    AND pse.webhook_event_id IS NOT NULL
    AND pse.occurred_at >= NOW() - INTERVAL '1 hour'
WHERE wpc.workspace_id = $1
  AND wpc.provider_name = $2
  AND wpc.deleted_at IS NULL
GROUP BY wpc.provider_name, wpc.last_webhook_at, wpc.is_active
`

type GetWebhookHealthStatusParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
}

type GetWebhookHealthStatusRow struct {
	ProviderName   string             `json:"provider_name"`
	LastWebhookAt  pgtype.Timestamptz `json:"last_webhook_at"`
	ConfigActive   bool               `json:"config_active"`
	RecentEvents   int64              `json:"recent_events"`
	RecentFailures int64              `json:"recent_failures"`
	LastEventTime  interface{}        `json:"last_event_time"`
}

// Get overall webhook health for a workspace and provider
func (q *Queries) GetWebhookHealthStatus(ctx context.Context, arg GetWebhookHealthStatusParams) (GetWebhookHealthStatusRow, error) {
	row := q.db.QueryRow(ctx, getWebhookHealthStatus, arg.WorkspaceID, arg.ProviderName)
	var i GetWebhookHealthStatusRow
	err := row.Scan(
		&i.ProviderName,
		&i.LastWebhookAt,
		&i.ConfigActive,
		&i.RecentEvents,
		&i.RecentFailures,
		&i.LastEventTime,
	)
	return i, err
}

const getWebhookProcessingStats = `-- name: GetWebhookProcessingStats :one
SELECT 
    COUNT(*) as total_webhooks,
    COUNT(CASE WHEN event_type = 'webhook_processed_successfully' THEN 1 END) as successful_webhooks,
    COUNT(CASE WHEN event_type = 'webhook_processing_failed' THEN 1 END) as failed_webhooks,
    COUNT(CASE WHEN signature_valid = false THEN 1 END) as invalid_signatures,
    AVG(processing_attempts) as avg_processing_attempts,
    MAX(occurred_at) as last_webhook_time
FROM payment_sync_events
WHERE workspace_id = $1
  AND provider_name = $2
  AND webhook_event_id IS NOT NULL
  AND occurred_at >= $3
`

type GetWebhookProcessingStatsParams struct {
	WorkspaceID  uuid.UUID          `json:"workspace_id"`
	ProviderName string             `json:"provider_name"`
	OccurredAt   pgtype.Timestamptz `json:"occurred_at"`
}

type GetWebhookProcessingStatsRow struct {
	TotalWebhooks         int64       `json:"total_webhooks"`
	SuccessfulWebhooks    int64       `json:"successful_webhooks"`
	FailedWebhooks        int64       `json:"failed_webhooks"`
	InvalidSignatures     int64       `json:"invalid_signatures"`
	AvgProcessingAttempts float64     `json:"avg_processing_attempts"`
	LastWebhookTime       interface{} `json:"last_webhook_time"`
}

// Get webhook processing statistics for monitoring
func (q *Queries) GetWebhookProcessingStats(ctx context.Context, arg GetWebhookProcessingStatsParams) (GetWebhookProcessingStatsRow, error) {
	row := q.db.QueryRow(ctx, getWebhookProcessingStats, arg.WorkspaceID, arg.ProviderName, arg.OccurredAt)
	var i GetWebhookProcessingStatsRow
	err := row.Scan(
		&i.TotalWebhooks,
		&i.SuccessfulWebhooks,
		&i.FailedWebhooks,
		&i.InvalidSignatures,
		&i.AvgProcessingAttempts,
		&i.LastWebhookTime,
	)
	return i, err
}

const getWorkspaceConfigForWebhook = `-- name: GetWorkspaceConfigForWebhook :one

SELECT 
    w.id as workspace_id,
    w.name as workspace_name,
    w.livemode as workspace_livemode,
    wpc.id as config_id,
    wpc.provider_name,
    wpc.is_active as config_active,
    wpc.is_test_mode,
    wpc.configuration,
    wpc.webhook_secret_key,
    wpc.connected_account_id,
    wpa.provider_account_id,
    wpa.account_type,
    wpa.environment
FROM workspaces w
JOIN workspace_provider_accounts wpa ON w.id = wpa.workspace_id
JOIN workspace_payment_configurations wpc ON w.id = wpc.workspace_id AND wpa.provider_name = wpc.provider_name
WHERE wpa.provider_name = $1 
  AND wpa.provider_account_id = $2 
  AND wpa.environment = $3
  AND wpa.is_active = true
  AND wpc.is_active = true
  AND w.deleted_at IS NULL
  AND wpa.deleted_at IS NULL
  AND wpc.deleted_at IS NULL
`

type GetWorkspaceConfigForWebhookParams struct {
	ProviderName      string `json:"provider_name"`
	ProviderAccountID string `json:"provider_account_id"`
	Environment       string `json:"environment"`
}

type GetWorkspaceConfigForWebhookRow struct {
	WorkspaceID        uuid.UUID       `json:"workspace_id"`
	WorkspaceName      string          `json:"workspace_name"`
	WorkspaceLivemode  pgtype.Bool     `json:"workspace_livemode"`
	ConfigID           uuid.UUID       `json:"config_id"`
	ProviderName       string          `json:"provider_name"`
	ConfigActive       bool            `json:"config_active"`
	IsTestMode         bool            `json:"is_test_mode"`
	Configuration      json.RawMessage `json:"configuration"`
	WebhookSecretKey   pgtype.Text     `json:"webhook_secret_key"`
	ConnectedAccountID pgtype.Text     `json:"connected_account_id"`
	ProviderAccountID  string          `json:"provider_account_id"`
	AccountType        string          `json:"account_type"`
	Environment        string          `json:"environment"`
}

// webhook_management.sql
// Specialized queries for multi-provider webhook processing in AWS Lambda
// Combined query to get workspace and configuration for webhook processing
func (q *Queries) GetWorkspaceConfigForWebhook(ctx context.Context, arg GetWorkspaceConfigForWebhookParams) (GetWorkspaceConfigForWebhookRow, error) {
	row := q.db.QueryRow(ctx, getWorkspaceConfigForWebhook, arg.ProviderName, arg.ProviderAccountID, arg.Environment)
	var i GetWorkspaceConfigForWebhookRow
	err := row.Scan(
		&i.WorkspaceID,
		&i.WorkspaceName,
		&i.WorkspaceLivemode,
		&i.ConfigID,
		&i.ProviderName,
		&i.ConfigActive,
		&i.IsTestMode,
		&i.Configuration,
		&i.WebhookSecretKey,
		&i.ConnectedAccountID,
		&i.ProviderAccountID,
		&i.AccountType,
		&i.Environment,
	)
	return i, err
}

const logDLQProcessingAttempt = `-- name: LogDLQProcessingAttempt :one
INSERT INTO payment_sync_events (
    workspace_id,
    provider_name,
    entity_type,
    event_type,
    event_message,
    event_details,
    webhook_event_id,
    provider_account_id,
    processing_attempts
) VALUES (
    $1, $2, 'dlq_processing', $3, $4, $5, $6, $7, $8
) RETURNING id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at
`

type LogDLQProcessingAttemptParams struct {
	WorkspaceID        uuid.UUID   `json:"workspace_id"`
	ProviderName       string      `json:"provider_name"`
	EventType          string      `json:"event_type"`
	EventMessage       pgtype.Text `json:"event_message"`
	EventDetails       []byte      `json:"event_details"`
	WebhookEventID     pgtype.Text `json:"webhook_event_id"`
	ProviderAccountID  pgtype.Text `json:"provider_account_id"`
	ProcessingAttempts pgtype.Int4 `json:"processing_attempts"`
}

// Log DLQ processing attempt
func (q *Queries) LogDLQProcessingAttempt(ctx context.Context, arg LogDLQProcessingAttemptParams) (PaymentSyncEvent, error) {
	row := q.db.QueryRow(ctx, logDLQProcessingAttempt,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.EventType,
		arg.EventMessage,
		arg.EventDetails,
		arg.WebhookEventID,
		arg.ProviderAccountID,
		arg.ProcessingAttempts,
	)
	var i PaymentSyncEvent
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.EntityType,
		&i.EntityID,
		&i.ExternalID,
		&i.EventType,
		&i.EventMessage,
		&i.EventDetails,
		&i.WebhookEventID,
		&i.ProviderAccountID,
		&i.IdempotencyKey,
		&i.ProcessingAttempts,
		&i.SignatureValid,
		&i.OccurredAt,
	)
	return i, err
}

const logWebhookReceived = `-- name: LogWebhookReceived :one
INSERT INTO payment_sync_events (
    workspace_id,
    provider_name,
    entity_type,
    event_type,
    event_message,
    event_details,
    webhook_event_id,
    provider_account_id,
    idempotency_key,
    signature_valid
) VALUES (
    $1, $2, 'webhook', 'webhook_received', $3, $4, $5, $6, $7, $8
) RETURNING id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at
`

type LogWebhookReceivedParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	ProviderName      string      `json:"provider_name"`
	EventMessage      pgtype.Text `json:"event_message"`
	EventDetails      []byte      `json:"event_details"`
	WebhookEventID    pgtype.Text `json:"webhook_event_id"`
	ProviderAccountID pgtype.Text `json:"provider_account_id"`
	IdempotencyKey    pgtype.Text `json:"idempotency_key"`
	SignatureValid    pgtype.Bool `json:"signature_valid"`
}

// Log incoming webhook before processing
func (q *Queries) LogWebhookReceived(ctx context.Context, arg LogWebhookReceivedParams) (PaymentSyncEvent, error) {
	row := q.db.QueryRow(ctx, logWebhookReceived,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.EventMessage,
		arg.EventDetails,
		arg.WebhookEventID,
		arg.ProviderAccountID,
		arg.IdempotencyKey,
		arg.SignatureValid,
	)
	var i PaymentSyncEvent
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.EntityType,
		&i.EntityID,
		&i.ExternalID,
		&i.EventType,
		&i.EventMessage,
		&i.EventDetails,
		&i.WebhookEventID,
		&i.ProviderAccountID,
		&i.IdempotencyKey,
		&i.ProcessingAttempts,
		&i.SignatureValid,
		&i.OccurredAt,
	)
	return i, err
}

const markWebhookForRetry = `-- name: MarkWebhookForRetry :one
UPDATE payment_sync_events
SET 
    event_type = 'webhook_retry_queued',
    event_details = COALESCE(event_details, '{}'::jsonb) || jsonb_build_object(
        'retry_queued_at', EXTRACT(epoch FROM CURRENT_TIMESTAMP),
        'retry_attempt', processing_attempts + 1
    )
WHERE id = $1
RETURNING id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at
`

// Mark a webhook event for retry processing
func (q *Queries) MarkWebhookForRetry(ctx context.Context, id uuid.UUID) (PaymentSyncEvent, error) {
	row := q.db.QueryRow(ctx, markWebhookForRetry, id)
	var i PaymentSyncEvent
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.EntityType,
		&i.EntityID,
		&i.ExternalID,
		&i.EventType,
		&i.EventMessage,
		&i.EventDetails,
		&i.WebhookEventID,
		&i.ProviderAccountID,
		&i.IdempotencyKey,
		&i.ProcessingAttempts,
		&i.SignatureValid,
		&i.OccurredAt,
	)
	return i, err
}

const replayWebhookEvent = `-- name: ReplayWebhookEvent :one
INSERT INTO payment_sync_events (
    workspace_id,
    provider_name,
    entity_type,
    event_type,
    event_message,
    event_details,
    webhook_event_id,
    provider_account_id,
    idempotency_key,
    signature_valid,
    processing_attempts
) VALUES (
    $1, $2, 'webhook', 'webhook_replayed', $3, $4, $5, $6, $7, $8, 0
) RETURNING id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at
`

type ReplayWebhookEventParams struct {
	WorkspaceID       uuid.UUID   `json:"workspace_id"`
	ProviderName      string      `json:"provider_name"`
	EventMessage      pgtype.Text `json:"event_message"`
	EventDetails      []byte      `json:"event_details"`
	WebhookEventID    pgtype.Text `json:"webhook_event_id"`
	ProviderAccountID pgtype.Text `json:"provider_account_id"`
	IdempotencyKey    pgtype.Text `json:"idempotency_key"`
	SignatureValid    pgtype.Bool `json:"signature_valid"`
}

// Create a new event record for webhook replay
func (q *Queries) ReplayWebhookEvent(ctx context.Context, arg ReplayWebhookEventParams) (PaymentSyncEvent, error) {
	row := q.db.QueryRow(ctx, replayWebhookEvent,
		arg.WorkspaceID,
		arg.ProviderName,
		arg.EventMessage,
		arg.EventDetails,
		arg.WebhookEventID,
		arg.ProviderAccountID,
		arg.IdempotencyKey,
		arg.SignatureValid,
	)
	var i PaymentSyncEvent
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.EntityType,
		&i.EntityID,
		&i.ExternalID,
		&i.EventType,
		&i.EventMessage,
		&i.EventDetails,
		&i.WebhookEventID,
		&i.ProviderAccountID,
		&i.IdempotencyKey,
		&i.ProcessingAttempts,
		&i.SignatureValid,
		&i.OccurredAt,
	)
	return i, err
}

const resumeSyncSession = `-- name: ResumeSyncSession :one
UPDATE payment_sync_sessions
SET 
    status = 'running',
    progress = COALESCE(progress, '{}'::jsonb) || jsonb_build_object(
        'resumed_at', EXTRACT(epoch FROM CURRENT_TIMESTAMP),
        'resume_count', COALESCE((progress->>'resume_count')::int, 0) + 1
    ),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
  AND workspace_id = $2
  AND status IN ('failed', 'running')
RETURNING id, workspace_id, provider_name, session_type, status, entity_types, config, progress, error_summary, started_at, completed_at, created_at, updated_at, deleted_at
`

type ResumeSyncSessionParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

// Resume a failed sync session by updating its status
func (q *Queries) ResumeSyncSession(ctx context.Context, arg ResumeSyncSessionParams) (PaymentSyncSession, error) {
	row := q.db.QueryRow(ctx, resumeSyncSession, arg.ID, arg.WorkspaceID)
	var i PaymentSyncSession
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.SessionType,
		&i.Status,
		&i.EntityTypes,
		&i.Config,
		&i.Progress,
		&i.ErrorSummary,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateLastWebhookTime = `-- name: UpdateLastWebhookTime :exec
UPDATE workspace_payment_configurations
SET 
    last_webhook_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE workspace_id = $1 
  AND provider_name = $2
  AND deleted_at IS NULL
`

type UpdateLastWebhookTimeParams struct {
	WorkspaceID  uuid.UUID `json:"workspace_id"`
	ProviderName string    `json:"provider_name"`
}

// Update the last webhook received time for a workspace configuration
func (q *Queries) UpdateLastWebhookTime(ctx context.Context, arg UpdateLastWebhookTimeParams) error {
	_, err := q.db.Exec(ctx, updateLastWebhookTime, arg.WorkspaceID, arg.ProviderName)
	return err
}

const updateWebhookProcessingStatus = `-- name: UpdateWebhookProcessingStatus :one
UPDATE payment_sync_events
SET 
    event_type = $2,
    event_message = $3,
    event_details = COALESCE(event_details, '{}'::jsonb) || $4,
    processing_attempts = processing_attempts + 1
WHERE id = $1
RETURNING id, session_id, workspace_id, provider_name, entity_type, entity_id, external_id, event_type, event_message, event_details, webhook_event_id, provider_account_id, idempotency_key, processing_attempts, signature_valid, occurred_at
`

type UpdateWebhookProcessingStatusParams struct {
	ID           uuid.UUID   `json:"id"`
	EventType    string      `json:"event_type"`
	EventMessage pgtype.Text `json:"event_message"`
	EventDetails []byte      `json:"event_details"`
}

// Update webhook processing status (success/failure)
func (q *Queries) UpdateWebhookProcessingStatus(ctx context.Context, arg UpdateWebhookProcessingStatusParams) (PaymentSyncEvent, error) {
	row := q.db.QueryRow(ctx, updateWebhookProcessingStatus,
		arg.ID,
		arg.EventType,
		arg.EventMessage,
		arg.EventDetails,
	)
	var i PaymentSyncEvent
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.WorkspaceID,
		&i.ProviderName,
		&i.EntityType,
		&i.EntityID,
		&i.ExternalID,
		&i.EventType,
		&i.EventMessage,
		&i.EventDetails,
		&i.WebhookEventID,
		&i.ProviderAccountID,
		&i.IdempotencyKey,
		&i.ProcessingAttempts,
		&i.SignatureValid,
		&i.OccurredAt,
	)
	return i, err
}
